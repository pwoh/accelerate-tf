
==================== FINAL INTERFACE ====================
2017-08-29 05:28:48.766292 UTC

interface accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Data.Fold 8002
  interface hash: a75222b234534a9bbd914865d5a71f9d
  ABI hash: 43c1a501adb33e17d0d5cc8c1ea797ed
  export-list hash: dde564bbb93dd34959098d457b90eeb3
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: cf0f03fc63fe7a8b52e14d606c5a934e
  sig of: Nothing
  used TH splices: False
  where
exports:
  Data.Array.Accelerate.Data.Fold.runFold
  Data.Array.Accelerate.Data.Fold.Fold{Data.Array.Accelerate.Data.Fold.Fold}
module dependencies: Data.Array.Accelerate
                     Data.Array.Accelerate.AST Data.Array.Accelerate.Analysis.Hash
                     Data.Array.Accelerate.Analysis.Hash.TH
                     Data.Array.Accelerate.Analysis.Match
                     Data.Array.Accelerate.Analysis.Shape
                     Data.Array.Accelerate.Array.Data
                     Data.Array.Accelerate.Array.Representation
                     Data.Array.Accelerate.Array.Sugar
                     Data.Array.Accelerate.Array.Unique Data.Array.Accelerate.Classes
                     Data.Array.Accelerate.Classes.Bounded
                     Data.Array.Accelerate.Classes.Enum Data.Array.Accelerate.Classes.Eq
                     Data.Array.Accelerate.Classes.Floating
                     Data.Array.Accelerate.Classes.Fractional
                     Data.Array.Accelerate.Classes.FromIntegral
                     Data.Array.Accelerate.Classes.Integral
                     Data.Array.Accelerate.Classes.Num Data.Array.Accelerate.Classes.Ord
                     Data.Array.Accelerate.Classes.Real
                     Data.Array.Accelerate.Classes.RealFloat
                     Data.Array.Accelerate.Classes.RealFrac
                     Data.Array.Accelerate.Classes.ToFloating
                     Data.Array.Accelerate.Data.Bits Data.Array.Accelerate.Data.Monoid
                     Data.Array.Accelerate.Debug Data.Array.Accelerate.Debug.Flags
                     Data.Array.Accelerate.Debug.Monitoring
                     Data.Array.Accelerate.Debug.Stats Data.Array.Accelerate.Debug.Timed
                     Data.Array.Accelerate.Debug.Trace Data.Array.Accelerate.Error
                     Data.Array.Accelerate.Language Data.Array.Accelerate.Lifetime
                     Data.Array.Accelerate.Lift Data.Array.Accelerate.Prelude
                     Data.Array.Accelerate.Pretty Data.Array.Accelerate.Pretty.Graphviz
                     Data.Array.Accelerate.Pretty.Graphviz.Monad
                     Data.Array.Accelerate.Pretty.Graphviz.Type
                     Data.Array.Accelerate.Pretty.Print Data.Array.Accelerate.Product
                     Data.Array.Accelerate.Smart Data.Array.Accelerate.Trafo
                     Data.Array.Accelerate.Trafo.Algebra
                     Data.Array.Accelerate.Trafo.Base Data.Array.Accelerate.Trafo.Fusion
                     Data.Array.Accelerate.Trafo.Rewrite
                     Data.Array.Accelerate.Trafo.Sharing
                     Data.Array.Accelerate.Trafo.Shrink
                     Data.Array.Accelerate.Trafo.Simplify
                     Data.Array.Accelerate.Trafo.Substitution Data.Array.Accelerate.Type
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.1.0
                      base-orphans-0.6@base-orphans-0.6-AbJ3lKVXygDCG0eeQEv8Iu
                      binary-0.8.3.0@binary-0.8.3.0
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0
                      fclabels-2.0.3.2@fclabels-2.0.3.2-4EezQlp7n1w9uoh5Y3yxAt
                      ghc-boot-th-8.0.2@ghc-boot-th-8.0.2 ghc-prim-0.5.0.0
                      hashable-1.2.6.1@hashable-1.2.6.1-2ZLNuHq395GGIHwEHuqZol
                      hashtables-1.2.1.1@hashtables-1.2.1.1-CvCXxmZFzjODUwEtnf4YU7
                      integer-gmp-1.0.0.1 mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6
                      pretty-1.1.3.3@pretty-1.1.3.3
                      primitive-0.6.2.0@primitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh
                      template-haskell-2.11.1.0
                      text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00
                      transformers-0.5.2.0@transformers-0.5.2.0
                      unique-0@unique-0-9CJQKYGbqiDaFUmoekKeA
                      unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC
                      vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ
orphans: accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.Bounded
         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.Enum
         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.Eq
         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.Floating
         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.Fractional
         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.Integral
         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.Num
         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.Ord
         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.Real
         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.RealFloat
         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.RealFrac
         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Data.Monoid
         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Pretty
         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Trafo
         base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         base-orphans-0.6@base-orphans-0.6-AbJ3lKVXygDCG0eeQEv8Iu:Data.Orphans
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
         fclabels-2.0.3.2@fclabels-2.0.3.2-4EezQlp7n1w9uoh5Y3yxAt:Data.Label.Point
         hashable-1.2.6.1@hashable-1.2.6.1-2ZLNuHq395GGIHwEHuqZol:Data.Hashable.Generic
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Lazy
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Show
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Fusion.Bundle
         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Unboxed
family instance modules: accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Array.Data
                         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Array.Representation
                         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Array.Sugar
                         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Data.Monoid
                         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Lift
                         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Prelude
                         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Product
                         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Smart
                         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Trafo.Base
                         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Trafo.Sharing
                         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Trafo.Substitution
                         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Type
                         base-4.9.1.0:Control.Applicative base-4.9.1.0:Data.Complex
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Compose
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.Functor.Product base-4.9.1.0:Data.Functor.Sum
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         ghc-boot-th-8.0.2@ghc-boot-th-8.0.2:GHC.LanguageExtensions.Type
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.HughesPJ
                         primitive-0.6.2.0@primitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh:Control.Monad.Primitive
                         primitive-0.6.2.0@primitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh:Data.Primitive.Array
                         template-haskell-2.11.1.0:Language.Haskell.TH.Syntax
                         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text
                         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Lazy
                         unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC:Data.HashMap.Base
                         unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC:Data.HashSet
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Primitive
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Unboxed
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Unboxed.Base
import  -/  Data.Array.Accelerate c5ccb922c9a8ba9bac33e6d6581e4614
  exports: 4984901c27895514887a0937ecd3a099
import  -/  Data.Array.Accelerate.Array.Sugar 1095a84a969562bd64b7800341e0d23c
  :. 78f23e81404aaf1e43268a71a575425c
  Array 78f23e81404aaf1e43268a71a575425c
  Elt 78f23e81404aaf1e43268a71a575425c
  Shape 78f23e81404aaf1e43268a71a575425c
import  -/  Data.Array.Accelerate.Classes.Floating 78c7950257cd37d694096876cf1b7382
  Floating c6033b504a6fb428fc9d28610d2d2d7f
import  -/  Data.Array.Accelerate.Classes.Fractional 74c1164036fe4be54acc34add9158746
  Fractional 6f99f01ef298935759845630a1e863d2
import  -/  Data.Array.Accelerate.Classes.Num 5830cb8ce2e6617e88ff07c7f188117f
  Num 13b6af1dd60ee5505ca10fef83916e95
import  -/  Data.Array.Accelerate.Data.Monoid 48c19df96f38ffb60b89276e0f717a6f
  exports: 9a748afd1326252cf0665225482b62b3
import  -/  Data.Array.Accelerate.Language 524bed6c61291389f36fc32a525eca39
  fold f7d77a209a3a47753e68a79091cae799
  map 5b504dcdeac486970efeb2aa6abad1c8
import  -/  Data.Array.Accelerate.Lift 454e17a2929036e6ccaa20714d77504c
  lift e513fb85b3ecd1c6d6ecd1c153e280b8
  unlift f5a24af2e6ef4bde78101039418077e7
import  -/  Data.Array.Accelerate.Smart c6a471aeed497009ce791e94dc05d100
  Acc dff601899922d9e86e5ab6941dfbac5f
  Exp dff601899922d9e86e5ab6941dfbac5f
  constant 8196d527ad9044191643ad6b39858685
import  -/  base-4.9.1.0:Control.Applicative 32430a90492e727f4bd80db71c28600c
import  -/  base-4.9.1.0:Data.Monoid 51cc9cd8c130d49ba96b7c2c2406022b
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Float 33e2b9ffe427edd6a5c2fd6a3b26703c
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Real 82e4e59051a13dba1da63e1e970a69e6
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
a4763fc6a11b8645f6b408759686d4c9
  $fApplicativeFold ::
    GHC.Base.Applicative (Data.Array.Accelerate.Data.Fold.Fold i)
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ i.
                  @ (Data.Array.Accelerate.Data.Fold.Fold i)
                  (Data.Array.Accelerate.Data.Fold.$fFunctorFold @ i)
                  (Data.Array.Accelerate.Data.Fold.$fApplicativeFold_$cpure @ i)
                  (Data.Array.Accelerate.Data.Fold.$fApplicativeFold_$c<*> @ i)
                  (Data.Array.Accelerate.Data.Fold.$fApplicativeFold_$c*> @ i)
                  (Data.Array.Accelerate.Data.Fold.$fApplicativeFold_$c<* @ i) -}
4eacb4ba0d3c5781bfad77ed1c252ad1
  $fApplicativeFold1 ::
    i
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc Data.Array.Accelerate.Smart.Exp ()
  {- Arity: 1, Strictness: <L,A>m2,
     Unfolding: InlineRule (1, True, True)
                (\ @ i (ds :: i) ->
                 Data.Array.Accelerate.Data.Fold.$fApplicativeFold2) -}
0fcfd273ee82c17f125e621aa987d4ad
  $fApplicativeFold2 ::
    Data.Array.Accelerate.Smart.PreExp
      Data.Array.Accelerate.Smart.Acc Data.Array.Accelerate.Smart.Exp ()
  {- Strictness: m2,
     Unfolding: (Data.Array.Accelerate.Smart.Const
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ ()
                   Data.Array.Accelerate.Array.Sugar.$fElt()
                   GHC.Tuple.()) -}
a4763fc6a11b8645f6b408759686d4c9
  $fApplicativeFold_$c*> ::
    Data.Array.Accelerate.Data.Fold.Fold i a
    -> Data.Array.Accelerate.Data.Fold.Fold i b
    -> Data.Array.Accelerate.Data.Fold.Fold i b
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ i
                   @ a
                   @ b
                   (eta :: Data.Array.Accelerate.Data.Fold.Fold i a)
                   (eta1 :: Data.Array.Accelerate.Data.Fold.Fold i b) ->
                 case eta of wild { Data.Array.Accelerate.Data.Fold.Fold w $dElt $dMonoid tally summarise ->
                 Data.Array.Accelerate.Data.Fold.$fApplicativeFold_$c<*>
                   @ i
                   @ b
                   @ b
                   (Data.Array.Accelerate.Data.Fold.Fold
                      @ i
                      @ (b -> b)
                      @ w
                      $dElt
                      $dMonoid
                      tally
                      (\ (x :: Data.Array.Accelerate.Smart.Exp w) (eta2 :: b) -> eta2))
                   eta1 }) -}
a4763fc6a11b8645f6b408759686d4c9
  $fApplicativeFold_$c<* ::
    Data.Array.Accelerate.Data.Fold.Fold i a
    -> Data.Array.Accelerate.Data.Fold.Fold i b
    -> Data.Array.Accelerate.Data.Fold.Fold i a
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ @ i
                   @ a
                   @ b
                   (eta :: Data.Array.Accelerate.Data.Fold.Fold i a)
                   (eta1 :: Data.Array.Accelerate.Data.Fold.Fold i b) ->
                 case eta of wild { Data.Array.Accelerate.Data.Fold.Fold w $dElt $dMonoid tally summarise ->
                 Data.Array.Accelerate.Data.Fold.$fApplicativeFold_$c<*>
                   @ i
                   @ b
                   @ a
                   (Data.Array.Accelerate.Data.Fold.Fold
                      @ i
                      @ (b -> a)
                      @ w
                      $dElt
                      $dMonoid
                      tally
                      (\ (x :: Data.Array.Accelerate.Smart.Exp w) ->
                       let { x1 :: a = summarise x } in \ (ds :: b) -> x1))
                   eta1 }) -}
a4763fc6a11b8645f6b408759686d4c9
  $fApplicativeFold_$c<*> ::
    Data.Array.Accelerate.Data.Fold.Fold i (a -> b)
    -> Data.Array.Accelerate.Data.Fold.Fold i a
    -> Data.Array.Accelerate.Data.Fold.Fold i b
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ @ i
                   @ a
                   @ b
                   (ds :: Data.Array.Accelerate.Data.Fold.Fold i (a -> b))
                   (ds1 :: Data.Array.Accelerate.Data.Fold.Fold i a) ->
                 case ds of wild { Data.Array.Accelerate.Data.Fold.Fold w $dElt $dMonoid tF sF ->
                 case ds1 of wild1 { Data.Array.Accelerate.Data.Fold.Fold w1 $dElt1 $dMonoid1 tX sX ->
                 let {
                   $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple (w, w1)
                   = Data.Array.Accelerate.Product.$fIsProductcst(,)
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ w
                       @ w1
                       $dElt
                       $dElt1
                 } in
                 let {
                   $dElt2 :: Data.Array.Accelerate.Array.Sugar.Elt (w, w1)
                   = Data.Array.Accelerate.Array.Sugar.$fElt(,) @ w @ w1 $dElt $dElt1
                 } in
                 let {
                   lvl2 :: Data.Array.Accelerate.Product.IsProduct
                             Data.Array.Accelerate.Array.Sugar.Elt
                             (Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp w),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp w1))
                   = Data.Array.Accelerate.Product.$fIsProductcst(,)
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp w))
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp w1))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <w>_N)))_R
                       $dElt1
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <w1>_N)))_R
                 } in
                 let {
                   lvl3 :: Data.Array.Accelerate.Array.Sugar.Elt
                             (Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp w),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp w1))
                   = Data.Array.Accelerate.Array.Sugar.$fElt(,)
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp w))
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp w1))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <w>_N)))_R
                       $dElt1
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <w1>_N)))_R
                 } in
                 Data.Array.Accelerate.Data.Fold.Fold
                   @ i
                   @ b
                   @ (w, w1)
                   $dElt2
                   (Data.Array.Accelerate.Data.Monoid.$fMonoidExp2
                      @ w
                      @ w1
                      $dElt
                      $dElt1
                      $dMonoid
                      $dMonoid1)
                   (\ (i1 :: i) ->
                    Data.Array.Accelerate.Smart.Tuple
                      @ Data.Array.Accelerate.Smart.Acc
                      @ Data.Array.Accelerate.Smart.Exp
                      @ (Data.Array.Accelerate.Lift.Plain
                           (Data.Array.Accelerate.Smart.Exp w,
                            Data.Array.Accelerate.Smart.Exp w1))
                      lvl3
                        `cast`
                      (Data.Array.Accelerate.Array.Sugar.Elt
                         (Sym (Data.Array.Accelerate.Lift.D:R:Plain(,)0[0]
                                   <Data.Array.Accelerate.Smart.Exp w1>_N
                                   <Data.Array.Accelerate.Smart.Exp w>_N)))_R
                      lvl2
                        `cast`
                      (Data.Array.Accelerate.Product.IsProduct
                         <Data.Array.Accelerate.Array.Sugar.Elt>_N
                         (Sym (Data.Array.Accelerate.Lift.D:R:Plain(,)0[0]
                                   <Data.Array.Accelerate.Smart.Exp w1>_N
                                   <Data.Array.Accelerate.Smart.Exp w>_N)))_R
                      (Data.Array.Accelerate.Array.Sugar.SnocTup
                         @ Data.Array.Accelerate.Smart.Exp
                         @ (((),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp w)),
                            Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp w1))
                         @ (Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp w1))
                         @ ((),
                            Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp w))
                         @~ <(((),
                               Data.Array.Accelerate.Lift.Plain
                                 (Data.Array.Accelerate.Smart.Exp w)),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp w1))>_N
                         $dElt1
                           `cast`
                         (Data.Array.Accelerate.Array.Sugar.Elt
                            (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <w1>_N)))_R
                         (Data.Array.Accelerate.Array.Sugar.SnocTup
                            @ Data.Array.Accelerate.Smart.Exp
                            @ ((),
                               Data.Array.Accelerate.Lift.Plain
                                 (Data.Array.Accelerate.Smart.Exp w))
                            @ (Data.Array.Accelerate.Lift.Plain
                                 (Data.Array.Accelerate.Smart.Exp w))
                            @ ()
                            @~ <((),
                                 Data.Array.Accelerate.Lift.Plain
                                   (Data.Array.Accelerate.Smart.Exp w))>_N
                            $dElt
                              `cast`
                            (Data.Array.Accelerate.Array.Sugar.Elt
                               (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <w>_N)))_R
                            (Data.Array.Accelerate.Array.Sugar.$WNilTup
                               @ Data.Array.Accelerate.Smart.Exp)
                            (tF i1)
                              `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <w>_N)))_R)
                         (tX i1)
                           `cast`
                         (Data.Array.Accelerate.Smart.Exp
                            (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <w1>_N)))_R)
                        `cast`
                      (Data.Array.Accelerate.Array.Sugar.Tuple
                         <Data.Array.Accelerate.Smart.Exp>_R
                         (Trans
                              (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                        <Data.Array.Accelerate.Lift.Plain
                                           (Data.Array.Accelerate.Smart.Exp w1)>_N
                                        <Data.Array.Accelerate.Lift.Plain
                                           (Data.Array.Accelerate.Smart.Exp w)>_N))
                              (Data.Array.Accelerate.Product.ProdRepr
                                 (Sym (Data.Array.Accelerate.Lift.D:R:Plain(,)0[0]
                                           <Data.Array.Accelerate.Smart.Exp w1>_N
                                           <Data.Array.Accelerate.Smart.Exp w>_N)))_N))_R)
                     `cast`
                   (<i>_R
                    ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Trans
                                                                         (Data.Array.Accelerate.Lift.D:R:Plain(,)[0]
                                                                              <Data.Array.Accelerate.Smart.Exp
                                                                                 w1>_N
                                                                              <Data.Array.Accelerate.Smart.Exp
                                                                                 w>_N)
                                                                         ((,)
                                                                            (Data.Array.Accelerate.Lift.D:R:PlainExp[0]
                                                                                 <w>_N)
                                                                            (Data.Array.Accelerate.Lift.D:R:PlainExp[0]
                                                                                 <w1>_N))_N))
                   (\ (t :: Data.Array.Accelerate.Smart.Exp (w, w1)) ->
                    sF
                      (Data.Array.Accelerate.Smart.Prj
                         @ Data.Array.Accelerate.Smart.Acc
                         @ Data.Array.Accelerate.Smart.Exp
                         @ w
                         @ (w, w1)
                         $dElt2
                         $dIsProduct
                         $dElt
                         (Data.Array.Accelerate.Smart.tix1 @ () @ w @ w1)
                           `cast`
                         (Data.Array.Accelerate.Product.TupleIdx
                            (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                      <w1>_N <w>_N))
                            <w>_N)_R
                         t)
                        `cast`
                      (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <w>_N)
                      (sX
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ w1
                            @ (w, w1)
                            $dElt2
                            $dIsProduct
                            $dElt1
                            (Data.Array.Accelerate.Product.$WZeroTupIdx @ w1 @ ((), w))
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                         <w1>_N <w>_N))
                               <w1>_N)_R
                            t)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <w1>_N))) } }) -}
a4763fc6a11b8645f6b408759686d4c9
  $fApplicativeFold_$cpure ::
    a -> Data.Array.Accelerate.Data.Fold.Fold i a
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ i @ a (o :: a) ->
                 Data.Array.Accelerate.Data.Fold.Fold
                   @ i
                   @ a
                   @ ()
                   Data.Array.Accelerate.Array.Sugar.$fElt()
                   Data.Array.Accelerate.Data.Monoid.$fMonoidExp3
                   (Data.Array.Accelerate.Data.Fold.$fApplicativeFold1 @ i)
                     `cast`
                   (<i>_R ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <()>_N)
                   (\ (ds :: Data.Array.Accelerate.Smart.Exp ()) -> o)) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFloatingFold ::
    Data.Array.Accelerate.Classes.Floating.Floating b =>
    GHC.Float.Floating
      (Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b))
  DFunId
  {- Arity: 1,
     Strictness: <L,U(U(U(A,U(U,U,U,U,U,U,U)),U(U,U,U,U)),U)>,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ b
                      @ a
                      ($d(%,%) :: Data.Array.Accelerate.Classes.Floating.Floating b).
                  @ (Data.Array.Accelerate.Data.Fold.Fold
                       a (Data.Array.Accelerate.Smart.Exp b))
                  (Data.Array.Accelerate.Data.Fold.$fFloatingFold_$cp1Floating
                     @ b
                     @ a
                     $d(%,%))
                  (Data.Array.Accelerate.Data.Fold.$fFloatingFold_$cpi
                     @ b
                     @ a
                     $d(%,%))
                  (Data.Array.Accelerate.Data.Fold.$fFloatingFold_$cexp
                     @ b
                     @ a
                     $d(%,%))
                  (Data.Array.Accelerate.Data.Fold.$fFloatingFold_$clog
                     @ b
                     @ a
                     $d(%,%))
                  (Data.Array.Accelerate.Data.Fold.$fFloatingFold_$csqrt
                     @ b
                     @ a
                     $d(%,%))
                  (Data.Array.Accelerate.Data.Fold.$fFloatingFold_$c**
                     @ b
                     @ a
                     $d(%,%))
                  (Data.Array.Accelerate.Data.Fold.$fFloatingFold_$clogBase
                     @ b
                     @ a
                     $d(%,%))
                  (Data.Array.Accelerate.Data.Fold.$fFloatingFold_$csin
                     @ b
                     @ a
                     $d(%,%))
                  (Data.Array.Accelerate.Data.Fold.$fFloatingFold_$ccos
                     @ b
                     @ a
                     $d(%,%))
                  (Data.Array.Accelerate.Data.Fold.$fFloatingFold_$ctan
                     @ b
                     @ a
                     $d(%,%))
                  (Data.Array.Accelerate.Data.Fold.$fFloatingFold_$casin
                     @ b
                     @ a
                     $d(%,%))
                  (Data.Array.Accelerate.Data.Fold.$fFloatingFold_$cacos
                     @ b
                     @ a
                     $d(%,%))
                  (Data.Array.Accelerate.Data.Fold.$fFloatingFold_$catan
                     @ b
                     @ a
                     $d(%,%))
                  (Data.Array.Accelerate.Data.Fold.$fFloatingFold_$csinh
                     @ b
                     @ a
                     $d(%,%))
                  (Data.Array.Accelerate.Data.Fold.$fFloatingFold_$ccosh
                     @ b
                     @ a
                     $d(%,%))
                  (Data.Array.Accelerate.Data.Fold.$fFloatingFold_$ctanh
                     @ b
                     @ a
                     $d(%,%))
                  (Data.Array.Accelerate.Data.Fold.$fFloatingFold_$casinh
                     @ b
                     @ a
                     $d(%,%))
                  (Data.Array.Accelerate.Data.Fold.$fFloatingFold_$cacosh
                     @ b
                     @ a
                     $d(%,%))
                  (Data.Array.Accelerate.Data.Fold.$fFloatingFold_$catanh
                     @ b
                     @ a
                     $d(%,%))
                  (Data.Array.Accelerate.Data.Fold.$fFloatingFold_$clog1p
                     @ b
                     @ a
                     $d(%,%))
                  (Data.Array.Accelerate.Data.Fold.$fFloatingFold_$cexpm1
                     @ b
                     @ a
                     $d(%,%))
                  (Data.Array.Accelerate.Data.Fold.$fFloatingFold_$clog1pexp
                     @ b
                     @ a
                     $d(%,%))
                  (Data.Array.Accelerate.Data.Fold.$fFloatingFold_$clog1mexp
                     @ b
                     @ a
                     $d(%,%)) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFloatingFold_$c** ::
    Data.Array.Accelerate.Classes.Floating.Floating b =>
    Data.Array.Accelerate.Data.Fold.Fold
      a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 3, Strictness: <L,1*U(A,1*U)><S,1*U><S,1*U>,
     Unfolding: (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Floating.Floating b)
                   (eta :: Data.Array.Accelerate.Data.Fold.Fold
                             a (Data.Array.Accelerate.Smart.Exp b))
                   (eta1 :: Data.Array.Accelerate.Data.Fold.Fold
                              a (Data.Array.Accelerate.Smart.Exp b)) ->
                 case eta of wild { Data.Array.Accelerate.Data.Fold.Fold w $dElt $dMonoid tally summarise ->
                 Data.Array.Accelerate.Data.Fold.$fApplicativeFold_$c<*>
                   @ a
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   (Data.Array.Accelerate.Data.Fold.Fold
                      @ a
                      @ (Data.Array.Accelerate.Smart.Exp b
                         -> Data.Array.Accelerate.Smart.Exp b)
                      @ w
                      $dElt
                      $dMonoid
                      tally
                      (let {
                         f :: GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b)
                         = GHC.Classes.$p2(%,%)
                             @ (Data.Array.Accelerate.Classes.Fractional.Fractional b)
                             @ (GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b))
                             $d(%,%)
                       } in
                       let {
                         f1 :: Data.Array.Accelerate.Smart.Exp b
                               -> Data.Array.Accelerate.Smart.Exp b
                               -> Data.Array.Accelerate.Smart.Exp b
                         = GHC.Float.** @ (Data.Array.Accelerate.Smart.Exp b) f
                       } in
                       \ (x :: Data.Array.Accelerate.Smart.Exp w) -> f1 (summarise x)))
                   eta1 }) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFloatingFold_$cacos ::
    Data.Array.Accelerate.Classes.Floating.Floating b =>
    Data.Array.Accelerate.Data.Fold.Fold
      a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(A,1*U)><S,1*U>,
     Unfolding: (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Floating.Floating b)
                   (eta :: Data.Array.Accelerate.Data.Fold.Fold
                             a (Data.Array.Accelerate.Smart.Exp b)) ->
                 case eta of wild { Data.Array.Accelerate.Data.Fold.Fold w $dElt $dMonoid tally summarise ->
                 Data.Array.Accelerate.Data.Fold.Fold
                   @ a
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   @ w
                   $dElt
                   $dMonoid
                   tally
                   (let {
                      f :: GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b)
                      = GHC.Classes.$p2(%,%)
                          @ (Data.Array.Accelerate.Classes.Fractional.Fractional b)
                          @ (GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b))
                          $d(%,%)
                    } in
                    let {
                      f1 :: Data.Array.Accelerate.Smart.Exp b
                            -> Data.Array.Accelerate.Smart.Exp b
                      = GHC.Float.acos @ (Data.Array.Accelerate.Smart.Exp b) f
                    } in
                    \ (x :: Data.Array.Accelerate.Smart.Exp w) ->
                    f1 (summarise x)) }) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFloatingFold_$cacosh ::
    Data.Array.Accelerate.Classes.Floating.Floating b =>
    Data.Array.Accelerate.Data.Fold.Fold
      a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(A,1*U)><S,1*U>,
     Unfolding: (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Floating.Floating b)
                   (eta :: Data.Array.Accelerate.Data.Fold.Fold
                             a (Data.Array.Accelerate.Smart.Exp b)) ->
                 case eta of wild { Data.Array.Accelerate.Data.Fold.Fold w $dElt $dMonoid tally summarise ->
                 Data.Array.Accelerate.Data.Fold.Fold
                   @ a
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   @ w
                   $dElt
                   $dMonoid
                   tally
                   (let {
                      f :: GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b)
                      = GHC.Classes.$p2(%,%)
                          @ (Data.Array.Accelerate.Classes.Fractional.Fractional b)
                          @ (GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b))
                          $d(%,%)
                    } in
                    let {
                      f1 :: Data.Array.Accelerate.Smart.Exp b
                            -> Data.Array.Accelerate.Smart.Exp b
                      = GHC.Float.acosh @ (Data.Array.Accelerate.Smart.Exp b) f
                    } in
                    \ (x :: Data.Array.Accelerate.Smart.Exp w) ->
                    f1 (summarise x)) }) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFloatingFold_$casin ::
    Data.Array.Accelerate.Classes.Floating.Floating b =>
    Data.Array.Accelerate.Data.Fold.Fold
      a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(A,1*U)><S,1*U>,
     Unfolding: (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Floating.Floating b)
                   (eta :: Data.Array.Accelerate.Data.Fold.Fold
                             a (Data.Array.Accelerate.Smart.Exp b)) ->
                 case eta of wild { Data.Array.Accelerate.Data.Fold.Fold w $dElt $dMonoid tally summarise ->
                 Data.Array.Accelerate.Data.Fold.Fold
                   @ a
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   @ w
                   $dElt
                   $dMonoid
                   tally
                   (let {
                      f :: GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b)
                      = GHC.Classes.$p2(%,%)
                          @ (Data.Array.Accelerate.Classes.Fractional.Fractional b)
                          @ (GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b))
                          $d(%,%)
                    } in
                    let {
                      f1 :: Data.Array.Accelerate.Smart.Exp b
                            -> Data.Array.Accelerate.Smart.Exp b
                      = GHC.Float.asin @ (Data.Array.Accelerate.Smart.Exp b) f
                    } in
                    \ (x :: Data.Array.Accelerate.Smart.Exp w) ->
                    f1 (summarise x)) }) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFloatingFold_$casinh ::
    Data.Array.Accelerate.Classes.Floating.Floating b =>
    Data.Array.Accelerate.Data.Fold.Fold
      a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(A,1*U)><S,1*U>,
     Unfolding: (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Floating.Floating b)
                   (eta :: Data.Array.Accelerate.Data.Fold.Fold
                             a (Data.Array.Accelerate.Smart.Exp b)) ->
                 case eta of wild { Data.Array.Accelerate.Data.Fold.Fold w $dElt $dMonoid tally summarise ->
                 Data.Array.Accelerate.Data.Fold.Fold
                   @ a
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   @ w
                   $dElt
                   $dMonoid
                   tally
                   (let {
                      f :: GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b)
                      = GHC.Classes.$p2(%,%)
                          @ (Data.Array.Accelerate.Classes.Fractional.Fractional b)
                          @ (GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b))
                          $d(%,%)
                    } in
                    let {
                      f1 :: Data.Array.Accelerate.Smart.Exp b
                            -> Data.Array.Accelerate.Smart.Exp b
                      = GHC.Float.asinh @ (Data.Array.Accelerate.Smart.Exp b) f
                    } in
                    \ (x :: Data.Array.Accelerate.Smart.Exp w) ->
                    f1 (summarise x)) }) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFloatingFold_$catan ::
    Data.Array.Accelerate.Classes.Floating.Floating b =>
    Data.Array.Accelerate.Data.Fold.Fold
      a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(A,1*U)><S,1*U>,
     Unfolding: (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Floating.Floating b)
                   (eta :: Data.Array.Accelerate.Data.Fold.Fold
                             a (Data.Array.Accelerate.Smart.Exp b)) ->
                 case eta of wild { Data.Array.Accelerate.Data.Fold.Fold w $dElt $dMonoid tally summarise ->
                 Data.Array.Accelerate.Data.Fold.Fold
                   @ a
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   @ w
                   $dElt
                   $dMonoid
                   tally
                   (let {
                      f :: GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b)
                      = GHC.Classes.$p2(%,%)
                          @ (Data.Array.Accelerate.Classes.Fractional.Fractional b)
                          @ (GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b))
                          $d(%,%)
                    } in
                    let {
                      f1 :: Data.Array.Accelerate.Smart.Exp b
                            -> Data.Array.Accelerate.Smart.Exp b
                      = GHC.Float.atan @ (Data.Array.Accelerate.Smart.Exp b) f
                    } in
                    \ (x :: Data.Array.Accelerate.Smart.Exp w) ->
                    f1 (summarise x)) }) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFloatingFold_$catanh ::
    Data.Array.Accelerate.Classes.Floating.Floating b =>
    Data.Array.Accelerate.Data.Fold.Fold
      a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(A,1*U)><S,1*U>,
     Unfolding: (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Floating.Floating b)
                   (eta :: Data.Array.Accelerate.Data.Fold.Fold
                             a (Data.Array.Accelerate.Smart.Exp b)) ->
                 case eta of wild { Data.Array.Accelerate.Data.Fold.Fold w $dElt $dMonoid tally summarise ->
                 Data.Array.Accelerate.Data.Fold.Fold
                   @ a
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   @ w
                   $dElt
                   $dMonoid
                   tally
                   (let {
                      f :: GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b)
                      = GHC.Classes.$p2(%,%)
                          @ (Data.Array.Accelerate.Classes.Fractional.Fractional b)
                          @ (GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b))
                          $d(%,%)
                    } in
                    let {
                      f1 :: Data.Array.Accelerate.Smart.Exp b
                            -> Data.Array.Accelerate.Smart.Exp b
                      = GHC.Float.atanh @ (Data.Array.Accelerate.Smart.Exp b) f
                    } in
                    \ (x :: Data.Array.Accelerate.Smart.Exp w) ->
                    f1 (summarise x)) }) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFloatingFold_$ccos ::
    Data.Array.Accelerate.Classes.Floating.Floating b =>
    Data.Array.Accelerate.Data.Fold.Fold
      a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(A,1*U)><S,1*U>,
     Unfolding: (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Floating.Floating b)
                   (eta :: Data.Array.Accelerate.Data.Fold.Fold
                             a (Data.Array.Accelerate.Smart.Exp b)) ->
                 case eta of wild { Data.Array.Accelerate.Data.Fold.Fold w $dElt $dMonoid tally summarise ->
                 Data.Array.Accelerate.Data.Fold.Fold
                   @ a
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   @ w
                   $dElt
                   $dMonoid
                   tally
                   (let {
                      f :: GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b)
                      = GHC.Classes.$p2(%,%)
                          @ (Data.Array.Accelerate.Classes.Fractional.Fractional b)
                          @ (GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b))
                          $d(%,%)
                    } in
                    let {
                      f1 :: Data.Array.Accelerate.Smart.Exp b
                            -> Data.Array.Accelerate.Smart.Exp b
                      = GHC.Float.cos @ (Data.Array.Accelerate.Smart.Exp b) f
                    } in
                    \ (x :: Data.Array.Accelerate.Smart.Exp w) ->
                    f1 (summarise x)) }) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFloatingFold_$ccosh ::
    Data.Array.Accelerate.Classes.Floating.Floating b =>
    Data.Array.Accelerate.Data.Fold.Fold
      a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(A,1*U)><S,1*U>,
     Unfolding: (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Floating.Floating b)
                   (eta :: Data.Array.Accelerate.Data.Fold.Fold
                             a (Data.Array.Accelerate.Smart.Exp b)) ->
                 case eta of wild { Data.Array.Accelerate.Data.Fold.Fold w $dElt $dMonoid tally summarise ->
                 Data.Array.Accelerate.Data.Fold.Fold
                   @ a
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   @ w
                   $dElt
                   $dMonoid
                   tally
                   (let {
                      f :: GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b)
                      = GHC.Classes.$p2(%,%)
                          @ (Data.Array.Accelerate.Classes.Fractional.Fractional b)
                          @ (GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b))
                          $d(%,%)
                    } in
                    let {
                      f1 :: Data.Array.Accelerate.Smart.Exp b
                            -> Data.Array.Accelerate.Smart.Exp b
                      = GHC.Float.cosh @ (Data.Array.Accelerate.Smart.Exp b) f
                    } in
                    \ (x :: Data.Array.Accelerate.Smart.Exp w) ->
                    f1 (summarise x)) }) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFloatingFold_$cexp ::
    Data.Array.Accelerate.Classes.Floating.Floating b =>
    Data.Array.Accelerate.Data.Fold.Fold
      a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(A,1*U)><S,1*U>,
     Unfolding: (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Floating.Floating b)
                   (eta :: Data.Array.Accelerate.Data.Fold.Fold
                             a (Data.Array.Accelerate.Smart.Exp b)) ->
                 case eta of wild { Data.Array.Accelerate.Data.Fold.Fold w $dElt $dMonoid tally summarise ->
                 Data.Array.Accelerate.Data.Fold.Fold
                   @ a
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   @ w
                   $dElt
                   $dMonoid
                   tally
                   (let {
                      f :: GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b)
                      = GHC.Classes.$p2(%,%)
                          @ (Data.Array.Accelerate.Classes.Fractional.Fractional b)
                          @ (GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b))
                          $d(%,%)
                    } in
                    let {
                      f1 :: Data.Array.Accelerate.Smart.Exp b
                            -> Data.Array.Accelerate.Smart.Exp b
                      = GHC.Float.exp @ (Data.Array.Accelerate.Smart.Exp b) f
                    } in
                    \ (x :: Data.Array.Accelerate.Smart.Exp w) ->
                    f1 (summarise x)) }) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFloatingFold_$cexpm1 ::
    Data.Array.Accelerate.Classes.Floating.Floating b =>
    Data.Array.Accelerate.Data.Fold.Fold
      a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 2,
     Strictness: <L,U(U(U(A,U(U,U,U,U,U,U,U)),U(U,U,U,U)),U)><L,U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (2, False, False)
                (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Floating.Floating b)
                   (eta :: Data.Array.Accelerate.Data.Fold.Fold
                             a (Data.Array.Accelerate.Smart.Exp b)) ->
                 let {
                   $dFractional :: GHC.Real.Fractional
                                     (Data.Array.Accelerate.Data.Fold.Fold
                                        a (Data.Array.Accelerate.Smart.Exp b))
                   = Data.Array.Accelerate.Data.Fold.$fFloatingFold_$cp1Floating
                       @ b
                       @ a
                       $d(%,%)
                 } in
                 let {
                   $dNum :: GHC.Num.Num
                              (Data.Array.Accelerate.Data.Fold.Fold
                                 a (Data.Array.Accelerate.Smart.Exp b))
                   = GHC.Real.$p1Fractional
                       @ (Data.Array.Accelerate.Data.Fold.Fold
                            a (Data.Array.Accelerate.Smart.Exp b))
                       $dFractional
                 } in
                 GHC.Num.-
                   @ (Data.Array.Accelerate.Data.Fold.Fold
                        a (Data.Array.Accelerate.Smart.Exp b))
                   $dNum
                   (Data.Array.Accelerate.Data.Fold.$fFloatingFold_$cexp
                      @ b
                      @ a
                      $d(%,%)
                      eta)
                   (GHC.Num.fromInteger
                      @ (Data.Array.Accelerate.Data.Fold.Fold
                           a (Data.Array.Accelerate.Smart.Exp b))
                      $dNum
                      1)) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFloatingFold_$clog ::
    Data.Array.Accelerate.Classes.Floating.Floating b =>
    Data.Array.Accelerate.Data.Fold.Fold
      a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(A,1*U)><S,1*U>,
     Unfolding: (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Floating.Floating b)
                   (eta :: Data.Array.Accelerate.Data.Fold.Fold
                             a (Data.Array.Accelerate.Smart.Exp b)) ->
                 case eta of wild { Data.Array.Accelerate.Data.Fold.Fold w $dElt $dMonoid tally summarise ->
                 Data.Array.Accelerate.Data.Fold.Fold
                   @ a
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   @ w
                   $dElt
                   $dMonoid
                   tally
                   (let {
                      f :: GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b)
                      = GHC.Classes.$p2(%,%)
                          @ (Data.Array.Accelerate.Classes.Fractional.Fractional b)
                          @ (GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b))
                          $d(%,%)
                    } in
                    let {
                      f1 :: Data.Array.Accelerate.Smart.Exp b
                            -> Data.Array.Accelerate.Smart.Exp b
                      = GHC.Float.log @ (Data.Array.Accelerate.Smart.Exp b) f
                    } in
                    \ (x :: Data.Array.Accelerate.Smart.Exp w) ->
                    f1 (summarise x)) }) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFloatingFold_$clog1mexp ::
    Data.Array.Accelerate.Classes.Floating.Floating b =>
    Data.Array.Accelerate.Data.Fold.Fold
      a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 2,
     Strictness: <L,U(U(U(A,U(U,U,U,U,U,U,U)),U(U,U,U,U)),U)><L,U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (2, False, False)
                (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Floating.Floating b)
                   (eta :: Data.Array.Accelerate.Data.Fold.Fold
                             a (Data.Array.Accelerate.Smart.Exp b)) ->
                 let {
                   $dFractional :: GHC.Real.Fractional
                                     (Data.Array.Accelerate.Data.Fold.Fold
                                        a (Data.Array.Accelerate.Smart.Exp b))
                   = Data.Array.Accelerate.Data.Fold.$fFloatingFold_$cp1Floating
                       @ b
                       @ a
                       $d(%,%)
                 } in
                 let {
                   $dNum :: GHC.Num.Num
                              (Data.Array.Accelerate.Data.Fold.Fold
                                 a (Data.Array.Accelerate.Smart.Exp b))
                   = GHC.Real.$p1Fractional
                       @ (Data.Array.Accelerate.Data.Fold.Fold
                            a (Data.Array.Accelerate.Smart.Exp b))
                       $dFractional
                 } in
                 Data.Array.Accelerate.Data.Fold.$fFloatingFold_$clog
                   @ b
                   @ a
                   $d(%,%)
                   (GHC.Num.+
                      @ (Data.Array.Accelerate.Data.Fold.Fold
                           a (Data.Array.Accelerate.Smart.Exp b))
                      $dNum
                      (GHC.Num.fromInteger
                         @ (Data.Array.Accelerate.Data.Fold.Fold
                              a (Data.Array.Accelerate.Smart.Exp b))
                         $dNum
                         1)
                      (GHC.Num.negate
                         @ (Data.Array.Accelerate.Data.Fold.Fold
                              a (Data.Array.Accelerate.Smart.Exp b))
                         (GHC.Real.$p1Fractional
                            @ (Data.Array.Accelerate.Data.Fold.Fold
                                 a (Data.Array.Accelerate.Smart.Exp b))
                            (Data.Array.Accelerate.Data.Fold.$fFloatingFold_$cp1Floating
                               @ b
                               @ a
                               $d(%,%)))
                         (Data.Array.Accelerate.Data.Fold.$fFloatingFold_$cexp
                            @ b
                            @ a
                            $d(%,%)
                            eta)))) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFloatingFold_$clog1p ::
    Data.Array.Accelerate.Classes.Floating.Floating b =>
    Data.Array.Accelerate.Data.Fold.Fold
      a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 2,
     Strictness: <L,U(U(U(A,U(U,U,U,U,U,U,U)),U(U,U,U,U)),U)><L,U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (2, False, False)
                (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Floating.Floating b)
                   (eta :: Data.Array.Accelerate.Data.Fold.Fold
                             a (Data.Array.Accelerate.Smart.Exp b)) ->
                 let {
                   $dFractional :: GHC.Real.Fractional
                                     (Data.Array.Accelerate.Data.Fold.Fold
                                        a (Data.Array.Accelerate.Smart.Exp b))
                   = Data.Array.Accelerate.Data.Fold.$fFloatingFold_$cp1Floating
                       @ b
                       @ a
                       $d(%,%)
                 } in
                 let {
                   $dNum :: GHC.Num.Num
                              (Data.Array.Accelerate.Data.Fold.Fold
                                 a (Data.Array.Accelerate.Smart.Exp b))
                   = GHC.Real.$p1Fractional
                       @ (Data.Array.Accelerate.Data.Fold.Fold
                            a (Data.Array.Accelerate.Smart.Exp b))
                       $dFractional
                 } in
                 Data.Array.Accelerate.Data.Fold.$fFloatingFold_$clog
                   @ b
                   @ a
                   $d(%,%)
                   (GHC.Num.+
                      @ (Data.Array.Accelerate.Data.Fold.Fold
                           a (Data.Array.Accelerate.Smart.Exp b))
                      $dNum
                      (GHC.Num.fromInteger
                         @ (Data.Array.Accelerate.Data.Fold.Fold
                              a (Data.Array.Accelerate.Smart.Exp b))
                         $dNum
                         1)
                      eta)) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFloatingFold_$clog1pexp ::
    Data.Array.Accelerate.Classes.Floating.Floating b =>
    Data.Array.Accelerate.Data.Fold.Fold
      a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 2,
     Strictness: <L,U(U(U(A,U(U,U,U,U,U,U,U)),U(U,U,U,U)),U)><L,U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (2, False, False)
                (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Floating.Floating b)
                   (x :: Data.Array.Accelerate.Data.Fold.Fold
                           a (Data.Array.Accelerate.Smart.Exp b)) ->
                 let {
                   $dFractional :: GHC.Real.Fractional
                                     (Data.Array.Accelerate.Data.Fold.Fold
                                        a (Data.Array.Accelerate.Smart.Exp b))
                   = Data.Array.Accelerate.Data.Fold.$fFloatingFold_$cp1Floating
                       @ b
                       @ a
                       $d(%,%)
                 } in
                 let {
                   $dNum :: GHC.Num.Num
                              (Data.Array.Accelerate.Data.Fold.Fold
                                 a (Data.Array.Accelerate.Smart.Exp b))
                   = GHC.Real.$p1Fractional
                       @ (Data.Array.Accelerate.Data.Fold.Fold
                            a (Data.Array.Accelerate.Smart.Exp b))
                       $dFractional
                 } in
                 Data.Array.Accelerate.Data.Fold.$fFloatingFold_$clog
                   @ b
                   @ a
                   $d(%,%)
                   (GHC.Num.+
                      @ (Data.Array.Accelerate.Data.Fold.Fold
                           a (Data.Array.Accelerate.Smart.Exp b))
                      $dNum
                      (GHC.Num.fromInteger
                         @ (Data.Array.Accelerate.Data.Fold.Fold
                              a (Data.Array.Accelerate.Smart.Exp b))
                         $dNum
                         1)
                      (Data.Array.Accelerate.Data.Fold.$fFloatingFold_$cexp
                         @ b
                         @ a
                         $d(%,%)
                         x))) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFloatingFold_$clogBase ::
    Data.Array.Accelerate.Classes.Floating.Floating b =>
    Data.Array.Accelerate.Data.Fold.Fold
      a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 3, Strictness: <L,1*U(A,1*U)><S,1*U><S,1*U>,
     Unfolding: (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Floating.Floating b)
                   (eta :: Data.Array.Accelerate.Data.Fold.Fold
                             a (Data.Array.Accelerate.Smart.Exp b))
                   (eta1 :: Data.Array.Accelerate.Data.Fold.Fold
                              a (Data.Array.Accelerate.Smart.Exp b)) ->
                 case eta of wild { Data.Array.Accelerate.Data.Fold.Fold w $dElt $dMonoid tally summarise ->
                 Data.Array.Accelerate.Data.Fold.$fApplicativeFold_$c<*>
                   @ a
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   (Data.Array.Accelerate.Data.Fold.Fold
                      @ a
                      @ (Data.Array.Accelerate.Smart.Exp b
                         -> Data.Array.Accelerate.Smart.Exp b)
                      @ w
                      $dElt
                      $dMonoid
                      tally
                      (let {
                         f :: GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b)
                         = GHC.Classes.$p2(%,%)
                             @ (Data.Array.Accelerate.Classes.Fractional.Fractional b)
                             @ (GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b))
                             $d(%,%)
                       } in
                       let {
                         f1 :: Data.Array.Accelerate.Smart.Exp b
                               -> Data.Array.Accelerate.Smart.Exp b
                               -> Data.Array.Accelerate.Smart.Exp b
                         = GHC.Float.logBase @ (Data.Array.Accelerate.Smart.Exp b) f
                       } in
                       \ (x :: Data.Array.Accelerate.Smart.Exp w) -> f1 (summarise x)))
                   eta1 }) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFloatingFold_$cp1Floating ::
    Data.Array.Accelerate.Classes.Floating.Floating b =>
    GHC.Real.Fractional
      (Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b))
  {- Arity: 1,
     Strictness: <L,1*U(1*U(1*U(A,U(U,U,U,U,U,U,U)),U(U,U,U,U)),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Floating.Floating b) ->
                 Data.Array.Accelerate.Data.Fold.$fFractionalFold
                   @ b
                   @ a
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Classes.Fractional.Fractional b)
                      @ (GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b))
                      $d(%,%))) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFloatingFold_$cpi ::
    Data.Array.Accelerate.Classes.Floating.Floating b =>
    Data.Array.Accelerate.Data.Fold.Fold
      a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 1, Strictness: <L,1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Floating.Floating b) ->
                 let {
                   o :: GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b)
                   = GHC.Classes.$p2(%,%)
                       @ (Data.Array.Accelerate.Classes.Fractional.Fractional b)
                       @ (GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b))
                       $d(%,%)
                 } in
                 let {
                   o1 :: Data.Array.Accelerate.Smart.Exp b
                   = GHC.Float.pi @ (Data.Array.Accelerate.Smart.Exp b) o
                 } in
                 Data.Array.Accelerate.Data.Fold.Fold
                   @ a
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   @ ()
                   Data.Array.Accelerate.Array.Sugar.$fElt()
                   Data.Array.Accelerate.Data.Monoid.$fMonoidExp3
                   (Data.Array.Accelerate.Data.Fold.$fApplicativeFold1 @ a)
                     `cast`
                   (<a>_R ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <()>_N)
                   (\ (ds :: Data.Array.Accelerate.Smart.Exp ()) -> o1)) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFloatingFold_$csin ::
    Data.Array.Accelerate.Classes.Floating.Floating b =>
    Data.Array.Accelerate.Data.Fold.Fold
      a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(A,1*U)><S,1*U>,
     Unfolding: (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Floating.Floating b)
                   (eta :: Data.Array.Accelerate.Data.Fold.Fold
                             a (Data.Array.Accelerate.Smart.Exp b)) ->
                 case eta of wild { Data.Array.Accelerate.Data.Fold.Fold w $dElt $dMonoid tally summarise ->
                 Data.Array.Accelerate.Data.Fold.Fold
                   @ a
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   @ w
                   $dElt
                   $dMonoid
                   tally
                   (let {
                      f :: GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b)
                      = GHC.Classes.$p2(%,%)
                          @ (Data.Array.Accelerate.Classes.Fractional.Fractional b)
                          @ (GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b))
                          $d(%,%)
                    } in
                    let {
                      f1 :: Data.Array.Accelerate.Smart.Exp b
                            -> Data.Array.Accelerate.Smart.Exp b
                      = GHC.Float.sin @ (Data.Array.Accelerate.Smart.Exp b) f
                    } in
                    \ (x :: Data.Array.Accelerate.Smart.Exp w) ->
                    f1 (summarise x)) }) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFloatingFold_$csinh ::
    Data.Array.Accelerate.Classes.Floating.Floating b =>
    Data.Array.Accelerate.Data.Fold.Fold
      a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(A,1*U)><S,1*U>,
     Unfolding: (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Floating.Floating b)
                   (eta :: Data.Array.Accelerate.Data.Fold.Fold
                             a (Data.Array.Accelerate.Smart.Exp b)) ->
                 case eta of wild { Data.Array.Accelerate.Data.Fold.Fold w $dElt $dMonoid tally summarise ->
                 Data.Array.Accelerate.Data.Fold.Fold
                   @ a
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   @ w
                   $dElt
                   $dMonoid
                   tally
                   (let {
                      f :: GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b)
                      = GHC.Classes.$p2(%,%)
                          @ (Data.Array.Accelerate.Classes.Fractional.Fractional b)
                          @ (GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b))
                          $d(%,%)
                    } in
                    let {
                      f1 :: Data.Array.Accelerate.Smart.Exp b
                            -> Data.Array.Accelerate.Smart.Exp b
                      = GHC.Float.sinh @ (Data.Array.Accelerate.Smart.Exp b) f
                    } in
                    \ (x :: Data.Array.Accelerate.Smart.Exp w) ->
                    f1 (summarise x)) }) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFloatingFold_$csqrt ::
    Data.Array.Accelerate.Classes.Floating.Floating b =>
    Data.Array.Accelerate.Data.Fold.Fold
      a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(A,1*U)><S,1*U>,
     Unfolding: (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Floating.Floating b)
                   (eta :: Data.Array.Accelerate.Data.Fold.Fold
                             a (Data.Array.Accelerate.Smart.Exp b)) ->
                 case eta of wild { Data.Array.Accelerate.Data.Fold.Fold w $dElt $dMonoid tally summarise ->
                 Data.Array.Accelerate.Data.Fold.Fold
                   @ a
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   @ w
                   $dElt
                   $dMonoid
                   tally
                   (let {
                      f :: GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b)
                      = GHC.Classes.$p2(%,%)
                          @ (Data.Array.Accelerate.Classes.Fractional.Fractional b)
                          @ (GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b))
                          $d(%,%)
                    } in
                    let {
                      f1 :: Data.Array.Accelerate.Smart.Exp b
                            -> Data.Array.Accelerate.Smart.Exp b
                      = GHC.Float.sqrt @ (Data.Array.Accelerate.Smart.Exp b) f
                    } in
                    \ (x :: Data.Array.Accelerate.Smart.Exp w) ->
                    f1 (summarise x)) }) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFloatingFold_$ctan ::
    Data.Array.Accelerate.Classes.Floating.Floating b =>
    Data.Array.Accelerate.Data.Fold.Fold
      a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(A,1*U)><S,1*U>,
     Unfolding: (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Floating.Floating b)
                   (eta :: Data.Array.Accelerate.Data.Fold.Fold
                             a (Data.Array.Accelerate.Smart.Exp b)) ->
                 case eta of wild { Data.Array.Accelerate.Data.Fold.Fold w $dElt $dMonoid tally summarise ->
                 Data.Array.Accelerate.Data.Fold.Fold
                   @ a
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   @ w
                   $dElt
                   $dMonoid
                   tally
                   (let {
                      f :: GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b)
                      = GHC.Classes.$p2(%,%)
                          @ (Data.Array.Accelerate.Classes.Fractional.Fractional b)
                          @ (GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b))
                          $d(%,%)
                    } in
                    let {
                      f1 :: Data.Array.Accelerate.Smart.Exp b
                            -> Data.Array.Accelerate.Smart.Exp b
                      = GHC.Float.tan @ (Data.Array.Accelerate.Smart.Exp b) f
                    } in
                    \ (x :: Data.Array.Accelerate.Smart.Exp w) ->
                    f1 (summarise x)) }) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFloatingFold_$ctanh ::
    Data.Array.Accelerate.Classes.Floating.Floating b =>
    Data.Array.Accelerate.Data.Fold.Fold
      a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(A,1*U)><S,1*U>,
     Unfolding: (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Floating.Floating b)
                   (eta :: Data.Array.Accelerate.Data.Fold.Fold
                             a (Data.Array.Accelerate.Smart.Exp b)) ->
                 case eta of wild { Data.Array.Accelerate.Data.Fold.Fold w $dElt $dMonoid tally summarise ->
                 Data.Array.Accelerate.Data.Fold.Fold
                   @ a
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   @ w
                   $dElt
                   $dMonoid
                   tally
                   (let {
                      f :: GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b)
                      = GHC.Classes.$p2(%,%)
                          @ (Data.Array.Accelerate.Classes.Fractional.Fractional b)
                          @ (GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp b))
                          $d(%,%)
                    } in
                    let {
                      f1 :: Data.Array.Accelerate.Smart.Exp b
                            -> Data.Array.Accelerate.Smart.Exp b
                      = GHC.Float.tanh @ (Data.Array.Accelerate.Smart.Exp b) f
                    } in
                    \ (x :: Data.Array.Accelerate.Smart.Exp w) ->
                    f1 (summarise x)) }) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFractionalFold ::
    Data.Array.Accelerate.Classes.Fractional.Fractional b =>
    GHC.Real.Fractional
      (Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b))
  DFunId
  {- Arity: 1,
     Strictness: <L,U(1*U(A,U(U,U,U,U,U,U,U)),U(U,U,U,U))>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ b
                      @ a
                      ($d(%,%) :: Data.Array.Accelerate.Classes.Fractional.Fractional b).
                  @ (Data.Array.Accelerate.Data.Fold.Fold
                       a (Data.Array.Accelerate.Smart.Exp b))
                  (Data.Array.Accelerate.Data.Fold.$fFractionalFold_$cp1Fractional
                     @ b
                     @ a
                     $d(%,%))
                  (Data.Array.Accelerate.Data.Fold.$fFractionalFold_$c/
                     @ b
                     @ a
                     $d(%,%))
                  (Data.Array.Accelerate.Data.Fold.$fFractionalFold_$crecip
                     @ b
                     @ a
                     $d(%,%))
                  (Data.Array.Accelerate.Data.Fold.$fFractionalFold_$cfromRational
                     @ b
                     @ a
                     $d(%,%)) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFractionalFold_$c/ ::
    Data.Array.Accelerate.Classes.Fractional.Fractional b =>
    Data.Array.Accelerate.Data.Fold.Fold
      a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 3, Strictness: <L,1*U(A,1*U)><S,1*U><S,1*U>,
     Unfolding: (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Fractional.Fractional b)
                   (eta :: Data.Array.Accelerate.Data.Fold.Fold
                             a (Data.Array.Accelerate.Smart.Exp b))
                   (eta1 :: Data.Array.Accelerate.Data.Fold.Fold
                              a (Data.Array.Accelerate.Smart.Exp b)) ->
                 case eta of wild { Data.Array.Accelerate.Data.Fold.Fold w $dElt $dMonoid tally summarise ->
                 Data.Array.Accelerate.Data.Fold.$fApplicativeFold_$c<*>
                   @ a
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   (Data.Array.Accelerate.Data.Fold.Fold
                      @ a
                      @ (Data.Array.Accelerate.Smart.Exp b
                         -> Data.Array.Accelerate.Smart.Exp b)
                      @ w
                      $dElt
                      $dMonoid
                      tally
                      (let {
                         f :: GHC.Real.Fractional (Data.Array.Accelerate.Smart.Exp b)
                         = GHC.Classes.$p2(%,%)
                             @ (Data.Array.Accelerate.Classes.Num.Num b)
                             @ (GHC.Real.Fractional (Data.Array.Accelerate.Smart.Exp b))
                             $d(%,%)
                       } in
                       let {
                         f1 :: Data.Array.Accelerate.Smart.Exp b
                               -> Data.Array.Accelerate.Smart.Exp b
                               -> Data.Array.Accelerate.Smart.Exp b
                         = GHC.Real./ @ (Data.Array.Accelerate.Smart.Exp b) f
                       } in
                       \ (x :: Data.Array.Accelerate.Smart.Exp w) -> f1 (summarise x)))
                   eta1 }) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFractionalFold_$cfromRational ::
    Data.Array.Accelerate.Classes.Fractional.Fractional b =>
    GHC.Real.Rational
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 2, Strictness: <L,1*U(A,1*U(A,A,A,1*C1(U)))><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Fractional.Fractional b)
                   (eta :: GHC.Real.Rational) ->
                 let {
                   o :: Data.Array.Accelerate.Smart.Exp b
                   = GHC.Real.fromRational
                       @ (Data.Array.Accelerate.Smart.Exp b)
                       (GHC.Classes.$p2(%,%)
                          @ (Data.Array.Accelerate.Classes.Num.Num b)
                          @ (GHC.Real.Fractional (Data.Array.Accelerate.Smart.Exp b))
                          $d(%,%))
                       eta
                 } in
                 Data.Array.Accelerate.Data.Fold.Fold
                   @ a
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   @ ()
                   Data.Array.Accelerate.Array.Sugar.$fElt()
                   Data.Array.Accelerate.Data.Monoid.$fMonoidExp3
                   (Data.Array.Accelerate.Data.Fold.$fApplicativeFold1 @ a)
                     `cast`
                   (<a>_R ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <()>_N)
                   (\ (ds :: Data.Array.Accelerate.Smart.Exp ()) -> o)) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFractionalFold_$cp1Fractional ::
    Data.Array.Accelerate.Classes.Fractional.Fractional b =>
    GHC.Num.Num
      (Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b))
  {- Arity: 1, Strictness: <L,1*U(1*U(A,U(U,U,U,U,U,U,U)),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Fractional.Fractional
                                 b) ->
                 Data.Array.Accelerate.Data.Fold.$fNumFold
                   @ b
                   @ a
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Classes.Num.Num b)
                      @ (GHC.Real.Fractional (Data.Array.Accelerate.Smart.Exp b))
                      $d(%,%))) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFractionalFold_$crecip ::
    Data.Array.Accelerate.Classes.Fractional.Fractional b =>
    Data.Array.Accelerate.Data.Fold.Fold
      a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(A,1*U)><S,1*U>,
     Unfolding: (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Fractional.Fractional b)
                   (eta :: Data.Array.Accelerate.Data.Fold.Fold
                             a (Data.Array.Accelerate.Smart.Exp b)) ->
                 case eta of wild { Data.Array.Accelerate.Data.Fold.Fold w $dElt $dMonoid tally summarise ->
                 Data.Array.Accelerate.Data.Fold.Fold
                   @ a
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   @ w
                   $dElt
                   $dMonoid
                   tally
                   (let {
                      f :: GHC.Real.Fractional (Data.Array.Accelerate.Smart.Exp b)
                      = GHC.Classes.$p2(%,%)
                          @ (Data.Array.Accelerate.Classes.Num.Num b)
                          @ (GHC.Real.Fractional (Data.Array.Accelerate.Smart.Exp b))
                          $d(%,%)
                    } in
                    let {
                      f1 :: Data.Array.Accelerate.Smart.Exp b
                            -> Data.Array.Accelerate.Smart.Exp b
                      = GHC.Real.recip @ (Data.Array.Accelerate.Smart.Exp b) f
                    } in
                    \ (x :: Data.Array.Accelerate.Smart.Exp w) ->
                    f1 (summarise x)) }) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFunctorFold ::
    GHC.Base.Functor (Data.Array.Accelerate.Data.Fold.Fold i)
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ i.
                  @ (Data.Array.Accelerate.Data.Fold.Fold i)
                  (Data.Array.Accelerate.Data.Fold.$fFunctorFold_$cfmap @ i)
                  (Data.Array.Accelerate.Data.Fold.$fFunctorFold_$c<$ @ i) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFunctorFold_$c<$ ::
    a
    -> Data.Array.Accelerate.Data.Fold.Fold i b
    -> Data.Array.Accelerate.Data.Fold.Fold i a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ i
                   @ a
                   @ b
                   (eta :: a)
                   (eta1 :: Data.Array.Accelerate.Data.Fold.Fold i b) ->
                 case eta1 of wild { Data.Array.Accelerate.Data.Fold.Fold w $dElt $dMonoid tally summarise ->
                 Data.Array.Accelerate.Data.Fold.Fold
                   @ i
                   @ a
                   @ w
                   $dElt
                   $dMonoid
                   tally
                   (\ (x :: Data.Array.Accelerate.Smart.Exp w) -> eta) }) -}
a4763fc6a11b8645f6b408759686d4c9
  $fFunctorFold_$cfmap ::
    (a -> b)
    -> Data.Array.Accelerate.Data.Fold.Fold i a
    -> Data.Array.Accelerate.Data.Fold.Fold i b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ i
                   @ a
                   @ b
                   (k :: a -> b)
                   (ds :: Data.Array.Accelerate.Data.Fold.Fold i a) ->
                 case ds of wild { Data.Array.Accelerate.Data.Fold.Fold w $dElt $dMonoid tally summarise ->
                 Data.Array.Accelerate.Data.Fold.Fold
                   @ i
                   @ b
                   @ w
                   $dElt
                   $dMonoid
                   tally
                   (GHC.Base..
                      @ a
                      @ b
                      @ (Data.Array.Accelerate.Smart.Exp w)
                      k
                      summarise) }) -}
a4763fc6a11b8645f6b408759686d4c9
  $fNumFold ::
    Data.Array.Accelerate.Classes.Num.Num b =>
    GHC.Num.Num
      (Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b))
  DFunId
  {- Arity: 1, Strictness: <L,U(A,U(U,U,U,U,U,U,U))>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ b
                      @ a
                      ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num b).
                  @ (Data.Array.Accelerate.Data.Fold.Fold
                       a (Data.Array.Accelerate.Smart.Exp b))
                  (Data.Array.Accelerate.Data.Fold.$fNumFold_$c+ @ b @ a $d(%,%))
                  (Data.Array.Accelerate.Data.Fold.$fNumFold_$c- @ b @ a $d(%,%))
                  (Data.Array.Accelerate.Data.Fold.$fNumFold_$c* @ b @ a $d(%,%))
                  (Data.Array.Accelerate.Data.Fold.$fNumFold_$cnegate
                     @ b
                     @ a
                     $d(%,%))
                  (Data.Array.Accelerate.Data.Fold.$fNumFold_$cabs @ b @ a $d(%,%))
                  (Data.Array.Accelerate.Data.Fold.$fNumFold_$csignum
                     @ b
                     @ a
                     $d(%,%))
                  (Data.Array.Accelerate.Data.Fold.$fNumFold_$cfromInteger
                     @ b
                     @ a
                     $d(%,%)) -}
a4763fc6a11b8645f6b408759686d4c9
  $fNumFold_$c* ::
    Data.Array.Accelerate.Classes.Num.Num b =>
    Data.Array.Accelerate.Data.Fold.Fold
      a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 3, Strictness: <L,1*U(A,1*U)><S,1*U><S,1*U>,
     Unfolding: (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num b)
                   (eta :: Data.Array.Accelerate.Data.Fold.Fold
                             a (Data.Array.Accelerate.Smart.Exp b))
                   (eta1 :: Data.Array.Accelerate.Data.Fold.Fold
                              a (Data.Array.Accelerate.Smart.Exp b)) ->
                 case eta of wild { Data.Array.Accelerate.Data.Fold.Fold w $dElt $dMonoid tally summarise ->
                 Data.Array.Accelerate.Data.Fold.$fApplicativeFold_$c<*>
                   @ a
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   (Data.Array.Accelerate.Data.Fold.Fold
                      @ a
                      @ (Data.Array.Accelerate.Smart.Exp b
                         -> Data.Array.Accelerate.Smart.Exp b)
                      @ w
                      $dElt
                      $dMonoid
                      tally
                      (let {
                         f :: GHC.Num.Num (Data.Array.Accelerate.Smart.Exp b)
                         = GHC.Classes.$p2(%,%)
                             @ (Data.Array.Accelerate.Array.Sugar.Elt b)
                             @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp b))
                             $d(%,%)
                       } in
                       let {
                         f1 :: Data.Array.Accelerate.Smart.Exp b
                               -> Data.Array.Accelerate.Smart.Exp b
                               -> Data.Array.Accelerate.Smart.Exp b
                         = GHC.Num.* @ (Data.Array.Accelerate.Smart.Exp b) f
                       } in
                       \ (x :: Data.Array.Accelerate.Smart.Exp w) -> f1 (summarise x)))
                   eta1 }) -}
a4763fc6a11b8645f6b408759686d4c9
  $fNumFold_$c+ ::
    Data.Array.Accelerate.Classes.Num.Num b =>
    Data.Array.Accelerate.Data.Fold.Fold
      a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 3, Strictness: <L,1*U(A,1*U)><S,1*U><S,1*U>,
     Unfolding: (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num b)
                   (eta :: Data.Array.Accelerate.Data.Fold.Fold
                             a (Data.Array.Accelerate.Smart.Exp b))
                   (eta1 :: Data.Array.Accelerate.Data.Fold.Fold
                              a (Data.Array.Accelerate.Smart.Exp b)) ->
                 case eta of wild { Data.Array.Accelerate.Data.Fold.Fold w $dElt $dMonoid tally summarise ->
                 Data.Array.Accelerate.Data.Fold.$fApplicativeFold_$c<*>
                   @ a
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   (Data.Array.Accelerate.Data.Fold.Fold
                      @ a
                      @ (Data.Array.Accelerate.Smart.Exp b
                         -> Data.Array.Accelerate.Smart.Exp b)
                      @ w
                      $dElt
                      $dMonoid
                      tally
                      (let {
                         f :: GHC.Num.Num (Data.Array.Accelerate.Smart.Exp b)
                         = GHC.Classes.$p2(%,%)
                             @ (Data.Array.Accelerate.Array.Sugar.Elt b)
                             @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp b))
                             $d(%,%)
                       } in
                       let {
                         f1 :: Data.Array.Accelerate.Smart.Exp b
                               -> Data.Array.Accelerate.Smart.Exp b
                               -> Data.Array.Accelerate.Smart.Exp b
                         = GHC.Num.+ @ (Data.Array.Accelerate.Smart.Exp b) f
                       } in
                       \ (x :: Data.Array.Accelerate.Smart.Exp w) -> f1 (summarise x)))
                   eta1 }) -}
a4763fc6a11b8645f6b408759686d4c9
  $fNumFold_$c- ::
    Data.Array.Accelerate.Classes.Num.Num b =>
    Data.Array.Accelerate.Data.Fold.Fold
      a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 3, Strictness: <L,1*U(A,1*U)><S,1*U><S,1*U>,
     Unfolding: (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num b)
                   (eta :: Data.Array.Accelerate.Data.Fold.Fold
                             a (Data.Array.Accelerate.Smart.Exp b))
                   (eta1 :: Data.Array.Accelerate.Data.Fold.Fold
                              a (Data.Array.Accelerate.Smart.Exp b)) ->
                 case eta of wild { Data.Array.Accelerate.Data.Fold.Fold w $dElt $dMonoid tally summarise ->
                 Data.Array.Accelerate.Data.Fold.$fApplicativeFold_$c<*>
                   @ a
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   (Data.Array.Accelerate.Data.Fold.Fold
                      @ a
                      @ (Data.Array.Accelerate.Smart.Exp b
                         -> Data.Array.Accelerate.Smart.Exp b)
                      @ w
                      $dElt
                      $dMonoid
                      tally
                      (let {
                         f :: GHC.Num.Num (Data.Array.Accelerate.Smart.Exp b)
                         = GHC.Classes.$p2(%,%)
                             @ (Data.Array.Accelerate.Array.Sugar.Elt b)
                             @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp b))
                             $d(%,%)
                       } in
                       let {
                         f1 :: Data.Array.Accelerate.Smart.Exp b
                               -> Data.Array.Accelerate.Smart.Exp b
                               -> Data.Array.Accelerate.Smart.Exp b
                         = GHC.Num.- @ (Data.Array.Accelerate.Smart.Exp b) f
                       } in
                       \ (x :: Data.Array.Accelerate.Smart.Exp w) -> f1 (summarise x)))
                   eta1 }) -}
a4763fc6a11b8645f6b408759686d4c9
  $fNumFold_$cabs ::
    Data.Array.Accelerate.Classes.Num.Num b =>
    Data.Array.Accelerate.Data.Fold.Fold
      a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(A,1*U)><S,1*U>,
     Unfolding: (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num b)
                   (eta :: Data.Array.Accelerate.Data.Fold.Fold
                             a (Data.Array.Accelerate.Smart.Exp b)) ->
                 case eta of wild { Data.Array.Accelerate.Data.Fold.Fold w $dElt $dMonoid tally summarise ->
                 Data.Array.Accelerate.Data.Fold.Fold
                   @ a
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   @ w
                   $dElt
                   $dMonoid
                   tally
                   (let {
                      f :: GHC.Num.Num (Data.Array.Accelerate.Smart.Exp b)
                      = GHC.Classes.$p2(%,%)
                          @ (Data.Array.Accelerate.Array.Sugar.Elt b)
                          @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp b))
                          $d(%,%)
                    } in
                    let {
                      f1 :: Data.Array.Accelerate.Smart.Exp b
                            -> Data.Array.Accelerate.Smart.Exp b
                      = GHC.Num.abs @ (Data.Array.Accelerate.Smart.Exp b) f
                    } in
                    \ (x :: Data.Array.Accelerate.Smart.Exp w) ->
                    f1 (summarise x)) }) -}
a4763fc6a11b8645f6b408759686d4c9
  $fNumFold_$cfromInteger ::
    Data.Array.Accelerate.Classes.Num.Num b =>
    GHC.Integer.Type.Integer
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 2, Strictness: <L,1*U(A,1*U(A,A,A,A,A,A,1*C1(U)))><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num b)
                   (eta :: GHC.Integer.Type.Integer) ->
                 let {
                   o :: Data.Array.Accelerate.Smart.Exp b
                   = GHC.Num.fromInteger
                       @ (Data.Array.Accelerate.Smart.Exp b)
                       (GHC.Classes.$p2(%,%)
                          @ (Data.Array.Accelerate.Array.Sugar.Elt b)
                          @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp b))
                          $d(%,%))
                       eta
                 } in
                 Data.Array.Accelerate.Data.Fold.Fold
                   @ a
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   @ ()
                   Data.Array.Accelerate.Array.Sugar.$fElt()
                   Data.Array.Accelerate.Data.Monoid.$fMonoidExp3
                   (Data.Array.Accelerate.Data.Fold.$fApplicativeFold1 @ a)
                     `cast`
                   (<a>_R ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <()>_N)
                   (\ (ds :: Data.Array.Accelerate.Smart.Exp ()) -> o)) -}
a4763fc6a11b8645f6b408759686d4c9
  $fNumFold_$cnegate ::
    Data.Array.Accelerate.Classes.Num.Num b =>
    Data.Array.Accelerate.Data.Fold.Fold
      a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(A,1*U)><S,1*U>,
     Unfolding: (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num b)
                   (eta :: Data.Array.Accelerate.Data.Fold.Fold
                             a (Data.Array.Accelerate.Smart.Exp b)) ->
                 case eta of wild { Data.Array.Accelerate.Data.Fold.Fold w $dElt $dMonoid tally summarise ->
                 Data.Array.Accelerate.Data.Fold.Fold
                   @ a
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   @ w
                   $dElt
                   $dMonoid
                   tally
                   (let {
                      f :: GHC.Num.Num (Data.Array.Accelerate.Smart.Exp b)
                      = GHC.Classes.$p2(%,%)
                          @ (Data.Array.Accelerate.Array.Sugar.Elt b)
                          @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp b))
                          $d(%,%)
                    } in
                    let {
                      f1 :: Data.Array.Accelerate.Smart.Exp b
                            -> Data.Array.Accelerate.Smart.Exp b
                      = GHC.Num.negate @ (Data.Array.Accelerate.Smart.Exp b) f
                    } in
                    \ (x :: Data.Array.Accelerate.Smart.Exp w) ->
                    f1 (summarise x)) }) -}
a4763fc6a11b8645f6b408759686d4c9
  $fNumFold_$csignum ::
    Data.Array.Accelerate.Classes.Num.Num b =>
    Data.Array.Accelerate.Data.Fold.Fold
      a (Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Data.Fold.Fold
         a (Data.Array.Accelerate.Smart.Exp b)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(A,1*U)><S,1*U>,
     Unfolding: (\ @ b
                   @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num b)
                   (eta :: Data.Array.Accelerate.Data.Fold.Fold
                             a (Data.Array.Accelerate.Smart.Exp b)) ->
                 case eta of wild { Data.Array.Accelerate.Data.Fold.Fold w $dElt $dMonoid tally summarise ->
                 Data.Array.Accelerate.Data.Fold.Fold
                   @ a
                   @ (Data.Array.Accelerate.Smart.Exp b)
                   @ w
                   $dElt
                   $dMonoid
                   tally
                   (let {
                      f :: GHC.Num.Num (Data.Array.Accelerate.Smart.Exp b)
                      = GHC.Classes.$p2(%,%)
                          @ (Data.Array.Accelerate.Array.Sugar.Elt b)
                          @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp b))
                          $d(%,%)
                    } in
                    let {
                      f1 :: Data.Array.Accelerate.Smart.Exp b
                            -> Data.Array.Accelerate.Smart.Exp b
                      = GHC.Num.signum @ (Data.Array.Accelerate.Smart.Exp b) f
                    } in
                    \ (x :: Data.Array.Accelerate.Smart.Exp w) ->
                    f1 (summarise x)) }) -}
6007629c5aee5731f32307f1fee14037
  $tc'Fold :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1354003580971296236##
                   254593570089193471##
                   Data.Array.Accelerate.Data.Fold.$trModule
                   Data.Array.Accelerate.Data.Fold.$tc'Fold1) -}
c4714d4ccf76b17c726c9f5b66a02e14
  $tc'Fold1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Fold"#) -}
cb2e9c34a10bbb56797473f7eda96783
  $tcFold :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   417957507991102996##
                   5054671281830894518##
                   Data.Array.Accelerate.Data.Fold.$trModule
                   Data.Array.Accelerate.Data.Fold.$tcFold1) -}
a97dab4f6569438d000ffbc586cc7749
  $tcFold1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Fold"#) -}
3c5a9805b8e489400411ad411a7af761
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Data.Array.Accelerate.Data.Fold.$trModule2
                   Data.Array.Accelerate.Data.Fold.$trModule1) -}
91495a10b8381da950f55d79cd8a343a
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "Data.Array.Accelerate.Data.Fold"#) -}
4deec6d6a6e3f854f66ad7d136fe6d80
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw"#) -}
a4763fc6a11b8645f6b408759686d4c9
  data Fold i o where
    Fold :: (Data.Array.Accelerate.Array.Sugar.Elt w,
             GHC.Base.Monoid (Data.Array.Accelerate.Smart.Exp w)) =>
            (i -> Data.Array.Accelerate.Smart.Exp w)
            -> (Data.Array.Accelerate.Smart.Exp w -> o) -> Fold i o
e307e473dc03ab991e3ad224ea34ac98
  runFold ::
    (Data.Array.Accelerate.Array.Sugar.Shape sh,
     Data.Array.Accelerate.Array.Sugar.Elt i,
     Data.Array.Accelerate.Array.Sugar.Elt o) =>
    Data.Array.Accelerate.Data.Fold.Fold
      (Data.Array.Accelerate.Smart.Exp i)
      (Data.Array.Accelerate.Smart.Exp o)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array
            (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) i)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array sh o)
  {- Arity: 5,
     Strictness: <S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(U(U(U,U,U),U,U,U(U,U,U,U,U,U,U,U,U),U,U,U),U(U,U,U,U(U,U,U,U,U,U,U,U,U),U,U,U),U(U(U,U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U),U(U),U(U),U(U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U><S,1*U><L,U>,
     Unfolding: (\ @ sh
                   @ i
                   @ o
                   ($dShape :: Data.Array.Accelerate.Array.Sugar.Shape sh)
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt i)
                   ($dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt o)
                   (eta :: Data.Array.Accelerate.Data.Fold.Fold
                             (Data.Array.Accelerate.Smart.Exp i)
                             (Data.Array.Accelerate.Smart.Exp o))
                   (eta1 :: Data.Array.Accelerate.Smart.Acc
                              (Data.Array.Accelerate.Array.Sugar.Array
                                 (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) i)) ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh>_N <sh>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh>_N <sh>_N) of cobox2 { DEFAULT ->
                 case eta of wild { Data.Array.Accelerate.Data.Fold.Fold w $dElt2 $dMonoid tally summarise ->
                 Data.Array.Accelerate.Language.map
                   @ sh
                   @ w
                   @ o
                   $dShape
                   $dElt2
                   $dElt1
                   summarise
                   (Data.Array.Accelerate.Language.fold
                      @ sh
                      @ w
                      $dShape
                      $dElt2
                      (GHC.Base.mappend @ (Data.Array.Accelerate.Smart.Exp w) $dMonoid)
                      (GHC.Base.mempty @ (Data.Array.Accelerate.Smart.Exp w) $dMonoid)
                      (case GHC.Types.HEq_sc
                              @ GHC.Types.*
                              @ GHC.Types.*
                              @ (Data.Array.Accelerate.Array.Sugar.SliceShape
                                   (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int))
                              @ Data.Array.Accelerate.Array.Sugar.Z
                              (Data.Array.Accelerate.Array.Sugar.$fShape:._$cp6Shape
                                 @ sh
                                 $dShape)
                                `cast`
                              (Data.Type.Equality.N:~[0]
                                   <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                      (sh
                                                       Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int)>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox3 { DEFAULT ->
                       case Data.Array.Accelerate.Array.Sugar.$w$cp5Shape
                              @ sh
                              $dShape of ww0 { DEFAULT ->
                       case Data.Array.Accelerate.Array.Sugar.$w$cp4Shape
                              @ sh
                              $dShape of ww1 { DEFAULT ->
                       (Data.Array.Accelerate.Smart.Map
                          @ Data.Array.Accelerate.Smart.Acc
                          @ Data.Array.Accelerate.Smart.Exp
                          @ (Data.Array.Accelerate.Array.Sugar.Array
                               (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) w)
                          @ (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int)
                          @ i
                          @ w
                          @~ <Data.Array.Accelerate.Array.Sugar.Array
                                (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) w>_N
                          (Data.Array.Accelerate.Array.Sugar.$fShape:. @ sh $dShape)
                          $dElt
                          $dElt2
                          tally
                          eta1)
                         `cast`
                       (Sym (Data.Array.Accelerate.Smart.N:Acc[0]) <Data.Array.Accelerate.Array.Sugar.Array
                                                                      (sh
                                                                       Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int)
                                                                      w>_N) } } })) } } } }) -}
instance GHC.Base.Applicative [Data.Array.Accelerate.Data.Fold.Fold]
  = Data.Array.Accelerate.Data.Fold.$fApplicativeFold
instance GHC.Float.Floating [Data.Array.Accelerate.Data.Fold.Fold]
  = Data.Array.Accelerate.Data.Fold.$fFloatingFold
instance GHC.Real.Fractional [Data.Array.Accelerate.Data.Fold.Fold]
  = Data.Array.Accelerate.Data.Fold.$fFractionalFold
instance GHC.Base.Functor [Data.Array.Accelerate.Data.Fold.Fold]
  = Data.Array.Accelerate.Data.Fold.$fFunctorFold
instance GHC.Num.Num [Data.Array.Accelerate.Data.Fold.Fold]
  = Data.Array.Accelerate.Data.Fold.$fNumFold
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

