
==================== FINAL INTERFACE ====================
2017-08-29 05:27:55.462295 UTC

interface accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Data.Complex [orphan module] [family instance module] 8002
  interface hash: c848a899aabb7a4a1fc7550b1ec7ffeb
  ABI hash: 22ea56b745ec45399a0ac499d88878cc
  export-list hash: 1d243201f2f4c13d7dc409f0d3e17e0a
  orphan hash: c6ee20b12d5d474f0c6e6c0a3c79d506
  flag hash: 8eba7aebe0f97d8b99f63834ca9c4be9
  sig of: Nothing
  used TH splices: False
  where
exports:
  Data.Array.Accelerate.Data.Complex.cis
  Data.Array.Accelerate.Data.Complex.conjugate
  Data.Array.Accelerate.Data.Complex.imag
  Data.Array.Accelerate.Data.Complex.magnitude
  Data.Array.Accelerate.Data.Complex.mkPolar
  Data.Array.Accelerate.Data.Complex.phase
  Data.Array.Accelerate.Data.Complex.polar
  Data.Array.Accelerate.Data.Complex.real
  Data.Complex.Complex{Data.Complex.:+}
module dependencies: Data.Array.Accelerate.AST
                     Data.Array.Accelerate.Array.Data
                     Data.Array.Accelerate.Array.Representation
                     Data.Array.Accelerate.Array.Sugar
                     Data.Array.Accelerate.Array.Unique Data.Array.Accelerate.Classes
                     Data.Array.Accelerate.Classes.Bounded
                     Data.Array.Accelerate.Classes.Enum Data.Array.Accelerate.Classes.Eq
                     Data.Array.Accelerate.Classes.Floating
                     Data.Array.Accelerate.Classes.Fractional
                     Data.Array.Accelerate.Classes.FromIntegral
                     Data.Array.Accelerate.Classes.Integral
                     Data.Array.Accelerate.Classes.Num Data.Array.Accelerate.Classes.Ord
                     Data.Array.Accelerate.Classes.Real
                     Data.Array.Accelerate.Classes.RealFloat
                     Data.Array.Accelerate.Classes.RealFrac
                     Data.Array.Accelerate.Classes.ToFloating
                     Data.Array.Accelerate.Data.Bits Data.Array.Accelerate.Debug.Flags
                     Data.Array.Accelerate.Debug.Monitoring
                     Data.Array.Accelerate.Debug.Trace Data.Array.Accelerate.Error
                     Data.Array.Accelerate.Language Data.Array.Accelerate.Lifetime
                     Data.Array.Accelerate.Lift Data.Array.Accelerate.Product
                     Data.Array.Accelerate.Smart Data.Array.Accelerate.Type
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.1.0
                      base-orphans-0.6@base-orphans-0.6-AbJ3lKVXygDCG0eeQEv8Iu
                      binary-0.8.3.0@binary-0.8.3.0
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0
                      fclabels-2.0.3.2@fclabels-2.0.3.2-4EezQlp7n1w9uoh5Y3yxAt
                      ghc-boot-th-8.0.2@ghc-boot-th-8.0.2 ghc-prim-0.5.0.0
                      hashable-1.2.6.1@hashable-1.2.6.1-2ZLNuHq395GGIHwEHuqZol
                      integer-gmp-1.0.0.1 pretty-1.1.3.3@pretty-1.1.3.3
                      template-haskell-2.11.1.0
                      text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00
                      unique-0@unique-0-9CJQKYGbqiDaFUmoekKeA
orphans: accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.Bounded
         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.Enum
         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.Eq
         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.Floating
         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.Fractional
         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.Integral
         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.Num
         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.Ord
         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.Real
         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.RealFloat
         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.RealFrac
         base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         base-orphans-0.6@base-orphans-0.6-AbJ3lKVXygDCG0eeQEv8Iu:Data.Orphans
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
         fclabels-2.0.3.2@fclabels-2.0.3.2-4EezQlp7n1w9uoh5Y3yxAt:Data.Label.Point
         hashable-1.2.6.1@hashable-1.2.6.1-2ZLNuHq395GGIHwEHuqZol:Data.Hashable.Generic
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Lazy
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Show
family instance modules: accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Array.Data
                         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Array.Representation
                         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Array.Sugar
                         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Lift
                         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Product
                         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Smart
                         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Type
                         base-4.9.1.0:Control.Applicative base-4.9.1.0:Data.Complex
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Compose
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.Functor.Product base-4.9.1.0:Data.Functor.Sum
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         ghc-boot-th-8.0.2@ghc-boot-th-8.0.2:GHC.LanguageExtensions.Type
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.HughesPJ
                         template-haskell-2.11.1.0:Language.Haskell.TH.Syntax
                         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text
                         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Lazy
import  -/  Data.Array.Accelerate.Array.Sugar 1095a84a969562bd64b7800341e0d23c
  exports: a6dd551b39ab2a3a217fc8c2a6979cd5
  Elt 78f23e81404aaf1e43268a71a575425c
  EltRepr 78f23e81404aaf1e43268a71a575425c
  NilTup 36796631cb3a95a68e6a4dde7e7b2bbe
  SnocTup ef3a739bcf04e48a53d49112dce542ea
  eltType 21a580fd17202e5faf93897dd670e4dd
  fromElt 861af21aa559d711d2643de35185f0ce
  toElt fb51c826f81999ac82f2cc2c37722ff3
import  -/  Data.Array.Accelerate.Classes 3cbb285ad010ed9f78ac56aaa84a6df0
  exports: 6bc498d1dca1fdfc299ab10a52211a73
import  -/  Data.Array.Accelerate.Classes.Eq b5abcb6d2b1b2f77926ba32e74c56bfd
  && fd3fbc575278d01240f55b5285c81d9c
  /= bfd246b5fc13bff4fe92c8890493d0d4
  == 373f16d63bf36dcf6c5be36579a78740
  Eq 52ed39f384f936d7cab795259d55d4b0
  || 385cac0096364cd1168d80272fce6db4
import  -/  Data.Array.Accelerate.Classes.Floating 78c7950257cd37d694096876cf1b7382
  Floating c6033b504a6fb428fc9d28610d2d2d7f
import  -/  Data.Array.Accelerate.Classes.FromIntegral c06fea6ff5a7af191d75e7f95b36e541
  FromIntegral a95a2a699889c53924901c0ef834b946
  fromIntegral 9dddad050c551c7877d059293b3447c7
import  -/  Data.Array.Accelerate.Classes.Num 5830cb8ce2e6617e88ff07c7f188117f
  Num 13b6af1dd60ee5505ca10fef83916e95
import  -/  Data.Array.Accelerate.Classes.Ord 838718467444fc3520e0ce057ae54e2a
  < fb7363126baf54c55879edf3cf13ee03
import  -/  Data.Array.Accelerate.Classes.RealFloat d0a972f761ddfd864af916d13c8917d7
  RealFloat 00ef28e1ee85ae838321e71004da4dc0
  atan2 a6fa6a1e91865b36cfe6575a5b3dd9ab
import  -/  Data.Array.Accelerate.Language 524bed6c61291389f36fc32a525eca39
  exports: a284cd1d10aeff227064b59c0864f9a0
  cond 1ad22d0d07dca5cab36a411c4b5a6965
import  -/  Data.Array.Accelerate.Lift 454e17a2929036e6ccaa20714d77504c
  exports: 00dd99cf720cc4352c4681d40a7a8243
  Lift f80630fa058bc1fec72a0c728d66e0bc
  Plain 6077ef8139c94a2543619db19e2eb099
  Unlift 0812513d17ebe99933d114cc44033ab7
  lift e513fb85b3ecd1c6d6ecd1c153e280b8
  lift1 e9ecd355db9fb88e5fc27730c536212b
  lift2 0f105eb1a91f17d4847b22d512966d48
  unlift f5a24af2e6ef4bde78101039418077e7
import  -/  Data.Array.Accelerate.Product 8b6346e847887a013338cfe4431f2f5a
  exports: aebe828f4ca2c96d5390ff50126a2bd3
  IsProduct f6af3d33d87461c8507cabb9d14916a8
  ProdRepr 0d61c92e96be18fac6577f3d6512c149
  SuccTupIdx 0bc8a098c8f2d27bf7ec36e6968e021b
  ZeroTupIdx 807a291e8a84844e2c5f3d7ffa83d357
  fromProd 232063dda3c7335d0303031245764c71
  prod 8d199261e6ea783434f051d08fd6c2eb
  toProd 3146d338cf4fb23b835e5970566031fc
import  -/  Data.Array.Accelerate.Smart c6a471aeed497009ce791e94dc05d100
  exports: 1e3a20050ce25466608a82a26d24d5f0
  Exp 2fd934232a7ed8f151cd01d9504e7b9f
  Exp dff601899922d9e86e5ab6941dfbac5f
  Prj 57e14165c8d4d18324b3351c490c5c28
  Tuple d9b38326707777837f9071d0b8b84579
import  -/  Data.Array.Accelerate.Type a1c7885f4a79193eaa1f192a9acbec78
  exports: 7aad7ca015788892b1349ebab929b71f
import  -/  base-4.9.1.0:Data.Complex ec864ed8b68bbdf9c6cffa700c3cfe8e
import  -/  base-4.9.1.0:GHC.Err 3bba35a16538d33d424682ce66876cdd
import  -/  base-4.9.1.0:GHC.Float 33e2b9ffe427edd6a5c2fd6a3b26703c
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Real 82e4e59051a13dba1da63e1e970a69e6
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
addDependentFile "/home/pwoh/.stack/programs/x86_64-linux-dkd1ce2ff9c9560b648268df668d177711/ghc-8.0.2/lib/ghc-8.0.2/include/ghcversion.h"
addDependentFile ".stack-work/dist/x86_64-linux-dkd1ce2ff9c9560b648268df668d177711/Cabal-1.24.2.0/build/autogen/cabal_macros.h"
addDependentFile "/usr/include/stdc-predef.h"
819eb09dffc4d36f5cfcc1317394075a
  $fEltComplex ::
    Data.Array.Accelerate.Array.Sugar.Elt a =>
    Data.Array.Accelerate.Array.Sugar.Elt (Data.Complex.Complex a)
  DFunId
  {- Arity: 1,
     Strictness: <L,U(1*U(C(C1(U)),A,A),1*C1(U),1*U,1*U,C(U),C(U),C(U))>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt a).
                  @ (Data.Complex.Complex a)
                  (Data.Array.Accelerate.Data.Complex.$fEltComplex_$cp1Elt @ a $dElt)
                  (Data.Array.Accelerate.Data.Complex.$fEltComplex_$cp2Elt @ a $dElt)
                  (Data.Array.Accelerate.Data.Complex.$fEltComplex_$cp3Elt @ a $dElt)
                  (Data.Array.Accelerate.Data.Complex.$fEltComplex_$cp4Elt @ a $dElt)
                  (Data.Array.Accelerate.Data.Complex.$fEltComplex_$celtType
                     @ a
                     $dElt)
                  (Data.Array.Accelerate.Data.Complex.$fEltComplex_$cfromElt
                     @ a
                     $dElt)
                  (Data.Array.Accelerate.Data.Complex.$fEltComplex_$ctoElt
                     @ a
                     $dElt) -}
fa326effa38c5b49a1a293593dc4c380
  $fEltComplex1 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           Data.Array.Accelerate.Data.Complex.$fEltComplex2
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   GHC.Tuple.$tc()
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
c7551c07fb47ef6001537b0de96a7638
  $fEltComplex2 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   15843165073189925570##
                   13730769858450861905##) -}
bf755b87a64367ac243ce246ce22df1a
  $fEltComplex3 :: [GHC.Fingerprint.Type.Fingerprint]
  {- Unfolding: (Data.Typeable.Internal.typeRepFingerprints
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   Data.Array.Accelerate.Data.Complex.$fEltComplex_types) -}
24d69cf784725827e602426b7357abf9
  $fEltComplex4 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   17502837480397947244##
                   15872498598114190556##) -}
43b73be22b6e283748f6d7af1dcdbfdc
  $fEltComplex5 :: [GHC.Fingerprint.Type.Fingerprint]
  {- Unfolding: (Data.Typeable.Internal.typeRepFingerprints
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
08c6c628097e5bc4a6b08c474d5cc5ac
  $fEltComplex6 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           Data.Array.Accelerate.Data.Complex.$fEltComplex7
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Data.Complex.$tcComplex
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
d3b33863eed66a50ea61ade9ef8e8aa0
  $fEltComplex7 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   2039197459658469559##
                   7194650304225502344##) -}
341ae6b0f8b9f0b6da1d506d39a6b174
  $fEltComplex_$celtType ::
    Data.Array.Accelerate.Array.Sugar.Elt a =>
    Data.Complex.Complex a
    -> Data.Array.Accelerate.Type.TupleType
         (Data.Array.Accelerate.Array.Sugar.EltRepr
            (Data.Complex.Complex a))
  {- Arity: 1, Strictness: <L,U(A,A,A,A,C(U),A,A)>,
     Unfolding: (\ @ a
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt a) ->
                 let {
                   lvl324 :: Data.Array.Accelerate.Type.TupleType
                               (Data.Array.Accelerate.Array.Sugar.EltRepr a)
                   = Data.Array.Accelerate.Array.Sugar.eltType
                       @ a
                       $dElt
                       (Data.Array.Accelerate.Array.Sugar.$fElt(,)2 @ a)
                 } in
                 let {
                   lvl325 :: Data.Array.Accelerate.Type.TupleType
                               ((), Data.Array.Accelerate.Array.Sugar.EltRepr a)
                   = Data.Array.Accelerate.Type.PairTuple
                       @ ((), Data.Array.Accelerate.Array.Sugar.EltRepr a)
                       @ ()
                       @ (Data.Array.Accelerate.Array.Sugar.EltRepr a)
                       @~ <((), Data.Array.Accelerate.Array.Sugar.EltRepr a)>_N
                       Data.Array.Accelerate.Type.$WUnitTuple
                       lvl324
                 } in
                 let {
                   lvl326 :: Data.Array.Accelerate.Type.TupleType
                               (Data.Array.Accelerate.Array.Sugar.EltRepr a)
                   = Data.Array.Accelerate.Array.Sugar.eltType
                       @ a
                       $dElt
                       (Data.Array.Accelerate.Array.Sugar.$fElt(,)1 @ a)
                 } in
                 let {
                   lvl327 :: Data.Array.Accelerate.Type.TupleType
                               (((), Data.Array.Accelerate.Array.Sugar.EltRepr a),
                                Data.Array.Accelerate.Array.Sugar.EltRepr a)
                   = Data.Array.Accelerate.Type.PairTuple
                       @ (((), Data.Array.Accelerate.Array.Sugar.EltRepr a),
                          Data.Array.Accelerate.Array.Sugar.EltRepr a)
                       @ ((), Data.Array.Accelerate.Array.Sugar.EltRepr a)
                       @ (Data.Array.Accelerate.Array.Sugar.EltRepr a)
                       @~ <(((), Data.Array.Accelerate.Array.Sugar.EltRepr a),
                            Data.Array.Accelerate.Array.Sugar.EltRepr a)>_N
                       lvl325
                       lvl326
                 } in
                 (\ (ds :: Data.Complex.Complex a) -> lvl327)
                   `cast`
                 (<Data.Complex.Complex a>_R
                  ->_R (Data.Array.Accelerate.Type.TupleType
                          (Trans
                               (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                         <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N
                                         <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N))
                               (Trans
                                    (Sym (Data.Array.Accelerate.Array.Sugar.D:R:EltRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:EltReprComplex[0]
                                              <a>_N)))))_R)) -}
0ec867c932b40d7c2e62eb6c11abbabb
  $fEltComplex_$cfromElt ::
    Data.Array.Accelerate.Array.Sugar.Elt a =>
    Data.Complex.Complex a
    -> Data.Array.Accelerate.Array.Sugar.EltRepr
         (Data.Complex.Complex a)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,C(U),A)><S(SS),1*U(U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt a)
                   (ds :: Data.Complex.Complex a) ->
                 case ds of wild { Data.Complex.:+ a1 b ->
                 ((GHC.Tuple.(),
                   Data.Array.Accelerate.Array.Sugar.fromElt @ a $dElt a1),
                  Data.Array.Accelerate.Array.Sugar.fromElt @ a $dElt b)
                   `cast`
                 (Trans
                      (Sub (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                     <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N
                                     <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N)))
                      (Trans
                           (Sub (Sym (Data.Array.Accelerate.Array.Sugar.D:R:EltRepr(,)[0]
                                          <a>_N <a>_N)))
                           (Sub (Sym (Data.Array.Accelerate.Data.Complex.D:R:EltReprComplex[0]
                                          <a>_N))))) }) -}
b47aa4305ba093a6598ff2c8c273b55b
  $fEltComplex_$cp1Elt ::
    Data.Array.Accelerate.Array.Sugar.Elt a =>
    GHC.Show.Show (Data.Complex.Complex a)
  {- Arity: 1, Strictness: <L,1*U(1*U(C(C1(U)),A,A),A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt a) ->
                 Data.Complex.$fShowComplex
                   @ a
                   (Data.Array.Accelerate.Array.Sugar.$p1Elt @ a $dElt)) -}
3584350783ac0eff860d4771d54ad796
  $fEltComplex_$cp2Elt ::
    Data.Array.Accelerate.Array.Sugar.Elt a =>
    Data.Typeable.Internal.Typeable (Data.Complex.Complex a)
  {- Arity: 1, Strictness: <L,1*U(A,1*C1(U),A,A,A,A,A)>,
     Unfolding: (\ @ a
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt a) ->
                 let {
                   ds :: Data.Typeable.Internal.TypeRep
                   = case Data.Array.Accelerate.Data.Complex.$fEltComplex6 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                     let {
                       types :: [Data.Typeable.Internal.TypeRep]
                       = GHC.Base.++
                           @ Data.Typeable.Internal.TypeRep
                           trs
                           (GHC.Types.:
                              @ Data.Typeable.Internal.TypeRep
                              ((Data.Array.Accelerate.Array.Sugar.$p2Elt @ a $dElt)
                                 `cast`
                               (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N)
                                 (GHC.Prim.proxy# @ * @ a))
                              (GHC.Types.[] @ Data.Typeable.Internal.TypeRep))
                     } in
                     case Data.Typeable.Internal.typeRepFingerprints
                            ks
                            types of kt_fps { DEFAULT ->
                     case GHC.Fingerprint.fingerprintFingerprints
                            (GHC.Types.:
                               @ GHC.Fingerprint.Type.Fingerprint
                               (Data.Typeable.Internal.tyConFingerprint tc)
                               kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                     Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }
                 } in
                 (\ (wild :: GHC.Prim.Proxy# (Data.Complex.Complex a)) -> ds)
                   `cast`
                 (Sym (Data.Typeable.Internal.N:Typeable[0]
                           <*>_N <Data.Complex.Complex a>_N))) -}
c404eda870a03f5ce1c147e7c591798c
  $fEltComplex_$cp3Elt ::
    Data.Array.Accelerate.Array.Sugar.Elt a =>
    Data.Typeable.Internal.Typeable
      (Data.Array.Accelerate.Array.Sugar.EltRepr
         (Data.Complex.Complex a))
  {- Arity: 1, Strictness: <L,1*U(A,A,1*U,A,A,A,A)>,
     Unfolding: (\ @ a
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt a) ->
                 let {
                   ds :: Data.Typeable.Internal.TypeRep
                   = case Data.Array.Accelerate.Data.Complex.$fEltComplex5 of kt_fps { DEFAULT ->
                     case GHC.Fingerprint.fingerprintFingerprints
                            (GHC.Types.:
                               @ GHC.Fingerprint.Type.Fingerprint
                               Data.Array.Accelerate.Data.Complex.$fEltComplex4
                               kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                     let {
                       $dTypeable :: Data.Typeable.Internal.Typeable
                                       (Data.Array.Accelerate.Array.Sugar.EltRepr a)
                       = Data.Array.Accelerate.Array.Sugar.$p3Elt @ a $dElt
                     } in
                     let {
                       types :: Data.Typeable.Internal.TypeRep
                       = case Data.Array.Accelerate.Data.Complex.$fEltComplex3 of kt_fps1 { DEFAULT ->
                         case GHC.Fingerprint.fingerprintFingerprints
                                (GHC.Types.:
                                   @ GHC.Fingerprint.Type.Fingerprint
                                   Data.Array.Accelerate.Data.Complex.$fEltComplex4
                                   kt_fps1) of dt4 { GHC.Fingerprint.Type.Fingerprint dt3 dt5 ->
                         let {
                           types1 :: [Data.Typeable.Internal.TypeRep]
                           = GHC.Base.++
                               @ Data.Typeable.Internal.TypeRep
                               Data.Array.Accelerate.Data.Complex.$fEltComplex_types
                               (GHC.Types.:
                                  @ Data.Typeable.Internal.TypeRep
                                  ($dTypeable
                                     `cast`
                                   (Data.Typeable.Internal.N:Typeable[0]
                                        <GHC.Types.*>_N
                                        <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N)
                                     (GHC.Prim.proxy#
                                        @ GHC.Types.*
                                        @ (Data.Array.Accelerate.Array.Sugar.EltRepr a)))
                                  (GHC.Types.[] @ Data.Typeable.Internal.TypeRep))
                         } in
                         case Data.Typeable.Internal.typeRepFingerprints
                                (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                                types1 of kt_fps2 { DEFAULT ->
                         case GHC.Fingerprint.fingerprintFingerprints
                                (GHC.Types.:
                                   @ GHC.Fingerprint.Type.Fingerprint
                                   Data.Array.Accelerate.Data.Complex.$fEltComplex4
                                   kt_fps2) of dt6 { GHC.Fingerprint.Type.Fingerprint dt7 dt8 ->
                         Data.Typeable.Internal.TypeRep
                           dt7
                           dt8
                           GHC.Tuple.$tc(,)
                           (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                           types1 } } } }
                     } in
                     let {
                       types1 :: [Data.Typeable.Internal.TypeRep]
                       = GHC.Types.:
                           @ Data.Typeable.Internal.TypeRep
                           types
                           (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                     } in
                     case Data.Typeable.Internal.typeRepFingerprints
                            (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                            types1 of kt_fps1 { DEFAULT ->
                     case GHC.Fingerprint.fingerprintFingerprints
                            (GHC.Types.:
                               @ GHC.Fingerprint.Type.Fingerprint
                               Data.Array.Accelerate.Data.Complex.$fEltComplex4
                               kt_fps1) of dt4 { GHC.Fingerprint.Type.Fingerprint dt3 dt5 ->
                     let {
                       types2 :: [Data.Typeable.Internal.TypeRep]
                       = GHC.Base.++
                           @ Data.Typeable.Internal.TypeRep
                           types1
                           (GHC.Types.:
                              @ Data.Typeable.Internal.TypeRep
                              ($dTypeable
                                 `cast`
                               (Data.Typeable.Internal.N:Typeable[0]
                                    <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N)
                                 (GHC.Prim.proxy#
                                    @ GHC.Types.*
                                    @ (Data.Array.Accelerate.Array.Sugar.EltRepr a)))
                              (GHC.Types.[] @ Data.Typeable.Internal.TypeRep))
                     } in
                     case Data.Typeable.Internal.typeRepFingerprints
                            (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                            types2 of kt_fps2 { DEFAULT ->
                     case GHC.Fingerprint.fingerprintFingerprints
                            (GHC.Types.:
                               @ GHC.Fingerprint.Type.Fingerprint
                               Data.Array.Accelerate.Data.Complex.$fEltComplex4
                               kt_fps2) of dt6 { GHC.Fingerprint.Type.Fingerprint dt7 dt8 ->
                     Data.Typeable.Internal.TypeRep
                       dt7
                       dt8
                       GHC.Tuple.$tc(,)
                       (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                       types2 } } } } } }
                 } in
                 (\ (wild :: GHC.Prim.Proxy#
                               (((), Data.Array.Accelerate.Array.Sugar.EltRepr a),
                                Data.Array.Accelerate.Array.Sugar.EltRepr a)) ->
                  ds)
                   `cast`
                 (Sym (Data.Typeable.Internal.N:Typeable[0]
                           <*>_N
                           (Trans
                                (Data.Array.Accelerate.Data.Complex.D:R:EltReprComplex[0] <a>_N)
                                (Trans
                                     (Data.Array.Accelerate.Array.Sugar.D:R:EltRepr(,)[0]
                                          <a>_N <a>_N)
                                     (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                          <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N
                                          <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N)))))) -}
b7d518dc0da38c70a1323005925056d1
  $fEltComplex_$cp4Elt ::
    Data.Array.Accelerate.Array.Sugar.Elt a =>
    Data.Array.Accelerate.Array.Data.ArrayElt
      (Data.Array.Accelerate.Array.Sugar.EltRepr
         (Data.Complex.Complex a))
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*U(A,A,A,1*U,A,A,A)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Data.Array.Accelerate.Array.Sugar.Elt a) ->
                 case Data.Array.Accelerate.Data.Complex.$w$cp4Elt
                        @ a
                        w of ww { (#,,,,,,,,#) ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ->
                 Data.Array.Accelerate.Array.Data.C:ArrayElt
                   @ (Data.Array.Accelerate.Array.Sugar.EltRepr
                        (Data.Complex.Complex a))
                   ww1
                   ww2
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww8
                   ww9 }) -}
e6f11ea11325fbbcb8f9372d15b2b83d
  $fEltComplex_$ctoElt ::
    Data.Array.Accelerate.Array.Sugar.Elt a =>
    Data.Array.Accelerate.Array.Sugar.EltRepr (Data.Complex.Complex a)
    -> Data.Complex.Complex a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLLLLC(S)),U(A,A,A,A,A,A,C(U))><S(S(SL)L),1*U(1*U(1*H,U),U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: Data.Array.Accelerate.Array.Sugar.Elt a)
                   (w1 :: Data.Array.Accelerate.Array.Sugar.EltRepr
                            (Data.Complex.Complex a)) ->
                 case w1
                        `cast`
                      (Trans
                           (Sub (Data.Array.Accelerate.Data.Complex.D:R:EltReprComplex[0]
                                     <a>_N))
                           (Trans
                                (Sub (Data.Array.Accelerate.Array.Sugar.D:R:EltRepr(,)[0]
                                          <a>_N <a>_N))
                                (Sub (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                          <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N
                                          <Data.Array.Accelerate.Array.Sugar.EltRepr
                                             a>_N)))) of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { (,) ww4 ww5 ->
                 case ww4 of ww6 { () ->
                 case Data.Array.Accelerate.Array.Sugar.toElt
                        @ a
                        w
                        ww5 of dt { DEFAULT ->
                 case Data.Array.Accelerate.Array.Sugar.toElt
                        @ a
                        w
                        ww2 of dt1 { DEFAULT ->
                 Data.Complex.:+ @ a dt dt1 } } } } }) -}
93bd8efc65e8694b7d56a2fadd06f5b7
  $fEltComplex_types :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   Data.Array.Accelerate.Data.Complex.$fEltComplex1
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
7dc36d4595f9068bb413f6a46910f839
  $fEqComplex ::
    Data.Array.Accelerate.Classes.Eq.Eq a =>
    Data.Array.Accelerate.Classes.Eq.Eq (Data.Complex.Complex a)
  DFunId
  {- Arity: 1,
     Strictness: <L,U(U(U(U,U,U),U,U,U,U,U,U),C(C1(U)),C(C1(U)))>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      ($dEq :: Data.Array.Accelerate.Classes.Eq.Eq a).
                  @ (Data.Complex.Complex a)
                  (Data.Array.Accelerate.Data.Complex.$fEqComplex_$cp1Eq @ a $dEq)
                  (Data.Array.Accelerate.Data.Complex.$fEqComplex_$c== @ a $dEq)
                  (Data.Array.Accelerate.Data.Complex.$fEqComplex_$c/= @ a $dEq) -}
fbf82ee02c9d8452c36b0fe7425f6dc3
  $fEqComplex1 ::
    Data.Array.Accelerate.Classes.Eq.Eq a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Bool
  {- Arity: 3, Strictness: <L,U(1*U,A,C(C1(U)))><L,U><L,U>,
     Unfolding: (\ @ a
                   ($dEq :: Data.Array.Accelerate.Classes.Eq.Eq a)
                   (eta :: Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a))
                   (eta1 :: Data.Array.Accelerate.Smart.Exp
                              (Data.Complex.Complex a)) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Bool
                   @ (GHC.Types.Bool, GHC.Types.Bool)
                   Data.Array.Accelerate.Smart.$s$fElt(,)
                   Data.Array.Accelerate.Array.Sugar.$fEltBool
                   Data.Array.Accelerate.AST.$WPrimLOr
                   (Data.Array.Accelerate.Smart.Tuple
                      @ Data.Array.Accelerate.Smart.Acc
                      @ Data.Array.Accelerate.Smart.Exp
                      @ (GHC.Types.Bool, GHC.Types.Bool)
                      Data.Array.Accelerate.Smart.$s$fElt(,)
                      Data.Array.Accelerate.Smart.$s$fIsProductcst(,)
                      (let {
                         $dElt :: Data.Array.Accelerate.Array.Sugar.Elt a
                         = Data.Array.Accelerate.Classes.Eq.$p1Eq @ a $dEq
                       } in
                       let {
                         $dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt
                                     (Data.Complex.Complex a)
                         = Data.Array.Accelerate.Data.Complex.$fEltComplex @ a $dElt
                       } in
                       let {
                         $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                          (Data.Complex.Complex a)
                         = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                             @ Data.Array.Accelerate.Array.Sugar.Elt
                             @ a
                             $dElt
                       } in
                       (Data.Array.Accelerate.Array.Sugar.SnocTup
                          @ Data.Array.Accelerate.Smart.Exp
                          @ (((), GHC.Types.Bool), GHC.Types.Bool)
                          @ GHC.Types.Bool
                          @ ((), GHC.Types.Bool)
                          @~ <(((), GHC.Types.Bool), GHC.Types.Bool)>_N
                          Data.Array.Accelerate.Array.Sugar.$fEltBool
                          (Data.Array.Accelerate.Array.Sugar.SnocTup
                             @ Data.Array.Accelerate.Smart.Exp
                             @ ((), GHC.Types.Bool)
                             @ GHC.Types.Bool
                             @ ()
                             @~ <((), GHC.Types.Bool)>_N
                             Data.Array.Accelerate.Array.Sugar.$fEltBool
                             (Data.Array.Accelerate.Array.Sugar.$WNilTup
                                @ Data.Array.Accelerate.Smart.Exp)
                             (Data.Array.Accelerate.Classes.Eq./=
                                @ a
                                $dEq
                                (Data.Array.Accelerate.Smart.Prj
                                   @ Data.Array.Accelerate.Smart.Acc
                                   @ Data.Array.Accelerate.Smart.Exp
                                   @ a
                                   @ (Data.Complex.Complex a)
                                   $dElt1
                                   $dIsProduct
                                   $dElt
                                   (Data.Array.Accelerate.Data.Complex.$fEqComplex2 @ a)
                                     `cast`
                                   (Data.Array.Accelerate.Product.TupleIdx
                                      (Trans
                                           (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                                     <a>_N <a>_N))
                                           (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                                     <a>_N)))
                                      <a>_N)_R
                                   eta)
                                  `cast`
                                (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                                (Data.Array.Accelerate.Smart.Prj
                                   @ Data.Array.Accelerate.Smart.Acc
                                   @ Data.Array.Accelerate.Smart.Exp
                                   @ a
                                   @ (Data.Complex.Complex a)
                                   $dElt1
                                   $dIsProduct
                                   $dElt
                                   (Data.Array.Accelerate.Data.Complex.$fEqComplex2 @ a)
                                     `cast`
                                   (Data.Array.Accelerate.Product.TupleIdx
                                      (Trans
                                           (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                                     <a>_N <a>_N))
                                           (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                                     <a>_N)))
                                      <a>_N)_R
                                   eta1)
                                  `cast`
                                (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)))
                          (Data.Array.Accelerate.Classes.Eq./=
                             @ a
                             $dEq
                             (Data.Array.Accelerate.Smart.Prj
                                @ Data.Array.Accelerate.Smart.Acc
                                @ Data.Array.Accelerate.Smart.Exp
                                @ a
                                @ (Data.Complex.Complex a)
                                $dElt1
                                $dIsProduct
                                $dElt
                                (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                                  `cast`
                                (Data.Array.Accelerate.Product.TupleIdx
                                   (Trans
                                        (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                                  <a>_N <a>_N))
                                        (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                                  <a>_N)))
                                   <a>_N)_R
                                eta)
                               `cast`
                             (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                             (Data.Array.Accelerate.Smart.Prj
                                @ Data.Array.Accelerate.Smart.Acc
                                @ Data.Array.Accelerate.Smart.Exp
                                @ a
                                @ (Data.Complex.Complex a)
                                $dElt1
                                $dIsProduct
                                $dElt
                                (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                                  `cast`
                                (Data.Array.Accelerate.Product.TupleIdx
                                   (Trans
                                        (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                                  <a>_N <a>_N))
                                        (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                                  <a>_N)))
                                   <a>_N)_R
                                eta1)
                               `cast`
                             (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)))
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Tuple
                          <Data.Array.Accelerate.Smart.Exp>_R
                          (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                    <GHC.Types.Bool>_N <GHC.Types.Bool>_N)))_R))
                     `cast`
                   (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <(GHC.Types.Bool,
                                                                 GHC.Types.Bool)>_N)) -}
9444fb20a0c58821e4cfa3b0f4dab948
  $fEqComplex2 ::
    Data.Array.Accelerate.Product.TupleIdx (((), a), a) a
  {- HasNoCafRefs,
     Unfolding: (\ @ a ->
                 Data.Array.Accelerate.Product.SuccTupIdx
                   @ (((), a), a)
                   @ a
                   @ ((), a)
                   @ a
                   @~ <(((), a), a)>_N
                   (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ())) -}
a9da2257e9b7d7207baac48572511a1e
  $fEqComplex3 ::
    Data.Array.Accelerate.Classes.Eq.Eq a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Bool
  {- Arity: 3, Strictness: <L,U(1*U,C(C1(U)),A)><L,U><L,U>,
     Unfolding: (\ @ a
                   ($dEq :: Data.Array.Accelerate.Classes.Eq.Eq a)
                   (eta :: Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a))
                   (eta1 :: Data.Array.Accelerate.Smart.Exp
                              (Data.Complex.Complex a)) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Bool
                   @ (GHC.Types.Bool, GHC.Types.Bool)
                   Data.Array.Accelerate.Smart.$s$fElt(,)
                   Data.Array.Accelerate.Array.Sugar.$fEltBool
                   Data.Array.Accelerate.AST.$WPrimLAnd
                   (Data.Array.Accelerate.Smart.Tuple
                      @ Data.Array.Accelerate.Smart.Acc
                      @ Data.Array.Accelerate.Smart.Exp
                      @ (GHC.Types.Bool, GHC.Types.Bool)
                      Data.Array.Accelerate.Smart.$s$fElt(,)
                      Data.Array.Accelerate.Smart.$s$fIsProductcst(,)
                      (let {
                         $dElt :: Data.Array.Accelerate.Array.Sugar.Elt a
                         = Data.Array.Accelerate.Classes.Eq.$p1Eq @ a $dEq
                       } in
                       let {
                         $dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt
                                     (Data.Complex.Complex a)
                         = Data.Array.Accelerate.Data.Complex.$fEltComplex @ a $dElt
                       } in
                       let {
                         $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                          (Data.Complex.Complex a)
                         = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                             @ Data.Array.Accelerate.Array.Sugar.Elt
                             @ a
                             $dElt
                       } in
                       (Data.Array.Accelerate.Array.Sugar.SnocTup
                          @ Data.Array.Accelerate.Smart.Exp
                          @ (((), GHC.Types.Bool), GHC.Types.Bool)
                          @ GHC.Types.Bool
                          @ ((), GHC.Types.Bool)
                          @~ <(((), GHC.Types.Bool), GHC.Types.Bool)>_N
                          Data.Array.Accelerate.Array.Sugar.$fEltBool
                          (Data.Array.Accelerate.Array.Sugar.SnocTup
                             @ Data.Array.Accelerate.Smart.Exp
                             @ ((), GHC.Types.Bool)
                             @ GHC.Types.Bool
                             @ ()
                             @~ <((), GHC.Types.Bool)>_N
                             Data.Array.Accelerate.Array.Sugar.$fEltBool
                             (Data.Array.Accelerate.Array.Sugar.$WNilTup
                                @ Data.Array.Accelerate.Smart.Exp)
                             (Data.Array.Accelerate.Classes.Eq.==
                                @ a
                                $dEq
                                (Data.Array.Accelerate.Smart.Prj
                                   @ Data.Array.Accelerate.Smart.Acc
                                   @ Data.Array.Accelerate.Smart.Exp
                                   @ a
                                   @ (Data.Complex.Complex a)
                                   $dElt1
                                   $dIsProduct
                                   $dElt
                                   (Data.Array.Accelerate.Data.Complex.$fEqComplex2 @ a)
                                     `cast`
                                   (Data.Array.Accelerate.Product.TupleIdx
                                      (Trans
                                           (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                                     <a>_N <a>_N))
                                           (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                                     <a>_N)))
                                      <a>_N)_R
                                   eta)
                                  `cast`
                                (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                                (Data.Array.Accelerate.Smart.Prj
                                   @ Data.Array.Accelerate.Smart.Acc
                                   @ Data.Array.Accelerate.Smart.Exp
                                   @ a
                                   @ (Data.Complex.Complex a)
                                   $dElt1
                                   $dIsProduct
                                   $dElt
                                   (Data.Array.Accelerate.Data.Complex.$fEqComplex2 @ a)
                                     `cast`
                                   (Data.Array.Accelerate.Product.TupleIdx
                                      (Trans
                                           (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                                     <a>_N <a>_N))
                                           (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                                     <a>_N)))
                                      <a>_N)_R
                                   eta1)
                                  `cast`
                                (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)))
                          (Data.Array.Accelerate.Classes.Eq.==
                             @ a
                             $dEq
                             (Data.Array.Accelerate.Smart.Prj
                                @ Data.Array.Accelerate.Smart.Acc
                                @ Data.Array.Accelerate.Smart.Exp
                                @ a
                                @ (Data.Complex.Complex a)
                                $dElt1
                                $dIsProduct
                                $dElt
                                (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                                  `cast`
                                (Data.Array.Accelerate.Product.TupleIdx
                                   (Trans
                                        (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                                  <a>_N <a>_N))
                                        (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                                  <a>_N)))
                                   <a>_N)_R
                                eta)
                               `cast`
                             (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                             (Data.Array.Accelerate.Smart.Prj
                                @ Data.Array.Accelerate.Smart.Acc
                                @ Data.Array.Accelerate.Smart.Exp
                                @ a
                                @ (Data.Complex.Complex a)
                                $dElt1
                                $dIsProduct
                                $dElt
                                (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                                  `cast`
                                (Data.Array.Accelerate.Product.TupleIdx
                                   (Trans
                                        (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                                  <a>_N <a>_N))
                                        (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                                  <a>_N)))
                                   <a>_N)_R
                                eta1)
                               `cast`
                             (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)))
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Tuple
                          <Data.Array.Accelerate.Smart.Exp>_R
                          (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                    <GHC.Types.Bool>_N <GHC.Types.Bool>_N)))_R))
                     `cast`
                   (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <(GHC.Types.Bool,
                                                                 GHC.Types.Bool)>_N)) -}
ce3699a91942969259f3daeb49acf5da
  $fEqComplex_$c/= ::
    Data.Array.Accelerate.Classes.Eq.Eq a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Bool
  {- Arity: 3, Strictness: <L,U(1*U,A,C(C1(U)))><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Data.Complex.$fEqComplex1
                  `cast`
                (forall (a :: <*>_N).
                 <Data.Array.Accelerate.Classes.Eq.Eq a>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Bool>_N) -}
2de0476d67a07341221b46776e297636
  $fEqComplex_$c== ::
    Data.Array.Accelerate.Classes.Eq.Eq a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Bool
  {- Arity: 3, Strictness: <L,U(1*U,C(C1(U)),A)><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Data.Complex.$fEqComplex3
                  `cast`
                (forall (a :: <*>_N).
                 <Data.Array.Accelerate.Classes.Eq.Eq a>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Bool>_N) -}
752e9beb28895fa4b6e4df6cf9fb8de5
  $fEqComplex_$cp1Eq ::
    Data.Array.Accelerate.Classes.Eq.Eq a =>
    Data.Array.Accelerate.Array.Sugar.Elt (Data.Complex.Complex a)
  {- Arity: 1,
     Strictness: <L,1*U(1*U(1*U(C(C1(U)),A,A),1*C1(U),1*U,1*U,C(U),C(U),C(U)),A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dEq :: Data.Array.Accelerate.Classes.Eq.Eq a) ->
                 Data.Array.Accelerate.Data.Complex.$fEltComplex
                   @ a
                   (Data.Array.Accelerate.Classes.Eq.$p1Eq @ a $dEq)) -}
2522180c1fc44c6b23a96f844169b58e
  $fFloatingExp ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    GHC.Float.Floating
      (Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a))
  DFunId
  {- Arity: 1,
     Strictness: <L,U(U(U(U,U,U(U(U,U,U,U,U,U,U),U,U)),U(U,U),U,U,U,U,U),U(U,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)),A,A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)))>,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                        a).
                  @ (Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a))
                  (Data.Array.Accelerate.Data.Complex.$fFractionalExp
                     @ a
                     $dRealFloat)
                  (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$cpi
                     @ a
                     $dRealFloat)
                  (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$cexp
                     @ a
                     $dRealFloat)
                  (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$clog
                     @ a
                     $dRealFloat)
                  (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$csqrt
                     @ a
                     $dRealFloat)
                  (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$c**
                     @ a
                     $dRealFloat)
                  (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$clogBase
                     @ a
                     $dRealFloat)
                  (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$csin
                     @ a
                     $dRealFloat)
                  (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$ccos
                     @ a
                     $dRealFloat)
                  (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$ctan
                     @ a
                     $dRealFloat)
                  (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$casin
                     @ a
                     $dRealFloat)
                  (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$cacos
                     @ a
                     $dRealFloat)
                  (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$catan
                     @ a
                     $dRealFloat)
                  (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$csinh
                     @ a
                     $dRealFloat)
                  (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$ccosh
                     @ a
                     $dRealFloat)
                  (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$ctanh
                     @ a
                     $dRealFloat)
                  (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$casinh
                     @ a
                     $dRealFloat)
                  (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$cacosh
                     @ a
                     $dRealFloat)
                  (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$catanh
                     @ a
                     $dRealFloat)
                  (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$clog1p
                     @ a
                     $dRealFloat)
                  (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$cexpm1
                     @ a
                     $dRealFloat)
                  (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$clog1pexp
                     @ a
                     $dRealFloat)
                  (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$clog1mexp
                     @ a
                     $dRealFloat) -}
bee9ab55e6bfe098e41ef8ef76c1a75c
  $fFloatingExp1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (0) -}
5e04ee0211906b852fc6986be86baeb8
  $fFloatingExp2 ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp
      (Data.Array.Accelerate.Lift.Plain
         (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a)))
  {- Arity: 1,
     Strictness: <S(S(S(LLS(S(LLLLLLC(S))LL))LLLLLL)S(LS(LSLLLLLLLLLLLLLLLLLLLLL))LLLLLLLLLLLLLL),U(U(U(U,U,U(U(U,U,U,U,U,U,U),U,U)),U,U,U,U,U,U),1*U(A,1*U(A,1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m3,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a
                   (w :: Data.Array.Accelerate.Classes.RealFloat.RealFloat a) ->
                 case Data.Array.Accelerate.Data.Complex.$w$cpi
                        @ a
                        w of ww { (#,,#) ww1 ww2 ww3 ->
                 (Data.Array.Accelerate.Smart.Tuple
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ (Data.Array.Accelerate.Lift.Plain
                         (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a)))
                    ww1
                    ww2
                    ww3)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Data.Array.Accelerate.Lift.Plain
                                                                (Data.Complex.Complex
                                                                   (Data.Array.Accelerate.Smart.Exp
                                                                      a))>_N) }) -}
59464d1d1910316f920700ca8541b325
  $fFloatingExp_$c* ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 1,
     Strictness: <L,U(U(U(U,U,U),U(U,U),U,U,U,U,U),U(U,U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ a
                   ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                     a) ->
                 let {
                   $dRealFrac :: Data.Array.Accelerate.Classes.RealFrac.RealFrac a
                   = Data.Array.Accelerate.Classes.RealFloat.$p1RealFloat
                       @ a
                       $dRealFloat
                 } in
                 let {
                   $d(%,,%) :: Data.Array.Accelerate.Classes.Real.Real a
                   = Data.Array.Accelerate.Classes.RealFrac.$p1RealFrac @ a $dRealFrac
                 } in
                 let {
                   $d(%,%) :: Data.Array.Accelerate.Classes.Num.Num a
                   = GHC.Classes.$p1(%,,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                       @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,,%)
                 } in
                 let {
                   $dElt :: Data.Array.Accelerate.Array.Sugar.Elt a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,%)
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex @ a $dElt
                 } in
                 let {
                   $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                    (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ a
                       $dElt
                 } in
                 let {
                   $dIsProduct1 :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                     (Data.Complex.Complex
                                        (Data.Array.Accelerate.Lift.Plain
                                           (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dElt2 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.Plain
                                     (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   f :: GHC.Float.RealFloat (Data.Array.Accelerate.Smart.Exp a)
                   = Data.Array.Accelerate.Classes.RealFloat.$fRealFloatExp
                       @ a
                       $dRealFloat
                 } in
                 (\ (x :: Data.Array.Accelerate.Smart.Exp
                            (Data.Array.Accelerate.Lift.Plain
                               (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a))))
                    (y :: Data.Array.Accelerate.Smart.Exp
                            (Data.Array.Accelerate.Lift.Plain
                               (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a)))) ->
                  case Data.Complex.$w$c*
                         @ (Data.Array.Accelerate.Smart.Exp a)
                         f
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt1
                            $dIsProduct
                            $dElt
                            (Data.Array.Accelerate.Data.Complex.$fEqComplex2 @ a)
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            x `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt1
                            $dIsProduct
                            $dElt
                            (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            x `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt1
                            $dIsProduct
                            $dElt
                            (Data.Array.Accelerate.Data.Complex.$fEqComplex2 @ a)
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            y `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt1
                            $dIsProduct
                            $dElt
                            (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            y `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N) of ww6 { (#,#) ww7 ww8 ->
                  (Data.Array.Accelerate.Smart.Tuple
                     @ Data.Array.Accelerate.Smart.Acc
                     @ Data.Array.Accelerate.Smart.Exp
                     @ (Data.Complex.Complex
                          (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a)))
                     $dElt2
                     $dIsProduct1
                     (Data.Array.Accelerate.Array.Sugar.SnocTup
                        @ Data.Array.Accelerate.Smart.Exp
                        @ (((),
                            Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp a)),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ ((),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @~ <(((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a)),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))>_N
                        $dElt
                          `cast`
                        (Data.Array.Accelerate.Array.Sugar.Elt
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                        (Data.Array.Accelerate.Array.Sugar.SnocTup
                           @ Data.Array.Accelerate.Smart.Exp
                           @ ((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ (Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ ()
                           @~ <((),
                                Data.Array.Accelerate.Lift.Plain
                                  (Data.Array.Accelerate.Smart.Exp a))>_N
                           $dElt
                             `cast`
                           (Data.Array.Accelerate.Array.Sugar.Elt
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                           (Data.Array.Accelerate.Array.Sugar.$WNilTup
                              @ Data.Array.Accelerate.Smart.Exp)
                           ww7
                             `cast`
                           (Data.Array.Accelerate.Smart.Exp
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                        ww8
                          `cast`
                        (Data.Array.Accelerate.Smart.Exp
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                       `cast`
                     (Data.Array.Accelerate.Array.Sugar.Tuple
                        <Data.Array.Accelerate.Smart.Exp>_R
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))
                             (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))))_R)
                    `cast`
                  (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                                                        <Data.Array.Accelerate.Smart.Exp
                                                                           a>_N))) })
                   `cast`
                 ((Data.Array.Accelerate.Smart.Exp
                     (Trans
                          (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                               <Data.Array.Accelerate.Smart.Exp a>_N)
                          (Data.Complex.Complex
                             (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R
                  ->_R (Data.Array.Accelerate.Smart.Exp
                          (Trans
                               (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                    <Data.Array.Accelerate.Smart.Exp a>_N)
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R
                  ->_R (Data.Array.Accelerate.Smart.Exp
                          (Trans
                               (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                    <Data.Array.Accelerate.Smart.Exp a>_N)
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)) -}
a83e95ec405c0fcbe448cb586885658a
  $fFloatingExp_$c** ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 3,
     Strictness: <L,U(U(U(U,U,U(U(U,U,U,U,U,U,U),U,U)),U(U,U),U,U,U,U,U),U(U,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)),A,A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)))><L,U><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                     a)
                   (eta :: Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a))
                   (eta1 :: Data.Array.Accelerate.Smart.Exp
                              (Data.Complex.Complex a)) ->
                 Data.Array.Accelerate.Data.Complex.$fFloatingExp_$cexp
                   @ a
                   $dRealFloat
                   (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$c*
                      @ a
                      $dRealFloat
                      (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$clog
                         @ a
                         $dRealFloat
                         eta)
                      eta1)) -}
8954cecc6c730466c4b559b2779016c8
  $fFloatingExp_$c+ ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 1, Strictness: <L,U(U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ a
                   ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                     a) ->
                 let {
                   $dRealFrac :: Data.Array.Accelerate.Classes.RealFrac.RealFrac a
                   = Data.Array.Accelerate.Classes.RealFloat.$p1RealFloat
                       @ a
                       $dRealFloat
                 } in
                 let {
                   $dReal :: Data.Array.Accelerate.Classes.Real.Real a
                   = Data.Array.Accelerate.Classes.RealFrac.$p1RealFrac @ a $dRealFrac
                 } in
                 let {
                   $d(%,%) :: Data.Array.Accelerate.Classes.Num.Num a
                   = GHC.Classes.$p1(%,,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                       @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                       $dReal
                 } in
                 let {
                   $dElt :: Data.Array.Accelerate.Array.Sugar.Elt a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,%)
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex @ a $dElt
                 } in
                 let {
                   $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                    (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ a
                       $dElt
                 } in
                 let {
                   $dIsProduct1 :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                     (Data.Complex.Complex
                                        (Data.Array.Accelerate.Lift.Plain
                                           (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dElt2 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.Plain
                                     (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dReal1 :: GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a)
                   = GHC.Classes.$p3(%,,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                       @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                       $dReal
                 } in
                 let {
                   $dNum :: GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a)
                   = GHC.Real.$p1Real @ (Data.Array.Accelerate.Smart.Exp a) $dReal1
                 } in
                 (\ (x :: Data.Array.Accelerate.Smart.Exp
                            (Data.Array.Accelerate.Lift.Plain
                               (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a))))
                    (y :: Data.Array.Accelerate.Smart.Exp
                            (Data.Array.Accelerate.Lift.Plain
                               (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a)))) ->
                  case (GHC.Num.+
                          @ (Data.Array.Accelerate.Smart.Exp a)
                          $dNum
                          (Data.Array.Accelerate.Smart.Prj
                             @ Data.Array.Accelerate.Smart.Acc
                             @ Data.Array.Accelerate.Smart.Exp
                             @ a
                             @ (Data.Complex.Complex a)
                             $dElt1
                             $dIsProduct
                             $dElt
                             (Data.Array.Accelerate.Data.Complex.$fEqComplex2 @ a)
                               `cast`
                             (Data.Array.Accelerate.Product.TupleIdx
                                (Trans
                                     (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                               <a>_N <a>_N))
                                     (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                               <a>_N)))
                                <a>_N)_R
                             x `cast`
                             (Data.Array.Accelerate.Smart.Exp
                                (Trans
                                     (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                          <Data.Array.Accelerate.Smart.Exp a>_N)
                                     (Data.Complex.Complex
                                        (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                            `cast`
                          (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                          (Data.Array.Accelerate.Smart.Prj
                             @ Data.Array.Accelerate.Smart.Acc
                             @ Data.Array.Accelerate.Smart.Exp
                             @ a
                             @ (Data.Complex.Complex a)
                             $dElt1
                             $dIsProduct
                             $dElt
                             (Data.Array.Accelerate.Data.Complex.$fEqComplex2 @ a)
                               `cast`
                             (Data.Array.Accelerate.Product.TupleIdx
                                (Trans
                                     (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                               <a>_N <a>_N))
                                     (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                               <a>_N)))
                                <a>_N)_R
                             y `cast`
                             (Data.Array.Accelerate.Smart.Exp
                                (Trans
                                     (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                          <Data.Array.Accelerate.Smart.Exp a>_N)
                                     (Data.Complex.Complex
                                        (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                            `cast`
                          (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N))
                         `cast`
                       (Data.Array.Accelerate.Smart.N:Exp[0] <a>_N) of nt { DEFAULT ->
                  case (GHC.Num.+
                          @ (Data.Array.Accelerate.Smart.Exp a)
                          $dNum
                          (Data.Array.Accelerate.Smart.Prj
                             @ Data.Array.Accelerate.Smart.Acc
                             @ Data.Array.Accelerate.Smart.Exp
                             @ a
                             @ (Data.Complex.Complex a)
                             $dElt1
                             $dIsProduct
                             $dElt
                             (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                               `cast`
                             (Data.Array.Accelerate.Product.TupleIdx
                                (Trans
                                     (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                               <a>_N <a>_N))
                                     (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                               <a>_N)))
                                <a>_N)_R
                             x `cast`
                             (Data.Array.Accelerate.Smart.Exp
                                (Trans
                                     (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                          <Data.Array.Accelerate.Smart.Exp a>_N)
                                     (Data.Complex.Complex
                                        (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                            `cast`
                          (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                          (Data.Array.Accelerate.Smart.Prj
                             @ Data.Array.Accelerate.Smart.Acc
                             @ Data.Array.Accelerate.Smart.Exp
                             @ a
                             @ (Data.Complex.Complex a)
                             $dElt1
                             $dIsProduct
                             $dElt
                             (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                               `cast`
                             (Data.Array.Accelerate.Product.TupleIdx
                                (Trans
                                     (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                               <a>_N <a>_N))
                                     (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                               <a>_N)))
                                <a>_N)_R
                             y `cast`
                             (Data.Array.Accelerate.Smart.Exp
                                (Trans
                                     (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                          <Data.Array.Accelerate.Smart.Exp a>_N)
                                     (Data.Complex.Complex
                                        (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                            `cast`
                          (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N))
                         `cast`
                       (Data.Array.Accelerate.Smart.N:Exp[0] <a>_N) of nt1 { DEFAULT ->
                  (Data.Array.Accelerate.Smart.Tuple
                     @ Data.Array.Accelerate.Smart.Acc
                     @ Data.Array.Accelerate.Smart.Exp
                     @ (Data.Complex.Complex
                          (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a)))
                     $dElt2
                     $dIsProduct1
                     (Data.Array.Accelerate.Array.Sugar.SnocTup
                        @ Data.Array.Accelerate.Smart.Exp
                        @ (((),
                            Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp a)),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ ((),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @~ <(((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a)),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))>_N
                        $dElt
                          `cast`
                        (Data.Array.Accelerate.Array.Sugar.Elt
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                        (Data.Array.Accelerate.Array.Sugar.SnocTup
                           @ Data.Array.Accelerate.Smart.Exp
                           @ ((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ (Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ ()
                           @~ <((),
                                Data.Array.Accelerate.Lift.Plain
                                  (Data.Array.Accelerate.Smart.Exp a))>_N
                           $dElt
                             `cast`
                           (Data.Array.Accelerate.Array.Sugar.Elt
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                           (Data.Array.Accelerate.Array.Sugar.$WNilTup
                              @ Data.Array.Accelerate.Smart.Exp)
                           nt
                             `cast`
                           (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0]
                                                                                 <a>_N))))
                        nt1
                          `cast`
                        (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0]
                                                                              <a>_N))))
                       `cast`
                     (Data.Array.Accelerate.Array.Sugar.Tuple
                        <Data.Array.Accelerate.Smart.Exp>_R
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))
                             (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))))_R)
                    `cast`
                  (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                                                        <Data.Array.Accelerate.Smart.Exp
                                                                           a>_N))) } })
                   `cast`
                 ((Data.Array.Accelerate.Smart.Exp
                     (Trans
                          (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                               <Data.Array.Accelerate.Smart.Exp a>_N)
                          (Data.Complex.Complex
                             (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R
                  ->_R (Data.Array.Accelerate.Smart.Exp
                          (Trans
                               (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                    <Data.Array.Accelerate.Smart.Exp a>_N)
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R
                  ->_R (Data.Array.Accelerate.Smart.Exp
                          (Trans
                               (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                    <Data.Array.Accelerate.Smart.Exp a>_N)
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)) -}
6e776df261973b024f089f8100c185e0
  $fFloatingExp_$c- ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 1, Strictness: <L,U(U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ a
                   ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                     a) ->
                 let {
                   $dRealFrac :: Data.Array.Accelerate.Classes.RealFrac.RealFrac a
                   = Data.Array.Accelerate.Classes.RealFloat.$p1RealFloat
                       @ a
                       $dRealFloat
                 } in
                 let {
                   $dReal :: Data.Array.Accelerate.Classes.Real.Real a
                   = Data.Array.Accelerate.Classes.RealFrac.$p1RealFrac @ a $dRealFrac
                 } in
                 let {
                   $d(%,%) :: Data.Array.Accelerate.Classes.Num.Num a
                   = GHC.Classes.$p1(%,,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                       @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                       $dReal
                 } in
                 let {
                   $dElt :: Data.Array.Accelerate.Array.Sugar.Elt a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,%)
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex @ a $dElt
                 } in
                 let {
                   $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                    (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ a
                       $dElt
                 } in
                 let {
                   $dIsProduct1 :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                     (Data.Complex.Complex
                                        (Data.Array.Accelerate.Lift.Plain
                                           (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dElt2 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.Plain
                                     (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dReal1 :: GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a)
                   = GHC.Classes.$p3(%,,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                       @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                       $dReal
                 } in
                 let {
                   $dNum :: GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a)
                   = GHC.Real.$p1Real @ (Data.Array.Accelerate.Smart.Exp a) $dReal1
                 } in
                 (\ (x :: Data.Array.Accelerate.Smart.Exp
                            (Data.Array.Accelerate.Lift.Plain
                               (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a))))
                    (y :: Data.Array.Accelerate.Smart.Exp
                            (Data.Array.Accelerate.Lift.Plain
                               (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a)))) ->
                  case (GHC.Num.-
                          @ (Data.Array.Accelerate.Smart.Exp a)
                          $dNum
                          (Data.Array.Accelerate.Smart.Prj
                             @ Data.Array.Accelerate.Smart.Acc
                             @ Data.Array.Accelerate.Smart.Exp
                             @ a
                             @ (Data.Complex.Complex a)
                             $dElt1
                             $dIsProduct
                             $dElt
                             (Data.Array.Accelerate.Data.Complex.$fEqComplex2 @ a)
                               `cast`
                             (Data.Array.Accelerate.Product.TupleIdx
                                (Trans
                                     (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                               <a>_N <a>_N))
                                     (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                               <a>_N)))
                                <a>_N)_R
                             x `cast`
                             (Data.Array.Accelerate.Smart.Exp
                                (Trans
                                     (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                          <Data.Array.Accelerate.Smart.Exp a>_N)
                                     (Data.Complex.Complex
                                        (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                            `cast`
                          (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                          (Data.Array.Accelerate.Smart.Prj
                             @ Data.Array.Accelerate.Smart.Acc
                             @ Data.Array.Accelerate.Smart.Exp
                             @ a
                             @ (Data.Complex.Complex a)
                             $dElt1
                             $dIsProduct
                             $dElt
                             (Data.Array.Accelerate.Data.Complex.$fEqComplex2 @ a)
                               `cast`
                             (Data.Array.Accelerate.Product.TupleIdx
                                (Trans
                                     (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                               <a>_N <a>_N))
                                     (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                               <a>_N)))
                                <a>_N)_R
                             y `cast`
                             (Data.Array.Accelerate.Smart.Exp
                                (Trans
                                     (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                          <Data.Array.Accelerate.Smart.Exp a>_N)
                                     (Data.Complex.Complex
                                        (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                            `cast`
                          (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N))
                         `cast`
                       (Data.Array.Accelerate.Smart.N:Exp[0] <a>_N) of nt { DEFAULT ->
                  case (GHC.Num.-
                          @ (Data.Array.Accelerate.Smart.Exp a)
                          $dNum
                          (Data.Array.Accelerate.Smart.Prj
                             @ Data.Array.Accelerate.Smart.Acc
                             @ Data.Array.Accelerate.Smart.Exp
                             @ a
                             @ (Data.Complex.Complex a)
                             $dElt1
                             $dIsProduct
                             $dElt
                             (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                               `cast`
                             (Data.Array.Accelerate.Product.TupleIdx
                                (Trans
                                     (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                               <a>_N <a>_N))
                                     (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                               <a>_N)))
                                <a>_N)_R
                             x `cast`
                             (Data.Array.Accelerate.Smart.Exp
                                (Trans
                                     (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                          <Data.Array.Accelerate.Smart.Exp a>_N)
                                     (Data.Complex.Complex
                                        (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                            `cast`
                          (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                          (Data.Array.Accelerate.Smart.Prj
                             @ Data.Array.Accelerate.Smart.Acc
                             @ Data.Array.Accelerate.Smart.Exp
                             @ a
                             @ (Data.Complex.Complex a)
                             $dElt1
                             $dIsProduct
                             $dElt
                             (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                               `cast`
                             (Data.Array.Accelerate.Product.TupleIdx
                                (Trans
                                     (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                               <a>_N <a>_N))
                                     (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                               <a>_N)))
                                <a>_N)_R
                             y `cast`
                             (Data.Array.Accelerate.Smart.Exp
                                (Trans
                                     (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                          <Data.Array.Accelerate.Smart.Exp a>_N)
                                     (Data.Complex.Complex
                                        (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                            `cast`
                          (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N))
                         `cast`
                       (Data.Array.Accelerate.Smart.N:Exp[0] <a>_N) of nt1 { DEFAULT ->
                  (Data.Array.Accelerate.Smart.Tuple
                     @ Data.Array.Accelerate.Smart.Acc
                     @ Data.Array.Accelerate.Smart.Exp
                     @ (Data.Complex.Complex
                          (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a)))
                     $dElt2
                     $dIsProduct1
                     (Data.Array.Accelerate.Array.Sugar.SnocTup
                        @ Data.Array.Accelerate.Smart.Exp
                        @ (((),
                            Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp a)),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ ((),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @~ <(((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a)),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))>_N
                        $dElt
                          `cast`
                        (Data.Array.Accelerate.Array.Sugar.Elt
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                        (Data.Array.Accelerate.Array.Sugar.SnocTup
                           @ Data.Array.Accelerate.Smart.Exp
                           @ ((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ (Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ ()
                           @~ <((),
                                Data.Array.Accelerate.Lift.Plain
                                  (Data.Array.Accelerate.Smart.Exp a))>_N
                           $dElt
                             `cast`
                           (Data.Array.Accelerate.Array.Sugar.Elt
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                           (Data.Array.Accelerate.Array.Sugar.$WNilTup
                              @ Data.Array.Accelerate.Smart.Exp)
                           nt
                             `cast`
                           (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0]
                                                                                 <a>_N))))
                        nt1
                          `cast`
                        (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0]
                                                                              <a>_N))))
                       `cast`
                     (Data.Array.Accelerate.Array.Sugar.Tuple
                        <Data.Array.Accelerate.Smart.Exp>_R
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))
                             (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))))_R)
                    `cast`
                  (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                                                        <Data.Array.Accelerate.Smart.Exp
                                                                           a>_N))) } })
                   `cast`
                 ((Data.Array.Accelerate.Smart.Exp
                     (Trans
                          (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                               <Data.Array.Accelerate.Smart.Exp a>_N)
                          (Data.Complex.Complex
                             (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R
                  ->_R (Data.Array.Accelerate.Smart.Exp
                          (Trans
                               (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                    <Data.Array.Accelerate.Smart.Exp a>_N)
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R
                  ->_R (Data.Array.Accelerate.Smart.Exp
                          (Trans
                               (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                    <Data.Array.Accelerate.Smart.Exp a>_N)
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)) -}
5800e083830f38500073d9a3f3c3d343
  $fFloatingExp_$c/ ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 1,
     Strictness: <L,1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)> -}
746fafde87181171bc57339bd5a200b2
  $fFloatingExp_$cacos ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 1,
     Strictness: <L,U(U(U(U,U,U),U(U,U),U,U,U,U,U),U(U,U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ a
                   ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                     a) ->
                 let {
                   $dRealFrac :: Data.Array.Accelerate.Classes.RealFrac.RealFrac a
                   = Data.Array.Accelerate.Classes.RealFloat.$p1RealFloat
                       @ a
                       $dRealFloat
                 } in
                 let {
                   $d(%,,%) :: Data.Array.Accelerate.Classes.Real.Real a
                   = Data.Array.Accelerate.Classes.RealFrac.$p1RealFrac @ a $dRealFrac
                 } in
                 let {
                   $d(%,%) :: Data.Array.Accelerate.Classes.Num.Num a
                   = GHC.Classes.$p1(%,,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                       @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,,%)
                 } in
                 let {
                   $dElt :: Data.Array.Accelerate.Array.Sugar.Elt a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,%)
                 } in
                 let {
                   $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.Plain
                                     (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dIsProduct1 :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                     (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ a
                       $dElt
                 } in
                 let {
                   $dElt2 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex @ a $dElt
                 } in
                 let {
                   f :: GHC.Float.RealFloat (Data.Array.Accelerate.Smart.Exp a)
                   = Data.Array.Accelerate.Classes.RealFloat.$fRealFloatExp
                       @ a
                       $dRealFloat
                 } in
                 (\ (eta :: Data.Array.Accelerate.Smart.Exp
                              (Data.Array.Accelerate.Lift.Plain
                                 (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a)))) ->
                  case Data.Complex.$w$cacos
                         @ (Data.Array.Accelerate.Smart.Exp a)
                         f
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt2
                            $dIsProduct1
                            $dElt
                            (Data.Array.Accelerate.Data.Complex.$fEqComplex2 @ a)
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            eta
                              `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt2
                            $dIsProduct1
                            $dElt
                            (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            eta
                              `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N) of ww3 { (#,#) ww4 ww5 ->
                  (Data.Array.Accelerate.Smart.Tuple
                     @ Data.Array.Accelerate.Smart.Acc
                     @ Data.Array.Accelerate.Smart.Exp
                     @ (Data.Complex.Complex
                          (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a)))
                     $dElt1
                     $dIsProduct
                     (Data.Array.Accelerate.Array.Sugar.SnocTup
                        @ Data.Array.Accelerate.Smart.Exp
                        @ (((),
                            Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp a)),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ ((),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @~ <(((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a)),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))>_N
                        $dElt
                          `cast`
                        (Data.Array.Accelerate.Array.Sugar.Elt
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                        (Data.Array.Accelerate.Array.Sugar.SnocTup
                           @ Data.Array.Accelerate.Smart.Exp
                           @ ((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ (Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ ()
                           @~ <((),
                                Data.Array.Accelerate.Lift.Plain
                                  (Data.Array.Accelerate.Smart.Exp a))>_N
                           $dElt
                             `cast`
                           (Data.Array.Accelerate.Array.Sugar.Elt
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                           (Data.Array.Accelerate.Array.Sugar.$WNilTup
                              @ Data.Array.Accelerate.Smart.Exp)
                           ww4
                             `cast`
                           (Data.Array.Accelerate.Smart.Exp
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                        ww5
                          `cast`
                        (Data.Array.Accelerate.Smart.Exp
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                       `cast`
                     (Data.Array.Accelerate.Array.Sugar.Tuple
                        <Data.Array.Accelerate.Smart.Exp>_R
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))
                             (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))))_R)
                    `cast`
                  (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                                                        <Data.Array.Accelerate.Smart.Exp
                                                                           a>_N))) })
                   `cast`
                 ((Data.Array.Accelerate.Smart.Exp
                     (Trans
                          (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                               <Data.Array.Accelerate.Smart.Exp a>_N)
                          (Data.Complex.Complex
                             (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R
                  ->_R (Data.Array.Accelerate.Smart.Exp
                          (Trans
                               (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                    <Data.Array.Accelerate.Smart.Exp a>_N)
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)) -}
e77ba1eb5bc444957a977039e50d9450
  $fFloatingExp_$cacosh ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 1,
     Strictness: <L,U(U(U(U,U,U),U(U,U),U,U,U,U,U),U(U,U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ a
                   ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                     a) ->
                 let {
                   $dRealFrac :: Data.Array.Accelerate.Classes.RealFrac.RealFrac a
                   = Data.Array.Accelerate.Classes.RealFloat.$p1RealFloat
                       @ a
                       $dRealFloat
                 } in
                 let {
                   $d(%,,%) :: Data.Array.Accelerate.Classes.Real.Real a
                   = Data.Array.Accelerate.Classes.RealFrac.$p1RealFrac @ a $dRealFrac
                 } in
                 let {
                   $d(%,%) :: Data.Array.Accelerate.Classes.Num.Num a
                   = GHC.Classes.$p1(%,,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                       @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,,%)
                 } in
                 let {
                   $dElt :: Data.Array.Accelerate.Array.Sugar.Elt a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,%)
                 } in
                 let {
                   $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.Plain
                                     (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dIsProduct1 :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                     (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ a
                       $dElt
                 } in
                 let {
                   $dElt2 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex @ a $dElt
                 } in
                 let {
                   f :: GHC.Float.RealFloat (Data.Array.Accelerate.Smart.Exp a)
                   = Data.Array.Accelerate.Classes.RealFloat.$fRealFloatExp
                       @ a
                       $dRealFloat
                 } in
                 (\ (eta :: Data.Array.Accelerate.Smart.Exp
                              (Data.Array.Accelerate.Lift.Plain
                                 (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a)))) ->
                  case Data.Complex.$w$cacosh
                         @ (Data.Array.Accelerate.Smart.Exp a)
                         f
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt2
                            $dIsProduct1
                            $dElt
                            (Data.Array.Accelerate.Data.Complex.$fEqComplex2 @ a)
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            eta
                              `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt2
                            $dIsProduct1
                            $dElt
                            (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            eta
                              `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N) of ww3 { (#,#) ww4 ww5 ->
                  (Data.Array.Accelerate.Smart.Tuple
                     @ Data.Array.Accelerate.Smart.Acc
                     @ Data.Array.Accelerate.Smart.Exp
                     @ (Data.Complex.Complex
                          (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a)))
                     $dElt1
                     $dIsProduct
                     (Data.Array.Accelerate.Array.Sugar.SnocTup
                        @ Data.Array.Accelerate.Smart.Exp
                        @ (((),
                            Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp a)),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ ((),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @~ <(((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a)),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))>_N
                        $dElt
                          `cast`
                        (Data.Array.Accelerate.Array.Sugar.Elt
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                        (Data.Array.Accelerate.Array.Sugar.SnocTup
                           @ Data.Array.Accelerate.Smart.Exp
                           @ ((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ (Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ ()
                           @~ <((),
                                Data.Array.Accelerate.Lift.Plain
                                  (Data.Array.Accelerate.Smart.Exp a))>_N
                           $dElt
                             `cast`
                           (Data.Array.Accelerate.Array.Sugar.Elt
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                           (Data.Array.Accelerate.Array.Sugar.$WNilTup
                              @ Data.Array.Accelerate.Smart.Exp)
                           ww4
                             `cast`
                           (Data.Array.Accelerate.Smart.Exp
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                        ww5
                          `cast`
                        (Data.Array.Accelerate.Smart.Exp
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                       `cast`
                     (Data.Array.Accelerate.Array.Sugar.Tuple
                        <Data.Array.Accelerate.Smart.Exp>_R
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))
                             (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))))_R)
                    `cast`
                  (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                                                        <Data.Array.Accelerate.Smart.Exp
                                                                           a>_N))) })
                   `cast`
                 ((Data.Array.Accelerate.Smart.Exp
                     (Trans
                          (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                               <Data.Array.Accelerate.Smart.Exp a>_N)
                          (Data.Complex.Complex
                             (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R
                  ->_R (Data.Array.Accelerate.Smart.Exp
                          (Trans
                               (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                    <Data.Array.Accelerate.Smart.Exp a>_N)
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)) -}
5ed20dc0f7f12cc3b2a27921d12ded18
  $fFloatingExp_$casin ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 1,
     Strictness: <L,U(U(U(U,U,U),U(U,U),U,U,U,U,U),U(U,U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ a
                   ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                     a) ->
                 let {
                   $dRealFrac :: Data.Array.Accelerate.Classes.RealFrac.RealFrac a
                   = Data.Array.Accelerate.Classes.RealFloat.$p1RealFloat
                       @ a
                       $dRealFloat
                 } in
                 let {
                   $d(%,,%) :: Data.Array.Accelerate.Classes.Real.Real a
                   = Data.Array.Accelerate.Classes.RealFrac.$p1RealFrac @ a $dRealFrac
                 } in
                 let {
                   $d(%,%) :: Data.Array.Accelerate.Classes.Num.Num a
                   = GHC.Classes.$p1(%,,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                       @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,,%)
                 } in
                 let {
                   $dElt :: Data.Array.Accelerate.Array.Sugar.Elt a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,%)
                 } in
                 let {
                   $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.Plain
                                     (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dIsProduct1 :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                     (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ a
                       $dElt
                 } in
                 let {
                   $dElt2 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex @ a $dElt
                 } in
                 let {
                   f :: GHC.Float.RealFloat (Data.Array.Accelerate.Smart.Exp a)
                   = Data.Array.Accelerate.Classes.RealFloat.$fRealFloatExp
                       @ a
                       $dRealFloat
                 } in
                 (\ (eta :: Data.Array.Accelerate.Smart.Exp
                              (Data.Array.Accelerate.Lift.Plain
                                 (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a)))) ->
                  case Data.Complex.$w$casin
                         @ (Data.Array.Accelerate.Smart.Exp a)
                         f
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt2
                            $dIsProduct1
                            $dElt
                            (Data.Array.Accelerate.Data.Complex.$fEqComplex2 @ a)
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            eta
                              `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt2
                            $dIsProduct1
                            $dElt
                            (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            eta
                              `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N) of ww3 { (#,#) ww4 ww5 ->
                  (Data.Array.Accelerate.Smart.Tuple
                     @ Data.Array.Accelerate.Smart.Acc
                     @ Data.Array.Accelerate.Smart.Exp
                     @ (Data.Complex.Complex
                          (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a)))
                     $dElt1
                     $dIsProduct
                     (Data.Array.Accelerate.Array.Sugar.SnocTup
                        @ Data.Array.Accelerate.Smart.Exp
                        @ (((),
                            Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp a)),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ ((),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @~ <(((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a)),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))>_N
                        $dElt
                          `cast`
                        (Data.Array.Accelerate.Array.Sugar.Elt
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                        (Data.Array.Accelerate.Array.Sugar.SnocTup
                           @ Data.Array.Accelerate.Smart.Exp
                           @ ((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ (Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ ()
                           @~ <((),
                                Data.Array.Accelerate.Lift.Plain
                                  (Data.Array.Accelerate.Smart.Exp a))>_N
                           $dElt
                             `cast`
                           (Data.Array.Accelerate.Array.Sugar.Elt
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                           (Data.Array.Accelerate.Array.Sugar.$WNilTup
                              @ Data.Array.Accelerate.Smart.Exp)
                           ww4
                             `cast`
                           (Data.Array.Accelerate.Smart.Exp
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                        ww5
                          `cast`
                        (Data.Array.Accelerate.Smart.Exp
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                       `cast`
                     (Data.Array.Accelerate.Array.Sugar.Tuple
                        <Data.Array.Accelerate.Smart.Exp>_R
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))
                             (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))))_R)
                    `cast`
                  (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                                                        <Data.Array.Accelerate.Smart.Exp
                                                                           a>_N))) })
                   `cast`
                 ((Data.Array.Accelerate.Smart.Exp
                     (Trans
                          (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                               <Data.Array.Accelerate.Smart.Exp a>_N)
                          (Data.Complex.Complex
                             (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R
                  ->_R (Data.Array.Accelerate.Smart.Exp
                          (Trans
                               (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                    <Data.Array.Accelerate.Smart.Exp a>_N)
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)) -}
b0affc59697c4af42e8205fa9d5d0282
  $fFloatingExp_$casinh ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 1,
     Strictness: <L,U(U(U(U,U,U),U(U,U),U,U,U,U,U),U(U,U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ a
                   ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                     a) ->
                 let {
                   $dRealFrac :: Data.Array.Accelerate.Classes.RealFrac.RealFrac a
                   = Data.Array.Accelerate.Classes.RealFloat.$p1RealFloat
                       @ a
                       $dRealFloat
                 } in
                 let {
                   $d(%,,%) :: Data.Array.Accelerate.Classes.Real.Real a
                   = Data.Array.Accelerate.Classes.RealFrac.$p1RealFrac @ a $dRealFrac
                 } in
                 let {
                   $d(%,%) :: Data.Array.Accelerate.Classes.Num.Num a
                   = GHC.Classes.$p1(%,,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                       @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,,%)
                 } in
                 let {
                   $dElt :: Data.Array.Accelerate.Array.Sugar.Elt a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,%)
                 } in
                 let {
                   $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.Plain
                                     (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dIsProduct1 :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                     (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ a
                       $dElt
                 } in
                 let {
                   $dElt2 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex @ a $dElt
                 } in
                 let {
                   f :: GHC.Float.RealFloat (Data.Array.Accelerate.Smart.Exp a)
                   = Data.Array.Accelerate.Classes.RealFloat.$fRealFloatExp
                       @ a
                       $dRealFloat
                 } in
                 (\ (eta :: Data.Array.Accelerate.Smart.Exp
                              (Data.Array.Accelerate.Lift.Plain
                                 (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a)))) ->
                  case Data.Complex.$w$casinh
                         @ (Data.Array.Accelerate.Smart.Exp a)
                         f
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt2
                            $dIsProduct1
                            $dElt
                            (Data.Array.Accelerate.Data.Complex.$fEqComplex2 @ a)
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            eta
                              `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt2
                            $dIsProduct1
                            $dElt
                            (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            eta
                              `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N) of ww3 { (#,#) ww4 ww5 ->
                  (Data.Array.Accelerate.Smart.Tuple
                     @ Data.Array.Accelerate.Smart.Acc
                     @ Data.Array.Accelerate.Smart.Exp
                     @ (Data.Complex.Complex
                          (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a)))
                     $dElt1
                     $dIsProduct
                     (Data.Array.Accelerate.Array.Sugar.SnocTup
                        @ Data.Array.Accelerate.Smart.Exp
                        @ (((),
                            Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp a)),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ ((),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @~ <(((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a)),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))>_N
                        $dElt
                          `cast`
                        (Data.Array.Accelerate.Array.Sugar.Elt
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                        (Data.Array.Accelerate.Array.Sugar.SnocTup
                           @ Data.Array.Accelerate.Smart.Exp
                           @ ((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ (Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ ()
                           @~ <((),
                                Data.Array.Accelerate.Lift.Plain
                                  (Data.Array.Accelerate.Smart.Exp a))>_N
                           $dElt
                             `cast`
                           (Data.Array.Accelerate.Array.Sugar.Elt
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                           (Data.Array.Accelerate.Array.Sugar.$WNilTup
                              @ Data.Array.Accelerate.Smart.Exp)
                           ww4
                             `cast`
                           (Data.Array.Accelerate.Smart.Exp
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                        ww5
                          `cast`
                        (Data.Array.Accelerate.Smart.Exp
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                       `cast`
                     (Data.Array.Accelerate.Array.Sugar.Tuple
                        <Data.Array.Accelerate.Smart.Exp>_R
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))
                             (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))))_R)
                    `cast`
                  (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                                                        <Data.Array.Accelerate.Smart.Exp
                                                                           a>_N))) })
                   `cast`
                 ((Data.Array.Accelerate.Smart.Exp
                     (Trans
                          (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                               <Data.Array.Accelerate.Smart.Exp a>_N)
                          (Data.Complex.Complex
                             (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R
                  ->_R (Data.Array.Accelerate.Smart.Exp
                          (Trans
                               (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                    <Data.Array.Accelerate.Smart.Exp a>_N)
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)) -}
41ebf441aea78f93b2013707d0e6ac55
  $fFloatingExp_$catan ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 1,
     Strictness: <L,U(U(U(U,U,U),U(U,U),U,U,U,U,U),U(U,U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ a
                   ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                     a) ->
                 let {
                   $dRealFrac :: Data.Array.Accelerate.Classes.RealFrac.RealFrac a
                   = Data.Array.Accelerate.Classes.RealFloat.$p1RealFloat
                       @ a
                       $dRealFloat
                 } in
                 let {
                   $d(%,,%) :: Data.Array.Accelerate.Classes.Real.Real a
                   = Data.Array.Accelerate.Classes.RealFrac.$p1RealFrac @ a $dRealFrac
                 } in
                 let {
                   $d(%,%) :: Data.Array.Accelerate.Classes.Num.Num a
                   = GHC.Classes.$p1(%,,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                       @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,,%)
                 } in
                 let {
                   $dElt :: Data.Array.Accelerate.Array.Sugar.Elt a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,%)
                 } in
                 let {
                   $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.Plain
                                     (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dIsProduct1 :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                     (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ a
                       $dElt
                 } in
                 let {
                   $dElt2 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex @ a $dElt
                 } in
                 let {
                   f :: GHC.Float.RealFloat (Data.Array.Accelerate.Smart.Exp a)
                   = Data.Array.Accelerate.Classes.RealFloat.$fRealFloatExp
                       @ a
                       $dRealFloat
                 } in
                 (\ (eta :: Data.Array.Accelerate.Smart.Exp
                              (Data.Array.Accelerate.Lift.Plain
                                 (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a)))) ->
                  case Data.Complex.$w$catan
                         @ (Data.Array.Accelerate.Smart.Exp a)
                         f
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt2
                            $dIsProduct1
                            $dElt
                            (Data.Array.Accelerate.Data.Complex.$fEqComplex2 @ a)
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            eta
                              `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt2
                            $dIsProduct1
                            $dElt
                            (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            eta
                              `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N) of ww3 { (#,#) ww4 ww5 ->
                  (Data.Array.Accelerate.Smart.Tuple
                     @ Data.Array.Accelerate.Smart.Acc
                     @ Data.Array.Accelerate.Smart.Exp
                     @ (Data.Complex.Complex
                          (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a)))
                     $dElt1
                     $dIsProduct
                     (Data.Array.Accelerate.Array.Sugar.SnocTup
                        @ Data.Array.Accelerate.Smart.Exp
                        @ (((),
                            Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp a)),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ ((),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @~ <(((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a)),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))>_N
                        $dElt
                          `cast`
                        (Data.Array.Accelerate.Array.Sugar.Elt
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                        (Data.Array.Accelerate.Array.Sugar.SnocTup
                           @ Data.Array.Accelerate.Smart.Exp
                           @ ((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ (Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ ()
                           @~ <((),
                                Data.Array.Accelerate.Lift.Plain
                                  (Data.Array.Accelerate.Smart.Exp a))>_N
                           $dElt
                             `cast`
                           (Data.Array.Accelerate.Array.Sugar.Elt
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                           (Data.Array.Accelerate.Array.Sugar.$WNilTup
                              @ Data.Array.Accelerate.Smart.Exp)
                           ww4
                             `cast`
                           (Data.Array.Accelerate.Smart.Exp
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                        ww5
                          `cast`
                        (Data.Array.Accelerate.Smart.Exp
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                       `cast`
                     (Data.Array.Accelerate.Array.Sugar.Tuple
                        <Data.Array.Accelerate.Smart.Exp>_R
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))
                             (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))))_R)
                    `cast`
                  (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                                                        <Data.Array.Accelerate.Smart.Exp
                                                                           a>_N))) })
                   `cast`
                 ((Data.Array.Accelerate.Smart.Exp
                     (Trans
                          (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                               <Data.Array.Accelerate.Smart.Exp a>_N)
                          (Data.Complex.Complex
                             (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R
                  ->_R (Data.Array.Accelerate.Smart.Exp
                          (Trans
                               (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                    <Data.Array.Accelerate.Smart.Exp a>_N)
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)) -}
b3a71d70e6d46649e3c2325a4d926335
  $fFloatingExp_$catanh ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 1,
     Strictness: <L,U(U(U(U,U,U),U(U,U),U,U,U,U,U),U(U,U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ a
                   ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                     a) ->
                 let {
                   $dRealFrac :: Data.Array.Accelerate.Classes.RealFrac.RealFrac a
                   = Data.Array.Accelerate.Classes.RealFloat.$p1RealFloat
                       @ a
                       $dRealFloat
                 } in
                 let {
                   $d(%,,%) :: Data.Array.Accelerate.Classes.Real.Real a
                   = Data.Array.Accelerate.Classes.RealFrac.$p1RealFrac @ a $dRealFrac
                 } in
                 let {
                   $d(%,%) :: Data.Array.Accelerate.Classes.Num.Num a
                   = GHC.Classes.$p1(%,,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                       @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,,%)
                 } in
                 let {
                   $dElt :: Data.Array.Accelerate.Array.Sugar.Elt a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,%)
                 } in
                 let {
                   $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.Plain
                                     (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dIsProduct1 :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                     (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ a
                       $dElt
                 } in
                 let {
                   $dElt2 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex @ a $dElt
                 } in
                 let {
                   f :: GHC.Float.RealFloat (Data.Array.Accelerate.Smart.Exp a)
                   = Data.Array.Accelerate.Classes.RealFloat.$fRealFloatExp
                       @ a
                       $dRealFloat
                 } in
                 (\ (eta :: Data.Array.Accelerate.Smart.Exp
                              (Data.Array.Accelerate.Lift.Plain
                                 (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a)))) ->
                  case Data.Complex.$w$catanh
                         @ (Data.Array.Accelerate.Smart.Exp a)
                         f
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt2
                            $dIsProduct1
                            $dElt
                            (Data.Array.Accelerate.Data.Complex.$fEqComplex2 @ a)
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            eta
                              `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt2
                            $dIsProduct1
                            $dElt
                            (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            eta
                              `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N) of ww3 { (#,#) ww4 ww5 ->
                  (Data.Array.Accelerate.Smart.Tuple
                     @ Data.Array.Accelerate.Smart.Acc
                     @ Data.Array.Accelerate.Smart.Exp
                     @ (Data.Complex.Complex
                          (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a)))
                     $dElt1
                     $dIsProduct
                     (Data.Array.Accelerate.Array.Sugar.SnocTup
                        @ Data.Array.Accelerate.Smart.Exp
                        @ (((),
                            Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp a)),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ ((),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @~ <(((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a)),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))>_N
                        $dElt
                          `cast`
                        (Data.Array.Accelerate.Array.Sugar.Elt
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                        (Data.Array.Accelerate.Array.Sugar.SnocTup
                           @ Data.Array.Accelerate.Smart.Exp
                           @ ((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ (Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ ()
                           @~ <((),
                                Data.Array.Accelerate.Lift.Plain
                                  (Data.Array.Accelerate.Smart.Exp a))>_N
                           $dElt
                             `cast`
                           (Data.Array.Accelerate.Array.Sugar.Elt
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                           (Data.Array.Accelerate.Array.Sugar.$WNilTup
                              @ Data.Array.Accelerate.Smart.Exp)
                           ww4
                             `cast`
                           (Data.Array.Accelerate.Smart.Exp
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                        ww5
                          `cast`
                        (Data.Array.Accelerate.Smart.Exp
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                       `cast`
                     (Data.Array.Accelerate.Array.Sugar.Tuple
                        <Data.Array.Accelerate.Smart.Exp>_R
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))
                             (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))))_R)
                    `cast`
                  (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                                                        <Data.Array.Accelerate.Smart.Exp
                                                                           a>_N))) })
                   `cast`
                 ((Data.Array.Accelerate.Smart.Exp
                     (Trans
                          (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                               <Data.Array.Accelerate.Smart.Exp a>_N)
                          (Data.Complex.Complex
                             (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R
                  ->_R (Data.Array.Accelerate.Smart.Exp
                          (Trans
                               (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                    <Data.Array.Accelerate.Smart.Exp a>_N)
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)) -}
18352c1d971707af8203a796934894e1
  $fFloatingExp_$ccos ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 1,
     Strictness: <L,U(U(U(U,U,U),U(U,U),U,U,U,U,U),U(U,U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ a
                   ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                     a) ->
                 let {
                   $dRealFrac :: Data.Array.Accelerate.Classes.RealFrac.RealFrac a
                   = Data.Array.Accelerate.Classes.RealFloat.$p1RealFloat
                       @ a
                       $dRealFloat
                 } in
                 let {
                   $d(%,,%) :: Data.Array.Accelerate.Classes.Real.Real a
                   = Data.Array.Accelerate.Classes.RealFrac.$p1RealFrac @ a $dRealFrac
                 } in
                 let {
                   $d(%,%) :: Data.Array.Accelerate.Classes.Num.Num a
                   = GHC.Classes.$p1(%,,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                       @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,,%)
                 } in
                 let {
                   $dElt :: Data.Array.Accelerate.Array.Sugar.Elt a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,%)
                 } in
                 let {
                   $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.Plain
                                     (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dIsProduct1 :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                     (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ a
                       $dElt
                 } in
                 let {
                   $dElt2 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex @ a $dElt
                 } in
                 let {
                   f :: GHC.Float.RealFloat (Data.Array.Accelerate.Smart.Exp a)
                   = Data.Array.Accelerate.Classes.RealFloat.$fRealFloatExp
                       @ a
                       $dRealFloat
                 } in
                 (\ (eta :: Data.Array.Accelerate.Smart.Exp
                              (Data.Array.Accelerate.Lift.Plain
                                 (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a)))) ->
                  case Data.Complex.$w$ccos
                         @ (Data.Array.Accelerate.Smart.Exp a)
                         f
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt2
                            $dIsProduct1
                            $dElt
                            (Data.Array.Accelerate.Data.Complex.$fEqComplex2 @ a)
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            eta
                              `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt2
                            $dIsProduct1
                            $dElt
                            (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            eta
                              `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N) of ww3 { (#,#) ww4 ww5 ->
                  (Data.Array.Accelerate.Smart.Tuple
                     @ Data.Array.Accelerate.Smart.Acc
                     @ Data.Array.Accelerate.Smart.Exp
                     @ (Data.Complex.Complex
                          (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a)))
                     $dElt1
                     $dIsProduct
                     (Data.Array.Accelerate.Array.Sugar.SnocTup
                        @ Data.Array.Accelerate.Smart.Exp
                        @ (((),
                            Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp a)),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ ((),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @~ <(((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a)),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))>_N
                        $dElt
                          `cast`
                        (Data.Array.Accelerate.Array.Sugar.Elt
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                        (Data.Array.Accelerate.Array.Sugar.SnocTup
                           @ Data.Array.Accelerate.Smart.Exp
                           @ ((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ (Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ ()
                           @~ <((),
                                Data.Array.Accelerate.Lift.Plain
                                  (Data.Array.Accelerate.Smart.Exp a))>_N
                           $dElt
                             `cast`
                           (Data.Array.Accelerate.Array.Sugar.Elt
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                           (Data.Array.Accelerate.Array.Sugar.$WNilTup
                              @ Data.Array.Accelerate.Smart.Exp)
                           ww4
                             `cast`
                           (Data.Array.Accelerate.Smart.Exp
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                        ww5
                          `cast`
                        (Data.Array.Accelerate.Smart.Exp
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                       `cast`
                     (Data.Array.Accelerate.Array.Sugar.Tuple
                        <Data.Array.Accelerate.Smart.Exp>_R
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))
                             (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))))_R)
                    `cast`
                  (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                                                        <Data.Array.Accelerate.Smart.Exp
                                                                           a>_N))) })
                   `cast`
                 ((Data.Array.Accelerate.Smart.Exp
                     (Trans
                          (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                               <Data.Array.Accelerate.Smart.Exp a>_N)
                          (Data.Complex.Complex
                             (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R
                  ->_R (Data.Array.Accelerate.Smart.Exp
                          (Trans
                               (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                    <Data.Array.Accelerate.Smart.Exp a>_N)
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)) -}
07282b5117d82ee0f7cb036765452f76
  $fFloatingExp_$ccosh ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 1,
     Strictness: <L,U(U(U(U,U,U),U(U,U),U,U,U,U,U),U(U,U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ a
                   ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                     a) ->
                 let {
                   $dRealFrac :: Data.Array.Accelerate.Classes.RealFrac.RealFrac a
                   = Data.Array.Accelerate.Classes.RealFloat.$p1RealFloat
                       @ a
                       $dRealFloat
                 } in
                 let {
                   $d(%,,%) :: Data.Array.Accelerate.Classes.Real.Real a
                   = Data.Array.Accelerate.Classes.RealFrac.$p1RealFrac @ a $dRealFrac
                 } in
                 let {
                   $d(%,%) :: Data.Array.Accelerate.Classes.Num.Num a
                   = GHC.Classes.$p1(%,,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                       @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,,%)
                 } in
                 let {
                   $dElt :: Data.Array.Accelerate.Array.Sugar.Elt a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,%)
                 } in
                 let {
                   $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.Plain
                                     (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dIsProduct1 :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                     (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ a
                       $dElt
                 } in
                 let {
                   $dElt2 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex @ a $dElt
                 } in
                 let {
                   f :: GHC.Float.RealFloat (Data.Array.Accelerate.Smart.Exp a)
                   = Data.Array.Accelerate.Classes.RealFloat.$fRealFloatExp
                       @ a
                       $dRealFloat
                 } in
                 (\ (eta :: Data.Array.Accelerate.Smart.Exp
                              (Data.Array.Accelerate.Lift.Plain
                                 (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a)))) ->
                  case Data.Complex.$w$ccosh
                         @ (Data.Array.Accelerate.Smart.Exp a)
                         f
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt2
                            $dIsProduct1
                            $dElt
                            (Data.Array.Accelerate.Data.Complex.$fEqComplex2 @ a)
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            eta
                              `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt2
                            $dIsProduct1
                            $dElt
                            (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            eta
                              `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N) of ww3 { (#,#) ww4 ww5 ->
                  (Data.Array.Accelerate.Smart.Tuple
                     @ Data.Array.Accelerate.Smart.Acc
                     @ Data.Array.Accelerate.Smart.Exp
                     @ (Data.Complex.Complex
                          (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a)))
                     $dElt1
                     $dIsProduct
                     (Data.Array.Accelerate.Array.Sugar.SnocTup
                        @ Data.Array.Accelerate.Smart.Exp
                        @ (((),
                            Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp a)),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ ((),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @~ <(((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a)),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))>_N
                        $dElt
                          `cast`
                        (Data.Array.Accelerate.Array.Sugar.Elt
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                        (Data.Array.Accelerate.Array.Sugar.SnocTup
                           @ Data.Array.Accelerate.Smart.Exp
                           @ ((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ (Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ ()
                           @~ <((),
                                Data.Array.Accelerate.Lift.Plain
                                  (Data.Array.Accelerate.Smart.Exp a))>_N
                           $dElt
                             `cast`
                           (Data.Array.Accelerate.Array.Sugar.Elt
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                           (Data.Array.Accelerate.Array.Sugar.$WNilTup
                              @ Data.Array.Accelerate.Smart.Exp)
                           ww4
                             `cast`
                           (Data.Array.Accelerate.Smart.Exp
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                        ww5
                          `cast`
                        (Data.Array.Accelerate.Smart.Exp
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                       `cast`
                     (Data.Array.Accelerate.Array.Sugar.Tuple
                        <Data.Array.Accelerate.Smart.Exp>_R
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))
                             (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))))_R)
                    `cast`
                  (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                                                        <Data.Array.Accelerate.Smart.Exp
                                                                           a>_N))) })
                   `cast`
                 ((Data.Array.Accelerate.Smart.Exp
                     (Trans
                          (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                               <Data.Array.Accelerate.Smart.Exp a>_N)
                          (Data.Complex.Complex
                             (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R
                  ->_R (Data.Array.Accelerate.Smart.Exp
                          (Trans
                               (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                    <Data.Array.Accelerate.Smart.Exp a>_N)
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)) -}
a49661557971d2445437646cbad4d70f
  $fFloatingExp_$cexp ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 1,
     Strictness: <L,U(U(U(U,U,U),U(U,U),U,U,U,U,U),U(U,U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ a
                   ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                     a) ->
                 let {
                   $dRealFrac :: Data.Array.Accelerate.Classes.RealFrac.RealFrac a
                   = Data.Array.Accelerate.Classes.RealFloat.$p1RealFloat
                       @ a
                       $dRealFloat
                 } in
                 let {
                   $d(%,,%) :: Data.Array.Accelerate.Classes.Real.Real a
                   = Data.Array.Accelerate.Classes.RealFrac.$p1RealFrac @ a $dRealFrac
                 } in
                 let {
                   $d(%,%) :: Data.Array.Accelerate.Classes.Num.Num a
                   = GHC.Classes.$p1(%,,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                       @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,,%)
                 } in
                 let {
                   $dElt :: Data.Array.Accelerate.Array.Sugar.Elt a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,%)
                 } in
                 let {
                   $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.Plain
                                     (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dIsProduct1 :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                     (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ a
                       $dElt
                 } in
                 let {
                   $dElt2 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex @ a $dElt
                 } in
                 let {
                   f :: GHC.Float.RealFloat (Data.Array.Accelerate.Smart.Exp a)
                   = Data.Array.Accelerate.Classes.RealFloat.$fRealFloatExp
                       @ a
                       $dRealFloat
                 } in
                 (\ (eta :: Data.Array.Accelerate.Smart.Exp
                              (Data.Array.Accelerate.Lift.Plain
                                 (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a)))) ->
                  case Data.Complex.$w$cexp
                         @ (Data.Array.Accelerate.Smart.Exp a)
                         f
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt2
                            $dIsProduct1
                            $dElt
                            (Data.Array.Accelerate.Data.Complex.$fEqComplex2 @ a)
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            eta
                              `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt2
                            $dIsProduct1
                            $dElt
                            (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            eta
                              `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N) of ww3 { (#,#) ww4 ww5 ->
                  (Data.Array.Accelerate.Smart.Tuple
                     @ Data.Array.Accelerate.Smart.Acc
                     @ Data.Array.Accelerate.Smart.Exp
                     @ (Data.Complex.Complex
                          (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a)))
                     $dElt1
                     $dIsProduct
                     (Data.Array.Accelerate.Array.Sugar.SnocTup
                        @ Data.Array.Accelerate.Smart.Exp
                        @ (((),
                            Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp a)),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ ((),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @~ <(((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a)),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))>_N
                        $dElt
                          `cast`
                        (Data.Array.Accelerate.Array.Sugar.Elt
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                        (Data.Array.Accelerate.Array.Sugar.SnocTup
                           @ Data.Array.Accelerate.Smart.Exp
                           @ ((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ (Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ ()
                           @~ <((),
                                Data.Array.Accelerate.Lift.Plain
                                  (Data.Array.Accelerate.Smart.Exp a))>_N
                           $dElt
                             `cast`
                           (Data.Array.Accelerate.Array.Sugar.Elt
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                           (Data.Array.Accelerate.Array.Sugar.$WNilTup
                              @ Data.Array.Accelerate.Smart.Exp)
                           ww4
                             `cast`
                           (Data.Array.Accelerate.Smart.Exp
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                        ww5
                          `cast`
                        (Data.Array.Accelerate.Smart.Exp
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                       `cast`
                     (Data.Array.Accelerate.Array.Sugar.Tuple
                        <Data.Array.Accelerate.Smart.Exp>_R
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))
                             (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))))_R)
                    `cast`
                  (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                                                        <Data.Array.Accelerate.Smart.Exp
                                                                           a>_N))) })
                   `cast`
                 ((Data.Array.Accelerate.Smart.Exp
                     (Trans
                          (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                               <Data.Array.Accelerate.Smart.Exp a>_N)
                          (Data.Complex.Complex
                             (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R
                  ->_R (Data.Array.Accelerate.Smart.Exp
                          (Trans
                               (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                    <Data.Array.Accelerate.Smart.Exp a>_N)
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)) -}
76633e15e671fd8c41cc696154a48ecc
  $fFloatingExp_$cexpm1 ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 2,
     Strictness: <L,U(U(U(U,U,U(U(U,U,U,U,U,U,U),U,U)),U(U,U),U,U,U,U,U),U(U,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)),A,A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)))><L,U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                     a)
                   (eta :: Data.Array.Accelerate.Smart.Exp
                             (Data.Complex.Complex a)) ->
                 Data.Array.Accelerate.Data.Complex.$fFloatingExp_$c-
                   @ a
                   $dRealFloat
                   (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$cexp
                      @ a
                      $dRealFloat
                      eta)
                   (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$cfromInteger
                      @ a
                      $dRealFloat
                      1)) -}
3e111f6d931bfc67b2b02215409e27aa
  $fFloatingExp_$cfromInteger ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    GHC.Integer.Type.Integer
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 1,
     Strictness: <L,1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ a
                   ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                     a) ->
                 let {
                   $dRealFrac :: Data.Array.Accelerate.Classes.RealFrac.RealFrac a
                   = Data.Array.Accelerate.Classes.RealFloat.$p1RealFloat
                       @ a
                       $dRealFloat
                 } in
                 let {
                   $d(%,,%) :: Data.Array.Accelerate.Classes.Real.Real a
                   = Data.Array.Accelerate.Classes.RealFrac.$p1RealFrac @ a $dRealFrac
                 } in
                 let {
                   $d(%,%) :: Data.Array.Accelerate.Classes.Num.Num a
                   = GHC.Classes.$p1(%,,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                       @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,,%)
                 } in
                 let {
                   $dElt :: Data.Array.Accelerate.Array.Sugar.Elt a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,%)
                 } in
                 let {
                   $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.Plain
                                     (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dNum :: GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a)
                   = GHC.Classes.$p2(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,%)
                 } in
                 let {
                   lvl13 :: Data.Array.Accelerate.Smart.Exp a
                   = GHC.Num.fromInteger
                       @ (Data.Array.Accelerate.Smart.Exp a)
                       $dNum
                       Data.Array.Accelerate.Data.Complex.$fFloatingExp1
                 } in
                 (\ (n :: GHC.Integer.Type.Integer) ->
                  case (GHC.Num.fromInteger
                          @ (Data.Array.Accelerate.Smart.Exp a)
                          $dNum
                          n)
                         `cast`
                       (Data.Array.Accelerate.Smart.N:Exp[0] <a>_N) of nt { DEFAULT ->
                  case lvl13
                         `cast`
                       (Data.Array.Accelerate.Smart.N:Exp[0] <a>_N) of nt1 { DEFAULT ->
                  (Data.Array.Accelerate.Smart.Tuple
                     @ Data.Array.Accelerate.Smart.Acc
                     @ Data.Array.Accelerate.Smart.Exp
                     @ (Data.Complex.Complex
                          (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a)))
                     $dElt1
                     $dIsProduct
                     (Data.Array.Accelerate.Array.Sugar.SnocTup
                        @ Data.Array.Accelerate.Smart.Exp
                        @ (((),
                            Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp a)),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ ((),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @~ <(((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a)),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))>_N
                        $dElt
                          `cast`
                        (Data.Array.Accelerate.Array.Sugar.Elt
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                        (Data.Array.Accelerate.Array.Sugar.SnocTup
                           @ Data.Array.Accelerate.Smart.Exp
                           @ ((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ (Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ ()
                           @~ <((),
                                Data.Array.Accelerate.Lift.Plain
                                  (Data.Array.Accelerate.Smart.Exp a))>_N
                           $dElt
                             `cast`
                           (Data.Array.Accelerate.Array.Sugar.Elt
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                           (Data.Array.Accelerate.Array.Sugar.$WNilTup
                              @ Data.Array.Accelerate.Smart.Exp)
                           nt
                             `cast`
                           (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0]
                                                                                 <a>_N))))
                        nt1
                          `cast`
                        (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0]
                                                                              <a>_N))))
                       `cast`
                     (Data.Array.Accelerate.Array.Sugar.Tuple
                        <Data.Array.Accelerate.Smart.Exp>_R
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))
                             (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))))_R)
                    `cast`
                  (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                                                        <Data.Array.Accelerate.Smart.Exp
                                                                           a>_N))) } })
                   `cast`
                 (<GHC.Integer.Type.Integer>_R
                  ->_R (Data.Array.Accelerate.Smart.Exp
                          (Trans
                               (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                    <Data.Array.Accelerate.Smart.Exp a>_N)
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)) -}
24861766dfd992c596c43f9f6eedcfcd
  $fFloatingExp_$clog ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 1,
     Strictness: <L,U(U,U(U,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)),A,A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)))>,
     Unfolding: (\ @ a
                   ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                     a) ->
                 let {
                   $dRealFrac :: Data.Array.Accelerate.Classes.RealFrac.RealFrac a
                   = Data.Array.Accelerate.Classes.RealFloat.$p1RealFloat
                       @ a
                       $dRealFloat
                 } in
                 let {
                   $d(%,,%) :: Data.Array.Accelerate.Classes.Real.Real a
                   = Data.Array.Accelerate.Classes.RealFrac.$p1RealFrac @ a $dRealFrac
                 } in
                 let {
                   $d(%,%) :: Data.Array.Accelerate.Classes.Num.Num a
                   = GHC.Classes.$p1(%,,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                       @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,,%)
                 } in
                 let {
                   $dElt :: Data.Array.Accelerate.Array.Sugar.Elt a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,%)
                 } in
                 let {
                   $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.Plain
                                     (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dFloating :: Data.Array.Accelerate.Classes.Floating.Floating a
                   = Data.Array.Accelerate.Classes.RealFloat.$p2RealFloat
                       @ a
                       $dRealFloat
                 } in
                 let {
                   $dFloating1 :: GHC.Float.Floating
                                    (Data.Array.Accelerate.Smart.Exp a)
                   = GHC.Classes.$p2(%,%)
                       @ (Data.Array.Accelerate.Classes.Fractional.Fractional a)
                       @ (GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp a))
                       $dFloating
                 } in
                 (\ (z :: Data.Array.Accelerate.Smart.Exp
                            (Data.Complex.Complex a)) ->
                  case (GHC.Float.log
                          @ (Data.Array.Accelerate.Smart.Exp a)
                          $dFloating1
                          (Data.Array.Accelerate.Data.Complex.magnitude @ a $dRealFloat z))
                         `cast`
                       (Data.Array.Accelerate.Smart.N:Exp[0] <a>_N) of nt { DEFAULT ->
                  case (Data.Array.Accelerate.Data.Complex.phase @ a $dRealFloat z)
                         `cast`
                       (Data.Array.Accelerate.Smart.N:Exp[0] <a>_N) of nt1 { DEFAULT ->
                  (Data.Array.Accelerate.Smart.Tuple
                     @ Data.Array.Accelerate.Smart.Acc
                     @ Data.Array.Accelerate.Smart.Exp
                     @ (Data.Complex.Complex
                          (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a)))
                     $dElt1
                     $dIsProduct
                     (Data.Array.Accelerate.Array.Sugar.SnocTup
                        @ Data.Array.Accelerate.Smart.Exp
                        @ (((),
                            Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp a)),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ ((),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @~ <(((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a)),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))>_N
                        $dElt
                          `cast`
                        (Data.Array.Accelerate.Array.Sugar.Elt
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                        (Data.Array.Accelerate.Array.Sugar.SnocTup
                           @ Data.Array.Accelerate.Smart.Exp
                           @ ((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ (Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ ()
                           @~ <((),
                                Data.Array.Accelerate.Lift.Plain
                                  (Data.Array.Accelerate.Smart.Exp a))>_N
                           $dElt
                             `cast`
                           (Data.Array.Accelerate.Array.Sugar.Elt
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                           (Data.Array.Accelerate.Array.Sugar.$WNilTup
                              @ Data.Array.Accelerate.Smart.Exp)
                           nt
                             `cast`
                           (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0]
                                                                                 <a>_N))))
                        nt1
                          `cast`
                        (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0]
                                                                              <a>_N))))
                       `cast`
                     (Data.Array.Accelerate.Array.Sugar.Tuple
                        <Data.Array.Accelerate.Smart.Exp>_R
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))
                             (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))))_R)
                    `cast`
                  (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                                                        <Data.Array.Accelerate.Smart.Exp
                                                                           a>_N))) } })
                   `cast`
                 (<Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)>_R
                  ->_R (Data.Array.Accelerate.Smart.Exp
                          (Trans
                               (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                    <Data.Array.Accelerate.Smart.Exp a>_N)
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)) -}
bbd802b7438c70e02f2e785afe8f96b2
  $fFloatingExp_$clog1mexp ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 2,
     Strictness: <L,U(U(U(U,U,U(U(U,U,U,U,U,U,U),U,U)),U(U,U),U,U,U,U,U),U(U,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)),A,A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)))><L,U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                     a)
                   (eta :: Data.Array.Accelerate.Smart.Exp
                             (Data.Complex.Complex a)) ->
                 Data.Array.Accelerate.Data.Complex.$fFloatingExp_$clog
                   @ a
                   $dRealFloat
                   (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$c+
                      @ a
                      $dRealFloat
                      (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$cfromInteger
                         @ a
                         $dRealFloat
                         1)
                      (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$cnegate
                         @ a
                         $dRealFloat
                         (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$cexp
                            @ a
                            $dRealFloat
                            eta)))) -}
594268d05da8b5676f4d9b40533d0dbd
  $fFloatingExp_$clog1p ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 2,
     Strictness: <L,U(U(U(U,U,U(U(U,U,U,U,U,U,U),U,U)),U(U,U),U,U,U,U,U),U(U,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)),A,A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)))><L,U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                     a)
                   (eta :: Data.Array.Accelerate.Smart.Exp
                             (Data.Complex.Complex a)) ->
                 Data.Array.Accelerate.Data.Complex.$fFloatingExp_$clog
                   @ a
                   $dRealFloat
                   (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$c+
                      @ a
                      $dRealFloat
                      (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$cfromInteger
                         @ a
                         $dRealFloat
                         1)
                      eta)) -}
9534add794af6b6f601207b2d9239e5b
  $fFloatingExp_$clog1pexp ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 2,
     Strictness: <L,U(U(U(U,U,U(U(U,U,U,U,U,U,U),U,U)),U(U,U),U,U,U,U,U),U(U,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)),A,A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)))><L,U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                     a)
                   (x :: Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)) ->
                 Data.Array.Accelerate.Data.Complex.$fFloatingExp_$clog
                   @ a
                   $dRealFloat
                   (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$c+
                      @ a
                      $dRealFloat
                      (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$cfromInteger
                         @ a
                         $dRealFloat
                         1)
                      (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$cexp
                         @ a
                         $dRealFloat
                         x))) -}
62e74a6515d2f897a87b557fdbf1cbe5
  $fFloatingExp_$clogBase ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 3,
     Strictness: <L,U(U(U(U,U,U(U(U,U,U,U,U,U,U),U,U)),U(U,U),U,U,U,U,U),U(U,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)),A,A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)))><L,U><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                     a)
                   (eta :: Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a))
                   (eta1 :: Data.Array.Accelerate.Smart.Exp
                              (Data.Complex.Complex a)) ->
                 Data.Array.Accelerate.Data.Complex.$fFloatingExp_$c/
                   @ a
                   $dRealFloat
                   (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$clog
                      @ a
                      $dRealFloat
                      eta1)
                   (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$clog
                      @ a
                      $dRealFloat
                      eta)) -}
e04809602da5e2f4c7c61229a87d284a
  $fFloatingExp_$cnegate ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 1, Strictness: <L,U(U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ a
                   ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                     a) ->
                 let {
                   $dRealFrac :: Data.Array.Accelerate.Classes.RealFrac.RealFrac a
                   = Data.Array.Accelerate.Classes.RealFloat.$p1RealFloat
                       @ a
                       $dRealFloat
                 } in
                 let {
                   $dReal :: Data.Array.Accelerate.Classes.Real.Real a
                   = Data.Array.Accelerate.Classes.RealFrac.$p1RealFrac @ a $dRealFrac
                 } in
                 let {
                   $d(%,%) :: Data.Array.Accelerate.Classes.Num.Num a
                   = GHC.Classes.$p1(%,,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                       @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                       $dReal
                 } in
                 let {
                   $dElt :: Data.Array.Accelerate.Array.Sugar.Elt a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,%)
                 } in
                 let {
                   $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.Plain
                                     (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dIsProduct1 :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                     (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ a
                       $dElt
                 } in
                 let {
                   $dElt2 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex @ a $dElt
                 } in
                 let {
                   $dReal1 :: GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a)
                   = GHC.Classes.$p3(%,,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                       @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                       $dReal
                 } in
                 let {
                   $dNum :: GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a)
                   = GHC.Real.$p1Real @ (Data.Array.Accelerate.Smart.Exp a) $dReal1
                 } in
                 (\ (eta :: Data.Array.Accelerate.Smart.Exp
                              (Data.Array.Accelerate.Lift.Plain
                                 (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a)))) ->
                  case (GHC.Num.negate
                          @ (Data.Array.Accelerate.Smart.Exp a)
                          $dNum
                          (Data.Array.Accelerate.Smart.Prj
                             @ Data.Array.Accelerate.Smart.Acc
                             @ Data.Array.Accelerate.Smart.Exp
                             @ a
                             @ (Data.Complex.Complex a)
                             $dElt2
                             $dIsProduct1
                             $dElt
                             (Data.Array.Accelerate.Data.Complex.$fEqComplex2 @ a)
                               `cast`
                             (Data.Array.Accelerate.Product.TupleIdx
                                (Trans
                                     (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                               <a>_N <a>_N))
                                     (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                               <a>_N)))
                                <a>_N)_R
                             eta
                               `cast`
                             (Data.Array.Accelerate.Smart.Exp
                                (Trans
                                     (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                          <Data.Array.Accelerate.Smart.Exp a>_N)
                                     (Data.Complex.Complex
                                        (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                            `cast`
                          (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N))
                         `cast`
                       (Data.Array.Accelerate.Smart.N:Exp[0] <a>_N) of nt { DEFAULT ->
                  case (GHC.Num.negate
                          @ (Data.Array.Accelerate.Smart.Exp a)
                          $dNum
                          (Data.Array.Accelerate.Smart.Prj
                             @ Data.Array.Accelerate.Smart.Acc
                             @ Data.Array.Accelerate.Smart.Exp
                             @ a
                             @ (Data.Complex.Complex a)
                             $dElt2
                             $dIsProduct1
                             $dElt
                             (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                               `cast`
                             (Data.Array.Accelerate.Product.TupleIdx
                                (Trans
                                     (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                               <a>_N <a>_N))
                                     (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                               <a>_N)))
                                <a>_N)_R
                             eta
                               `cast`
                             (Data.Array.Accelerate.Smart.Exp
                                (Trans
                                     (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                          <Data.Array.Accelerate.Smart.Exp a>_N)
                                     (Data.Complex.Complex
                                        (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                            `cast`
                          (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N))
                         `cast`
                       (Data.Array.Accelerate.Smart.N:Exp[0] <a>_N) of nt1 { DEFAULT ->
                  (Data.Array.Accelerate.Smart.Tuple
                     @ Data.Array.Accelerate.Smart.Acc
                     @ Data.Array.Accelerate.Smart.Exp
                     @ (Data.Complex.Complex
                          (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a)))
                     $dElt1
                     $dIsProduct
                     (Data.Array.Accelerate.Array.Sugar.SnocTup
                        @ Data.Array.Accelerate.Smart.Exp
                        @ (((),
                            Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp a)),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ ((),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @~ <(((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a)),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))>_N
                        $dElt
                          `cast`
                        (Data.Array.Accelerate.Array.Sugar.Elt
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                        (Data.Array.Accelerate.Array.Sugar.SnocTup
                           @ Data.Array.Accelerate.Smart.Exp
                           @ ((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ (Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ ()
                           @~ <((),
                                Data.Array.Accelerate.Lift.Plain
                                  (Data.Array.Accelerate.Smart.Exp a))>_N
                           $dElt
                             `cast`
                           (Data.Array.Accelerate.Array.Sugar.Elt
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                           (Data.Array.Accelerate.Array.Sugar.$WNilTup
                              @ Data.Array.Accelerate.Smart.Exp)
                           nt
                             `cast`
                           (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0]
                                                                                 <a>_N))))
                        nt1
                          `cast`
                        (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0]
                                                                              <a>_N))))
                       `cast`
                     (Data.Array.Accelerate.Array.Sugar.Tuple
                        <Data.Array.Accelerate.Smart.Exp>_R
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))
                             (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))))_R)
                    `cast`
                  (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                                                        <Data.Array.Accelerate.Smart.Exp
                                                                           a>_N))) } })
                   `cast`
                 ((Data.Array.Accelerate.Smart.Exp
                     (Trans
                          (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                               <Data.Array.Accelerate.Smart.Exp a>_N)
                          (Data.Complex.Complex
                             (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R
                  ->_R (Data.Array.Accelerate.Smart.Exp
                          (Trans
                               (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                    <Data.Array.Accelerate.Smart.Exp a>_N)
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)) -}
29815f0bf8449459cced4aeff6114094
  $fFloatingExp_$cpi ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 1,
     Strictness: <S(S(S(LLS(S(LLLLLLC(S))LL))LLLLLL)S(LS(LSLLLLLLLLLLLLLLLLLLLLL))LLLLLLLLLLLLLL),U(U(U(U,U,U(U(U,U,U,U,U,U,U),U,U)),U,U,U,U,U,U),1*U(A,1*U(A,1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m3,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Data.Complex.$fFloatingExp2
                  `cast`
                (forall (a :: <*>_N).
                 <Data.Array.Accelerate.Classes.RealFloat.RealFloat a>_R
                 ->_R (Data.Array.Accelerate.Smart.Exp
                         (Trans
                              (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                   <Data.Array.Accelerate.Smart.Exp a>_N)
                              (Data.Complex.Complex
                                 (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R) -}
5761cbedd6d40d1dbd79331eccb30bd3
  $fFloatingExp_$csin ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 1,
     Strictness: <L,U(U(U(U,U,U),U(U,U),U,U,U,U,U),U(U,U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ a
                   ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                     a) ->
                 let {
                   $dRealFrac :: Data.Array.Accelerate.Classes.RealFrac.RealFrac a
                   = Data.Array.Accelerate.Classes.RealFloat.$p1RealFloat
                       @ a
                       $dRealFloat
                 } in
                 let {
                   $d(%,,%) :: Data.Array.Accelerate.Classes.Real.Real a
                   = Data.Array.Accelerate.Classes.RealFrac.$p1RealFrac @ a $dRealFrac
                 } in
                 let {
                   $d(%,%) :: Data.Array.Accelerate.Classes.Num.Num a
                   = GHC.Classes.$p1(%,,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                       @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,,%)
                 } in
                 let {
                   $dElt :: Data.Array.Accelerate.Array.Sugar.Elt a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,%)
                 } in
                 let {
                   $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.Plain
                                     (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dIsProduct1 :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                     (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ a
                       $dElt
                 } in
                 let {
                   $dElt2 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex @ a $dElt
                 } in
                 let {
                   f :: GHC.Float.RealFloat (Data.Array.Accelerate.Smart.Exp a)
                   = Data.Array.Accelerate.Classes.RealFloat.$fRealFloatExp
                       @ a
                       $dRealFloat
                 } in
                 (\ (eta :: Data.Array.Accelerate.Smart.Exp
                              (Data.Array.Accelerate.Lift.Plain
                                 (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a)))) ->
                  case Data.Complex.$w$csin
                         @ (Data.Array.Accelerate.Smart.Exp a)
                         f
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt2
                            $dIsProduct1
                            $dElt
                            (Data.Array.Accelerate.Data.Complex.$fEqComplex2 @ a)
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            eta
                              `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt2
                            $dIsProduct1
                            $dElt
                            (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            eta
                              `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N) of ww3 { (#,#) ww4 ww5 ->
                  (Data.Array.Accelerate.Smart.Tuple
                     @ Data.Array.Accelerate.Smart.Acc
                     @ Data.Array.Accelerate.Smart.Exp
                     @ (Data.Complex.Complex
                          (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a)))
                     $dElt1
                     $dIsProduct
                     (Data.Array.Accelerate.Array.Sugar.SnocTup
                        @ Data.Array.Accelerate.Smart.Exp
                        @ (((),
                            Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp a)),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ ((),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @~ <(((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a)),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))>_N
                        $dElt
                          `cast`
                        (Data.Array.Accelerate.Array.Sugar.Elt
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                        (Data.Array.Accelerate.Array.Sugar.SnocTup
                           @ Data.Array.Accelerate.Smart.Exp
                           @ ((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ (Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ ()
                           @~ <((),
                                Data.Array.Accelerate.Lift.Plain
                                  (Data.Array.Accelerate.Smart.Exp a))>_N
                           $dElt
                             `cast`
                           (Data.Array.Accelerate.Array.Sugar.Elt
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                           (Data.Array.Accelerate.Array.Sugar.$WNilTup
                              @ Data.Array.Accelerate.Smart.Exp)
                           ww4
                             `cast`
                           (Data.Array.Accelerate.Smart.Exp
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                        ww5
                          `cast`
                        (Data.Array.Accelerate.Smart.Exp
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                       `cast`
                     (Data.Array.Accelerate.Array.Sugar.Tuple
                        <Data.Array.Accelerate.Smart.Exp>_R
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))
                             (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))))_R)
                    `cast`
                  (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                                                        <Data.Array.Accelerate.Smart.Exp
                                                                           a>_N))) })
                   `cast`
                 ((Data.Array.Accelerate.Smart.Exp
                     (Trans
                          (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                               <Data.Array.Accelerate.Smart.Exp a>_N)
                          (Data.Complex.Complex
                             (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R
                  ->_R (Data.Array.Accelerate.Smart.Exp
                          (Trans
                               (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                    <Data.Array.Accelerate.Smart.Exp a>_N)
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)) -}
a99a83036ac482dd0b5ad22eac851fef
  $fFloatingExp_$csinh ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 1,
     Strictness: <L,U(U(U(U,U,U),U(U,U),U,U,U,U,U),U(U,U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ a
                   ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                     a) ->
                 let {
                   $dRealFrac :: Data.Array.Accelerate.Classes.RealFrac.RealFrac a
                   = Data.Array.Accelerate.Classes.RealFloat.$p1RealFloat
                       @ a
                       $dRealFloat
                 } in
                 let {
                   $d(%,,%) :: Data.Array.Accelerate.Classes.Real.Real a
                   = Data.Array.Accelerate.Classes.RealFrac.$p1RealFrac @ a $dRealFrac
                 } in
                 let {
                   $d(%,%) :: Data.Array.Accelerate.Classes.Num.Num a
                   = GHC.Classes.$p1(%,,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                       @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,,%)
                 } in
                 let {
                   $dElt :: Data.Array.Accelerate.Array.Sugar.Elt a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,%)
                 } in
                 let {
                   $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.Plain
                                     (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dIsProduct1 :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                     (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ a
                       $dElt
                 } in
                 let {
                   $dElt2 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex @ a $dElt
                 } in
                 let {
                   f :: GHC.Float.RealFloat (Data.Array.Accelerate.Smart.Exp a)
                   = Data.Array.Accelerate.Classes.RealFloat.$fRealFloatExp
                       @ a
                       $dRealFloat
                 } in
                 (\ (eta :: Data.Array.Accelerate.Smart.Exp
                              (Data.Array.Accelerate.Lift.Plain
                                 (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a)))) ->
                  case Data.Complex.$w$csinh
                         @ (Data.Array.Accelerate.Smart.Exp a)
                         f
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt2
                            $dIsProduct1
                            $dElt
                            (Data.Array.Accelerate.Data.Complex.$fEqComplex2 @ a)
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            eta
                              `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt2
                            $dIsProduct1
                            $dElt
                            (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            eta
                              `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N) of ww3 { (#,#) ww4 ww5 ->
                  (Data.Array.Accelerate.Smart.Tuple
                     @ Data.Array.Accelerate.Smart.Acc
                     @ Data.Array.Accelerate.Smart.Exp
                     @ (Data.Complex.Complex
                          (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a)))
                     $dElt1
                     $dIsProduct
                     (Data.Array.Accelerate.Array.Sugar.SnocTup
                        @ Data.Array.Accelerate.Smart.Exp
                        @ (((),
                            Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp a)),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ ((),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @~ <(((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a)),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))>_N
                        $dElt
                          `cast`
                        (Data.Array.Accelerate.Array.Sugar.Elt
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                        (Data.Array.Accelerate.Array.Sugar.SnocTup
                           @ Data.Array.Accelerate.Smart.Exp
                           @ ((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ (Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ ()
                           @~ <((),
                                Data.Array.Accelerate.Lift.Plain
                                  (Data.Array.Accelerate.Smart.Exp a))>_N
                           $dElt
                             `cast`
                           (Data.Array.Accelerate.Array.Sugar.Elt
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                           (Data.Array.Accelerate.Array.Sugar.$WNilTup
                              @ Data.Array.Accelerate.Smart.Exp)
                           ww4
                             `cast`
                           (Data.Array.Accelerate.Smart.Exp
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                        ww5
                          `cast`
                        (Data.Array.Accelerate.Smart.Exp
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                       `cast`
                     (Data.Array.Accelerate.Array.Sugar.Tuple
                        <Data.Array.Accelerate.Smart.Exp>_R
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))
                             (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))))_R)
                    `cast`
                  (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                                                        <Data.Array.Accelerate.Smart.Exp
                                                                           a>_N))) })
                   `cast`
                 ((Data.Array.Accelerate.Smart.Exp
                     (Trans
                          (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                               <Data.Array.Accelerate.Smart.Exp a>_N)
                          (Data.Complex.Complex
                             (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R
                  ->_R (Data.Array.Accelerate.Smart.Exp
                          (Trans
                               (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                    <Data.Array.Accelerate.Smart.Exp a>_N)
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)) -}
55258ff226e8b021f16f1b662d3ae04e
  $fFloatingExp_$csqrt ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 1,
     Strictness: <L,U(U,U(U,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)> -}
08a760411ebf4e5477905ada8f04cdd8
  $fFloatingExp_$ctan ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 1,
     Strictness: <L,U(U(U(U,U,U),U(U,U),U,U,U,U,U),U(U,U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ a
                   ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                     a) ->
                 let {
                   $dRealFrac :: Data.Array.Accelerate.Classes.RealFrac.RealFrac a
                   = Data.Array.Accelerate.Classes.RealFloat.$p1RealFloat
                       @ a
                       $dRealFloat
                 } in
                 let {
                   $d(%,,%) :: Data.Array.Accelerate.Classes.Real.Real a
                   = Data.Array.Accelerate.Classes.RealFrac.$p1RealFrac @ a $dRealFrac
                 } in
                 let {
                   $d(%,%) :: Data.Array.Accelerate.Classes.Num.Num a
                   = GHC.Classes.$p1(%,,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                       @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,,%)
                 } in
                 let {
                   $dElt :: Data.Array.Accelerate.Array.Sugar.Elt a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,%)
                 } in
                 let {
                   $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.Plain
                                     (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dIsProduct1 :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                     (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ a
                       $dElt
                 } in
                 let {
                   $dElt2 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex @ a $dElt
                 } in
                 let {
                   f :: GHC.Float.RealFloat (Data.Array.Accelerate.Smart.Exp a)
                   = Data.Array.Accelerate.Classes.RealFloat.$fRealFloatExp
                       @ a
                       $dRealFloat
                 } in
                 (\ (eta :: Data.Array.Accelerate.Smart.Exp
                              (Data.Array.Accelerate.Lift.Plain
                                 (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a)))) ->
                  case Data.Complex.$w$ctan
                         @ (Data.Array.Accelerate.Smart.Exp a)
                         f
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt2
                            $dIsProduct1
                            $dElt
                            (Data.Array.Accelerate.Data.Complex.$fEqComplex2 @ a)
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            eta
                              `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt2
                            $dIsProduct1
                            $dElt
                            (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            eta
                              `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N) of ww3 { (#,#) ww4 ww5 ->
                  (Data.Array.Accelerate.Smart.Tuple
                     @ Data.Array.Accelerate.Smart.Acc
                     @ Data.Array.Accelerate.Smart.Exp
                     @ (Data.Complex.Complex
                          (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a)))
                     $dElt1
                     $dIsProduct
                     (Data.Array.Accelerate.Array.Sugar.SnocTup
                        @ Data.Array.Accelerate.Smart.Exp
                        @ (((),
                            Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp a)),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ ((),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @~ <(((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a)),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))>_N
                        $dElt
                          `cast`
                        (Data.Array.Accelerate.Array.Sugar.Elt
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                        (Data.Array.Accelerate.Array.Sugar.SnocTup
                           @ Data.Array.Accelerate.Smart.Exp
                           @ ((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ (Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ ()
                           @~ <((),
                                Data.Array.Accelerate.Lift.Plain
                                  (Data.Array.Accelerate.Smart.Exp a))>_N
                           $dElt
                             `cast`
                           (Data.Array.Accelerate.Array.Sugar.Elt
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                           (Data.Array.Accelerate.Array.Sugar.$WNilTup
                              @ Data.Array.Accelerate.Smart.Exp)
                           ww4
                             `cast`
                           (Data.Array.Accelerate.Smart.Exp
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                        ww5
                          `cast`
                        (Data.Array.Accelerate.Smart.Exp
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                       `cast`
                     (Data.Array.Accelerate.Array.Sugar.Tuple
                        <Data.Array.Accelerate.Smart.Exp>_R
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))
                             (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))))_R)
                    `cast`
                  (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                                                        <Data.Array.Accelerate.Smart.Exp
                                                                           a>_N))) })
                   `cast`
                 ((Data.Array.Accelerate.Smart.Exp
                     (Trans
                          (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                               <Data.Array.Accelerate.Smart.Exp a>_N)
                          (Data.Complex.Complex
                             (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R
                  ->_R (Data.Array.Accelerate.Smart.Exp
                          (Trans
                               (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                    <Data.Array.Accelerate.Smart.Exp a>_N)
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)) -}
39391581ea956648ef27db5e3b0e00cb
  $fFloatingExp_$ctanh ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 1,
     Strictness: <L,U(U(U(U,U,U),U(U,U),U,U,U,U,U),U(U,U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ a
                   ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                     a) ->
                 let {
                   $dRealFrac :: Data.Array.Accelerate.Classes.RealFrac.RealFrac a
                   = Data.Array.Accelerate.Classes.RealFloat.$p1RealFloat
                       @ a
                       $dRealFloat
                 } in
                 let {
                   $d(%,,%) :: Data.Array.Accelerate.Classes.Real.Real a
                   = Data.Array.Accelerate.Classes.RealFrac.$p1RealFrac @ a $dRealFrac
                 } in
                 let {
                   $d(%,%) :: Data.Array.Accelerate.Classes.Num.Num a
                   = GHC.Classes.$p1(%,,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                       @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,,%)
                 } in
                 let {
                   $dElt :: Data.Array.Accelerate.Array.Sugar.Elt a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,%)
                 } in
                 let {
                   $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.Plain
                                     (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dIsProduct1 :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                     (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ a
                       $dElt
                 } in
                 let {
                   $dElt2 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex @ a $dElt
                 } in
                 let {
                   f :: GHC.Float.RealFloat (Data.Array.Accelerate.Smart.Exp a)
                   = Data.Array.Accelerate.Classes.RealFloat.$fRealFloatExp
                       @ a
                       $dRealFloat
                 } in
                 (\ (eta :: Data.Array.Accelerate.Smart.Exp
                              (Data.Array.Accelerate.Lift.Plain
                                 (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a)))) ->
                  case Data.Complex.$w$ctanh
                         @ (Data.Array.Accelerate.Smart.Exp a)
                         f
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt2
                            $dIsProduct1
                            $dElt
                            (Data.Array.Accelerate.Data.Complex.$fEqComplex2 @ a)
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            eta
                              `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt2
                            $dIsProduct1
                            $dElt
                            (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            eta
                              `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N) of ww3 { (#,#) ww4 ww5 ->
                  (Data.Array.Accelerate.Smart.Tuple
                     @ Data.Array.Accelerate.Smart.Acc
                     @ Data.Array.Accelerate.Smart.Exp
                     @ (Data.Complex.Complex
                          (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a)))
                     $dElt1
                     $dIsProduct
                     (Data.Array.Accelerate.Array.Sugar.SnocTup
                        @ Data.Array.Accelerate.Smart.Exp
                        @ (((),
                            Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp a)),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ ((),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @~ <(((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a)),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))>_N
                        $dElt
                          `cast`
                        (Data.Array.Accelerate.Array.Sugar.Elt
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                        (Data.Array.Accelerate.Array.Sugar.SnocTup
                           @ Data.Array.Accelerate.Smart.Exp
                           @ ((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ (Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ ()
                           @~ <((),
                                Data.Array.Accelerate.Lift.Plain
                                  (Data.Array.Accelerate.Smart.Exp a))>_N
                           $dElt
                             `cast`
                           (Data.Array.Accelerate.Array.Sugar.Elt
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                           (Data.Array.Accelerate.Array.Sugar.$WNilTup
                              @ Data.Array.Accelerate.Smart.Exp)
                           ww4
                             `cast`
                           (Data.Array.Accelerate.Smart.Exp
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                        ww5
                          `cast`
                        (Data.Array.Accelerate.Smart.Exp
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                       `cast`
                     (Data.Array.Accelerate.Array.Sugar.Tuple
                        <Data.Array.Accelerate.Smart.Exp>_R
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))
                             (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))))_R)
                    `cast`
                  (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                                                        <Data.Array.Accelerate.Smart.Exp
                                                                           a>_N))) })
                   `cast`
                 ((Data.Array.Accelerate.Smart.Exp
                     (Trans
                          (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                               <Data.Array.Accelerate.Smart.Exp a>_N)
                          (Data.Complex.Complex
                             (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R
                  ->_R (Data.Array.Accelerate.Smart.Exp
                          (Trans
                               (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                    <Data.Array.Accelerate.Smart.Exp a>_N)
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)) -}
4e86bfd190593d7df8df9b0134555475
  $fFractionalExp ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    GHC.Real.Fractional
      (Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a))
  DFunId
  {- Arity: 1,
     Strictness: <L,U(U(U(U,U,U(U(U,U,U,U,U,U,U),U,U)),U(U,U),U,U,U,U,U),U(U,U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                        a).
                  @ (Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a))
                  (Data.Array.Accelerate.Data.Complex.$fNumExp @ a $dRealFloat)
                  (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$c/
                     @ a
                     $dRealFloat)
                  (Data.Array.Accelerate.Data.Complex.$fFractionalExp_$crecip
                     @ a
                     $dRealFloat)
                  (Data.Array.Accelerate.Data.Complex.$fFractionalExp_$cfromRational
                     @ a
                     $dRealFloat) -}
0efc28cf522441f9e1151f17a528b1c4
  $fFractionalExp_$cfromRational ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    GHC.Real.Rational
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 1,
     Strictness: <L,1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ a
                   ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                     a) ->
                 let {
                   $dRealFrac :: Data.Array.Accelerate.Classes.RealFrac.RealFrac a
                   = Data.Array.Accelerate.Classes.RealFloat.$p1RealFloat
                       @ a
                       $dRealFloat
                 } in
                 let {
                   $d(%,,%) :: Data.Array.Accelerate.Classes.Real.Real a
                   = Data.Array.Accelerate.Classes.RealFrac.$p1RealFrac @ a $dRealFrac
                 } in
                 let {
                   $d(%,%) :: Data.Array.Accelerate.Classes.Num.Num a
                   = GHC.Classes.$p1(%,,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                       @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,,%)
                 } in
                 let {
                   $dElt :: Data.Array.Accelerate.Array.Sugar.Elt a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,%)
                 } in
                 let {
                   $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.Plain
                                     (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   lvl13 :: Data.Array.Accelerate.Smart.Exp a
                   = GHC.Num.fromInteger
                       @ (Data.Array.Accelerate.Smart.Exp a)
                       (GHC.Classes.$p2(%,%)
                          @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                          @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                          $d(%,%))
                       Data.Array.Accelerate.Data.Complex.$fFloatingExp1
                 } in
                 let {
                   $dFractional :: Data.Array.Accelerate.Classes.Fractional.Fractional
                                     a
                   = Data.Array.Accelerate.Classes.RealFrac.$p2RealFrac @ a $dRealFrac
                 } in
                 let {
                   $dFractional1 :: GHC.Real.Fractional
                                      (Data.Array.Accelerate.Smart.Exp a)
                   = GHC.Classes.$p2(%,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (GHC.Real.Fractional (Data.Array.Accelerate.Smart.Exp a))
                       $dFractional
                 } in
                 (\ (x :: GHC.Real.Rational) ->
                  case (GHC.Real.fromRational
                          @ (Data.Array.Accelerate.Smart.Exp a)
                          $dFractional1
                          x)
                         `cast`
                       (Data.Array.Accelerate.Smart.N:Exp[0] <a>_N) of nt { DEFAULT ->
                  case lvl13
                         `cast`
                       (Data.Array.Accelerate.Smart.N:Exp[0] <a>_N) of nt1 { DEFAULT ->
                  (Data.Array.Accelerate.Smart.Tuple
                     @ Data.Array.Accelerate.Smart.Acc
                     @ Data.Array.Accelerate.Smart.Exp
                     @ (Data.Complex.Complex
                          (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a)))
                     $dElt1
                     $dIsProduct
                     (Data.Array.Accelerate.Array.Sugar.SnocTup
                        @ Data.Array.Accelerate.Smart.Exp
                        @ (((),
                            Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp a)),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ ((),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @~ <(((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a)),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))>_N
                        $dElt
                          `cast`
                        (Data.Array.Accelerate.Array.Sugar.Elt
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                        (Data.Array.Accelerate.Array.Sugar.SnocTup
                           @ Data.Array.Accelerate.Smart.Exp
                           @ ((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ (Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ ()
                           @~ <((),
                                Data.Array.Accelerate.Lift.Plain
                                  (Data.Array.Accelerate.Smart.Exp a))>_N
                           $dElt
                             `cast`
                           (Data.Array.Accelerate.Array.Sugar.Elt
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                           (Data.Array.Accelerate.Array.Sugar.$WNilTup
                              @ Data.Array.Accelerate.Smart.Exp)
                           nt
                             `cast`
                           (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0]
                                                                                 <a>_N))))
                        nt1
                          `cast`
                        (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0]
                                                                              <a>_N))))
                       `cast`
                     (Data.Array.Accelerate.Array.Sugar.Tuple
                        <Data.Array.Accelerate.Smart.Exp>_R
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))
                             (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))))_R)
                    `cast`
                  (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                                                        <Data.Array.Accelerate.Smart.Exp
                                                                           a>_N))) } })
                   `cast`
                 (<GHC.Real.Rational>_R
                  ->_R (Data.Array.Accelerate.Smart.Exp
                          (Trans
                               (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                    <Data.Array.Accelerate.Smart.Exp a>_N)
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)) -}
9bc5406fad9c4502109de1bb17d6518b
  $fFractionalExp_$crecip ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 2,
     Strictness: <L,U(U(U(U,U,U(U(U,U,U,U,U,U,U),U,U)),U(U,U),U,U,U,U,U),U(U,U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                     a)
                   (eta :: Data.Array.Accelerate.Smart.Exp
                             (Data.Complex.Complex a)) ->
                 Data.Array.Accelerate.Data.Complex.$fFloatingExp_$c/
                   @ a
                   $dRealFloat
                   (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$cfromInteger
                      @ a
                      $dRealFloat
                      1)
                   eta) -}
7c699574c4d3f1322b395e253933ba5e
  $fFromIntegralaComplex ::
    (Data.Array.Accelerate.Classes.FromIntegral.FromIntegral a b,
     Data.Array.Accelerate.Classes.Num.Num b) =>
    Data.Array.Accelerate.Classes.FromIntegral.FromIntegral
      a (Data.Complex.Complex b)
  DFunId
  {- Arity: 3,
     Strictness: <L,C(C1(U))><L,U(1*U,1*U(A,A,A,A,A,A,1*C1(U)))><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (2, False, True)
                Data.Array.Accelerate.Data.Complex.$fFromIntegralaComplex_$cfromIntegral
                  `cast`
                (forall (a :: <GHC.Types.*>_N) (b :: <GHC.Types.*>_N).
                 <Data.Array.Accelerate.Classes.FromIntegral.FromIntegral a b>_R
                 ->_R <Data.Array.Accelerate.Classes.Num.Num b>_R
                 ->_R Sym (Data.Array.Accelerate.Classes.FromIntegral.N:FromIntegral[0]
                               <a>_N <Data.Complex.Complex b>_N)) -}
c222411565a33a937426773d44fc40f2
  $fFromIntegralaComplex_$cfromIntegral ::
    (Data.Array.Accelerate.Classes.FromIntegral.FromIntegral a b,
     Data.Array.Accelerate.Classes.Num.Num b,
     Data.Array.Accelerate.Classes.Integral.Integral a) =>
    Data.Array.Accelerate.Smart.Exp a
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex b)
  {- Arity: 3,
     Strictness: <L,C(C1(U))><L,U(1*U,1*U(A,A,A,A,A,A,1*C1(U)))><L,U>,
     Unfolding: (\ @ a
                   @ b
                   ($dFromIntegral :: Data.Array.Accelerate.Classes.FromIntegral.FromIntegral
                                        a b)
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num b)
                   (eta :: Data.Array.Accelerate.Classes.Integral.Integral a) ->
                 let {
                   $dElt :: Data.Array.Accelerate.Array.Sugar.Elt b
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt b)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp b))
                       $d(%,%)
                 } in
                 let {
                   $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp b)))
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp b))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <b>_N)))_R
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.Plain
                                     (Data.Array.Accelerate.Smart.Exp b)))
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp b))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <b>_N)))_R
                 } in
                 let {
                   lvl13 :: Data.Array.Accelerate.Smart.Exp b
                   = GHC.Num.fromInteger
                       @ (Data.Array.Accelerate.Smart.Exp b)
                       (GHC.Classes.$p2(%,%)
                          @ (Data.Array.Accelerate.Array.Sugar.Elt b)
                          @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp b))
                          $d(%,%))
                       Data.Array.Accelerate.Data.Complex.$fFloatingExp1
                 } in
                 (\ (x :: Data.Array.Accelerate.Smart.Exp a) ->
                  case ($dFromIntegral
                          `cast`
                        (Data.Array.Accelerate.Classes.FromIntegral.N:FromIntegral[0]
                             <a>_N <b>_N)
                          eta
                          x)
                         `cast`
                       (Data.Array.Accelerate.Smart.N:Exp[0] <b>_N) of nt { DEFAULT ->
                  case lvl13
                         `cast`
                       (Data.Array.Accelerate.Smart.N:Exp[0] <b>_N) of nt1 { DEFAULT ->
                  (Data.Array.Accelerate.Smart.Tuple
                     @ Data.Array.Accelerate.Smart.Acc
                     @ Data.Array.Accelerate.Smart.Exp
                     @ (Data.Complex.Complex
                          (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp b)))
                     $dElt1
                     $dIsProduct
                     (Data.Array.Accelerate.Array.Sugar.SnocTup
                        @ Data.Array.Accelerate.Smart.Exp
                        @ (((),
                            Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp b)),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp b))
                        @ (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp b))
                        @ ((),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp b))
                        @~ <(((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp b)),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp b))>_N
                        $dElt
                          `cast`
                        (Data.Array.Accelerate.Array.Sugar.Elt
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <b>_N)))_R
                        (Data.Array.Accelerate.Array.Sugar.SnocTup
                           @ Data.Array.Accelerate.Smart.Exp
                           @ ((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp b))
                           @ (Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp b))
                           @ ()
                           @~ <((),
                                Data.Array.Accelerate.Lift.Plain
                                  (Data.Array.Accelerate.Smart.Exp b))>_N
                           $dElt
                             `cast`
                           (Data.Array.Accelerate.Array.Sugar.Elt
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <b>_N)))_R
                           (Data.Array.Accelerate.Array.Sugar.$WNilTup
                              @ Data.Array.Accelerate.Smart.Exp)
                           nt
                             `cast`
                           (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0]
                                                                                 <b>_N))))
                        nt1
                          `cast`
                        (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0]
                                                                              <b>_N))))
                       `cast`
                     (Data.Array.Accelerate.Array.Sugar.Tuple
                        <Data.Array.Accelerate.Smart.Exp>_R
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp b)>_N
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp b)>_N))
                             (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp b)>_N))))_R)
                    `cast`
                  (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                                                        <Data.Array.Accelerate.Smart.Exp
                                                                           b>_N))) } })
                   `cast`
                 (<Data.Array.Accelerate.Smart.Exp a>_R
                  ->_R (Data.Array.Accelerate.Smart.Exp
                          (Trans
                               (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                    <Data.Array.Accelerate.Smart.Exp b>_N)
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <b>_N))_N))_R)) -}
a3dfd77b8013cf335a9a4e8c48df7304
  $fIsProductcstComplex ::
    cst a =>
    Data.Array.Accelerate.Product.IsProduct
      cst (Data.Complex.Complex a)
  DFunId
  {- Arity: 1, Strictness: <L,U>m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ (cst :: * -> GHC.Types.Constraint)
                      @ a
                      (irred :: cst a).
                  @ cst
                  @ (Data.Complex.Complex a)
                  (Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex_$cfromProd
                     @ cst
                     @ a
                     irred)
                  (Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex_$ctoProd
                     @ cst
                     @ a
                     irred)
                  (Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex_$cprod
                     @ cst
                     @ a
                     irred) -}
52d37c8a98add59577967cfde4921da1
  $fIsProductcstComplex1 ::
    cst a =>
    forall (proxy :: (* -> GHC.Types.Constraint) -> *).
    proxy cst
    -> Data.Complex.Complex a
    -> Data.Array.Accelerate.Product.ProdR cst (((), a), a)
  {- Arity: 3, Strictness: <L,U><L,A><L,A>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (cst :: * -> GHC.Types.Constraint)
                   @ a
                   (irred :: cst a)
                   @ (proxy :: (* -> GHC.Types.Constraint) -> *)
                   (cst1 :: proxy cst)
                   (ds :: Data.Complex.Complex a) ->
                 Data.Array.Accelerate.Product.$fIsProductcst(,)1
                   @ cst
                   @ a
                   @ a
                   irred
                   irred
                   @ proxy
                   cst1
                   (Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex2 @ a)) -}
1f886dd94b56ce33fb67eea0eb52d921
  $fIsProductcstComplex2 :: (a, a)
  {- Strictness: x -}
59e4f440d2728c8df11749789cfbd247
  $fIsProductcstComplex_$cfromProd ::
    cst a =>
    forall (proxy :: (* -> GHC.Types.Constraint) -> *).
    proxy cst
    -> Data.Complex.Complex a
    -> Data.Array.Accelerate.Product.ProdRepr (Data.Complex.Complex a)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><S(SS),1*U(U,U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ @ (cst :: * -> GHC.Types.Constraint)
                   @ a
                   (irred :: cst a)
                   @ (proxy :: (* -> GHC.Types.Constraint) -> *)
                   (cst1 :: proxy cst)
                   (ds :: Data.Complex.Complex a) ->
                 case ds of wild { Data.Complex.:+ x y ->
                 ((GHC.Tuple.(), x), y)
                   `cast`
                 (Trans
                      (Sub (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                     <a>_N <a>_N)))
                      (Sub (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                     <a>_N)))) }) -}
dab22ff7fc7d3d3777cf5d1110b0c2d2
  $fIsProductcstComplex_$cprod ::
    cst a =>
    forall (proxy :: (* -> GHC.Types.Constraint) -> *).
    proxy cst
    -> Data.Complex.Complex a
    -> Data.Array.Accelerate.Product.ProdR
         cst
         (Data.Array.Accelerate.Product.ProdRepr (Data.Complex.Complex a))
  {- Arity: 3, Strictness: <L,U><L,A><L,A>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex1
                  `cast`
                (forall (cst :: <* -> GHC.Types.Constraint>_N) (a :: <*>_N).
                 <cst a>_R
                 ->_R forall (proxy :: <(* -> GHC.Types.Constraint) -> *>_N).
                      <proxy cst>_R
                      ->_R <Data.Complex.Complex a>_R
                      ->_R (Data.Array.Accelerate.Product.ProdR
                              <cst>_R
                              (Trans
                                   (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                             <a>_N <a>_N))
                                   (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                             <a>_N))))_R) -}
315138c14cfc599c52f390d48e22e2c1
  $fIsProductcstComplex_$ctoProd ::
    cst a =>
    forall (proxy :: (* -> GHC.Types.Constraint) -> *).
    proxy cst
    -> Data.Array.Accelerate.Product.ProdRepr (Data.Complex.Complex a)
    -> Data.Complex.Complex a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,A><L,A><S(S(SS)S),1*U(1*U(1*H,1*U),1*U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ @ (cst :: * -> GHC.Types.Constraint)
                   @ a
                   (irred :: cst a)
                   @ (proxy :: (* -> GHC.Types.Constraint) -> *)
                   (cst1 :: proxy cst)
                   (p :: Data.Array.Accelerate.Product.ProdRepr
                           (Data.Complex.Complex a)) ->
                 case p `cast`
                      (Trans
                           (Sub (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                     <a>_N))
                           (Sub (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                     <a>_N <a>_N))) of wild { (,) ds2 b1 ->
                 case ds2 of wild1 { (,) ds3 a1 ->
                 case ds3 of wild2 { () ->
                 case a1 of dt { DEFAULT ->
                 case b1 of dt1 { DEFAULT ->
                 Data.Complex.:+ @ a dt dt1 } } } } }) -}
fc0927672d3848bafbb0e9d723e8e955
  $fLiftExpComplex ::
    (Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp a,
     Data.Array.Accelerate.Array.Sugar.Elt
       (Data.Array.Accelerate.Lift.Plain a)) =>
    Data.Array.Accelerate.Lift.Lift
      Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  DFunId
  {- Arity: 2, Strictness: <L,C(U)><L,U(U(U,U,U),U,U,U,U,U,U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (2, False, True)
                Data.Array.Accelerate.Data.Complex.$fLiftExpComplex_$clift
                  `cast`
                (forall (a :: <*>_N).
                 <Data.Array.Accelerate.Lift.Lift
                    Data.Array.Accelerate.Smart.Exp a>_R
                 ->_R <Data.Array.Accelerate.Array.Sugar.Elt
                         (Data.Array.Accelerate.Lift.Plain a)>_R
                 ->_R Sym (Data.Array.Accelerate.Lift.N:Lift[0]
                               <Data.Array.Accelerate.Smart.Exp>_N <Data.Complex.Complex a>_N)) -}
ebce13f00f68526d73d4e8a3a5eef03f
  $fLiftExpComplex_$clift ::
    (Data.Array.Accelerate.Lift.Lift Data.Array.Accelerate.Smart.Exp a,
     Data.Array.Accelerate.Array.Sugar.Elt
       (Data.Array.Accelerate.Lift.Plain a)) =>
    Data.Complex.Complex a
    -> Data.Array.Accelerate.Smart.Exp
         (Data.Array.Accelerate.Lift.Plain (Data.Complex.Complex a))
  {- Arity: 2, Strictness: <L,C(U)><L,U(U(U,U,U),U,U,U,U,U,U)>,
     Unfolding: (\ @ a
                   ($dLift :: Data.Array.Accelerate.Lift.Lift
                                Data.Array.Accelerate.Smart.Exp a)
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Array.Accelerate.Lift.Plain a)) ->
                 let {
                   $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                    (Data.Complex.Complex (Data.Array.Accelerate.Lift.Plain a))
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ (Data.Array.Accelerate.Lift.Plain a)
                       $dElt
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex (Data.Array.Accelerate.Lift.Plain a))
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex
                       @ (Data.Array.Accelerate.Lift.Plain a)
                       $dElt
                 } in
                 \ (ds :: Data.Complex.Complex a) ->
                 case ds of wild { Data.Complex.:+ x1 x2 ->
                 (Data.Array.Accelerate.Smart.Tuple
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ (Data.Complex.Complex (Data.Array.Accelerate.Lift.Plain a))
                    $dElt1
                    $dIsProduct
                    (Data.Array.Accelerate.Array.Sugar.SnocTup
                       @ Data.Array.Accelerate.Smart.Exp
                       @ (((), Data.Array.Accelerate.Lift.Plain a),
                          Data.Array.Accelerate.Lift.Plain a)
                       @ (Data.Array.Accelerate.Lift.Plain a)
                       @ ((), Data.Array.Accelerate.Lift.Plain a)
                       @~ <(((), Data.Array.Accelerate.Lift.Plain a),
                            Data.Array.Accelerate.Lift.Plain a)>_N
                       $dElt
                       (Data.Array.Accelerate.Array.Sugar.SnocTup
                          @ Data.Array.Accelerate.Smart.Exp
                          @ ((), Data.Array.Accelerate.Lift.Plain a)
                          @ (Data.Array.Accelerate.Lift.Plain a)
                          @ ()
                          @~ <((), Data.Array.Accelerate.Lift.Plain a)>_N
                          $dElt
                          (Data.Array.Accelerate.Array.Sugar.$WNilTup
                             @ Data.Array.Accelerate.Smart.Exp)
                          ($dLift
                             `cast`
                           (Data.Array.Accelerate.Lift.N:Lift[0]
                                <Data.Array.Accelerate.Smart.Exp>_N <a>_N)
                             x1))
                       ($dLift
                          `cast`
                        (Data.Array.Accelerate.Lift.N:Lift[0]
                             <Data.Array.Accelerate.Smart.Exp>_N <a>_N)
                          x2))
                      `cast`
                    (Data.Array.Accelerate.Array.Sugar.Tuple
                       <Data.Array.Accelerate.Smart.Exp>_R
                       (Trans
                            (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                      <Data.Array.Accelerate.Lift.Plain a>_N
                                      <Data.Array.Accelerate.Lift.Plain a>_N))
                            (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                      <Data.Array.Accelerate.Lift.Plain a>_N))))_R)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                                                       <a>_N))) }) -}
e55716295906dedd32c4c553e2e21f0f
  $fNumExp ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    GHC.Num.Num
      (Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a))
  DFunId
  {- Arity: 1,
     Strictness: <L,U(U(U(U,U,U(U(U,U,U,U,U,U,U),U,U)),U(U,U),U,U,U,U,U),U(U,U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                        a).
                  @ (Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a))
                  (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$c+
                     @ a
                     $dRealFloat)
                  (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$c-
                     @ a
                     $dRealFloat)
                  (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$c*
                     @ a
                     $dRealFloat)
                  (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$cnegate
                     @ a
                     $dRealFloat)
                  (Data.Array.Accelerate.Data.Complex.$fNumExp_$cabs @ a $dRealFloat)
                  (Data.Array.Accelerate.Data.Complex.$fNumExp_$csignum
                     @ a
                     $dRealFloat)
                  (Data.Array.Accelerate.Data.Complex.$fFloatingExp_$cfromInteger
                     @ a
                     $dRealFloat) -}
578b36d0f90f293966dfd8a60abc60be
  $fNumExp_$cabs ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 1,
     Strictness: <L,U(U(U(U,U,U(U(U,U,U,U,U,U,U),U,U)),U(U,U),U,U,U,U,U),U(U,U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ a
                   ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                     a) ->
                 let {
                   $dRealFrac :: Data.Array.Accelerate.Classes.RealFrac.RealFrac a
                   = Data.Array.Accelerate.Classes.RealFloat.$p1RealFloat
                       @ a
                       $dRealFloat
                 } in
                 let {
                   $d(%,,%) :: Data.Array.Accelerate.Classes.Real.Real a
                   = Data.Array.Accelerate.Classes.RealFrac.$p1RealFrac @ a $dRealFrac
                 } in
                 let {
                   $d(%,%) :: Data.Array.Accelerate.Classes.Num.Num a
                   = GHC.Classes.$p1(%,,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                       @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,,%)
                 } in
                 let {
                   $dElt :: Data.Array.Accelerate.Array.Sugar.Elt a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,%)
                 } in
                 let {
                   $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.Plain
                                     (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dIsProduct1 :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                     (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ a
                       $dElt
                 } in
                 let {
                   $dElt2 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex @ a $dElt
                 } in
                 let {
                   f :: GHC.Float.RealFloat (Data.Array.Accelerate.Smart.Exp a)
                   = Data.Array.Accelerate.Classes.RealFloat.$fRealFloatExp
                       @ a
                       $dRealFloat
                 } in
                 let {
                   lvl13 :: Data.Array.Accelerate.Smart.Exp a
                   = GHC.Num.fromInteger
                       @ (Data.Array.Accelerate.Smart.Exp a)
                       (GHC.Real.$p1Real
                          @ (Data.Array.Accelerate.Smart.Exp a)
                          (GHC.Classes.$p3(%,,%)
                             @ (Data.Array.Accelerate.Classes.Num.Num a)
                             @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                             @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                             (Data.Array.Accelerate.Classes.RealFrac.$p1RealFrac
                                @ a
                                (Data.Array.Accelerate.Classes.RealFloat.$p1RealFloat
                                   @ a
                                   $dRealFloat))))
                       Data.Complex.$fFloatingComplex13
                 } in
                 (\ (eta :: Data.Array.Accelerate.Smart.Exp
                              (Data.Array.Accelerate.Lift.Plain
                                 (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a)))) ->
                  case (Data.Complex.$wmagnitude
                          @ (Data.Array.Accelerate.Smart.Exp a)
                          f
                          (Data.Array.Accelerate.Smart.Prj
                             @ Data.Array.Accelerate.Smart.Acc
                             @ Data.Array.Accelerate.Smart.Exp
                             @ a
                             @ (Data.Complex.Complex a)
                             $dElt2
                             $dIsProduct1
                             $dElt
                             (Data.Array.Accelerate.Data.Complex.$fEqComplex2 @ a)
                               `cast`
                             (Data.Array.Accelerate.Product.TupleIdx
                                (Trans
                                     (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                               <a>_N <a>_N))
                                     (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                               <a>_N)))
                                <a>_N)_R
                             eta
                               `cast`
                             (Data.Array.Accelerate.Smart.Exp
                                (Trans
                                     (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                          <Data.Array.Accelerate.Smart.Exp a>_N)
                                     (Data.Complex.Complex
                                        (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                            `cast`
                          (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                          (Data.Array.Accelerate.Smart.Prj
                             @ Data.Array.Accelerate.Smart.Acc
                             @ Data.Array.Accelerate.Smart.Exp
                             @ a
                             @ (Data.Complex.Complex a)
                             $dElt2
                             $dIsProduct1
                             $dElt
                             (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                               `cast`
                             (Data.Array.Accelerate.Product.TupleIdx
                                (Trans
                                     (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                               <a>_N <a>_N))
                                     (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                               <a>_N)))
                                <a>_N)_R
                             eta
                               `cast`
                             (Data.Array.Accelerate.Smart.Exp
                                (Trans
                                     (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                          <Data.Array.Accelerate.Smart.Exp a>_N)
                                     (Data.Complex.Complex
                                        (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                            `cast`
                          (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N))
                         `cast`
                       (Data.Array.Accelerate.Smart.N:Exp[0] <a>_N) of nt { DEFAULT ->
                  case lvl13
                         `cast`
                       (Data.Array.Accelerate.Smart.N:Exp[0] <a>_N) of nt1 { DEFAULT ->
                  (Data.Array.Accelerate.Smart.Tuple
                     @ Data.Array.Accelerate.Smart.Acc
                     @ Data.Array.Accelerate.Smart.Exp
                     @ (Data.Complex.Complex
                          (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a)))
                     $dElt1
                     $dIsProduct
                     (Data.Array.Accelerate.Array.Sugar.SnocTup
                        @ Data.Array.Accelerate.Smart.Exp
                        @ (((),
                            Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp a)),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ ((),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @~ <(((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a)),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))>_N
                        $dElt
                          `cast`
                        (Data.Array.Accelerate.Array.Sugar.Elt
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                        (Data.Array.Accelerate.Array.Sugar.SnocTup
                           @ Data.Array.Accelerate.Smart.Exp
                           @ ((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ (Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ ()
                           @~ <((),
                                Data.Array.Accelerate.Lift.Plain
                                  (Data.Array.Accelerate.Smart.Exp a))>_N
                           $dElt
                             `cast`
                           (Data.Array.Accelerate.Array.Sugar.Elt
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                           (Data.Array.Accelerate.Array.Sugar.$WNilTup
                              @ Data.Array.Accelerate.Smart.Exp)
                           nt
                             `cast`
                           (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0]
                                                                                 <a>_N))))
                        nt1
                          `cast`
                        (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0]
                                                                              <a>_N))))
                       `cast`
                     (Data.Array.Accelerate.Array.Sugar.Tuple
                        <Data.Array.Accelerate.Smart.Exp>_R
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))
                             (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))))_R)
                    `cast`
                  (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                                                        <Data.Array.Accelerate.Smart.Exp
                                                                           a>_N))) } })
                   `cast`
                 ((Data.Array.Accelerate.Smart.Exp
                     (Trans
                          (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                               <Data.Array.Accelerate.Smart.Exp a>_N)
                          (Data.Complex.Complex
                             (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R
                  ->_R (Data.Array.Accelerate.Smart.Exp
                          (Trans
                               (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                    <Data.Array.Accelerate.Smart.Exp a>_N)
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)) -}
26f0b12a66585dfaae2c4dad77f9c815
  $fNumExp_$csignum ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 1,
     Strictness: <L,U(U(U(U,U,U),U(U,U),U,U,U,U,U),U(U,U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ a
                   ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                     a) ->
                 let {
                   $dRealFrac :: Data.Array.Accelerate.Classes.RealFrac.RealFrac a
                   = Data.Array.Accelerate.Classes.RealFloat.$p1RealFloat
                       @ a
                       $dRealFloat
                 } in
                 let {
                   $d(%,,%) :: Data.Array.Accelerate.Classes.Real.Real a
                   = Data.Array.Accelerate.Classes.RealFrac.$p1RealFrac @ a $dRealFrac
                 } in
                 let {
                   $d(%,%) :: Data.Array.Accelerate.Classes.Num.Num a
                   = GHC.Classes.$p1(%,,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                       @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,,%)
                 } in
                 let {
                   $dElt :: Data.Array.Accelerate.Array.Sugar.Elt a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,%)
                 } in
                 let {
                   $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.Plain
                                     (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dIsProduct1 :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                     (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ a
                       $dElt
                 } in
                 let {
                   $dElt2 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex @ a $dElt
                 } in
                 let {
                   f :: GHC.Float.RealFloat (Data.Array.Accelerate.Smart.Exp a)
                   = Data.Array.Accelerate.Classes.RealFloat.$fRealFloatExp
                       @ a
                       $dRealFloat
                 } in
                 (\ (eta :: Data.Array.Accelerate.Smart.Exp
                              (Data.Array.Accelerate.Lift.Plain
                                 (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a)))) ->
                  case Data.Complex.$w$csignum
                         @ (Data.Array.Accelerate.Smart.Exp a)
                         f
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt2
                            $dIsProduct1
                            $dElt
                            (Data.Array.Accelerate.Data.Complex.$fEqComplex2 @ a)
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            eta
                              `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                         (Data.Array.Accelerate.Smart.Prj
                            @ Data.Array.Accelerate.Smart.Acc
                            @ Data.Array.Accelerate.Smart.Exp
                            @ a
                            @ (Data.Complex.Complex a)
                            $dElt2
                            $dIsProduct1
                            $dElt
                            (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                              `cast`
                            (Data.Array.Accelerate.Product.TupleIdx
                               (Trans
                                    (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                              <a>_N <a>_N))
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                              <a>_N)))
                               <a>_N)_R
                            eta
                              `cast`
                            (Data.Array.Accelerate.Smart.Exp
                               (Trans
                                    (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                         <Data.Array.Accelerate.Smart.Exp a>_N)
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                           `cast`
                         (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N) of ww3 { (#,#) ww4 ww5 ->
                  (Data.Array.Accelerate.Smart.Tuple
                     @ Data.Array.Accelerate.Smart.Acc
                     @ Data.Array.Accelerate.Smart.Exp
                     @ (Data.Complex.Complex
                          (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a)))
                     $dElt1
                     $dIsProduct
                     (Data.Array.Accelerate.Array.Sugar.SnocTup
                        @ Data.Array.Accelerate.Smart.Exp
                        @ (((),
                            Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp a)),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ ((),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @~ <(((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a)),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))>_N
                        $dElt
                          `cast`
                        (Data.Array.Accelerate.Array.Sugar.Elt
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                        (Data.Array.Accelerate.Array.Sugar.SnocTup
                           @ Data.Array.Accelerate.Smart.Exp
                           @ ((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ (Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ ()
                           @~ <((),
                                Data.Array.Accelerate.Lift.Plain
                                  (Data.Array.Accelerate.Smart.Exp a))>_N
                           $dElt
                             `cast`
                           (Data.Array.Accelerate.Array.Sugar.Elt
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                           (Data.Array.Accelerate.Array.Sugar.$WNilTup
                              @ Data.Array.Accelerate.Smart.Exp)
                           ww4
                             `cast`
                           (Data.Array.Accelerate.Smart.Exp
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                        ww5
                          `cast`
                        (Data.Array.Accelerate.Smart.Exp
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                       `cast`
                     (Data.Array.Accelerate.Array.Sugar.Tuple
                        <Data.Array.Accelerate.Smart.Exp>_R
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))
                             (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))))_R)
                    `cast`
                  (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                                                        <Data.Array.Accelerate.Smart.Exp
                                                                           a>_N))) })
                   `cast`
                 ((Data.Array.Accelerate.Smart.Exp
                     (Trans
                          (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                               <Data.Array.Accelerate.Smart.Exp a>_N)
                          (Data.Complex.Complex
                             (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R
                  ->_R (Data.Array.Accelerate.Smart.Exp
                          (Trans
                               (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                    <Data.Array.Accelerate.Smart.Exp a>_N)
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)) -}
b0ee4eec435f00afe09fa75d4cab3230
  $fUnliftExpComplex ::
    Data.Array.Accelerate.Array.Sugar.Elt a =>
    Data.Array.Accelerate.Lift.Unlift
      Data.Array.Accelerate.Smart.Exp
      (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a))
  DFunId
  {- Arity: 1, Strictness: <L,U(U(U,U,U),U,U,U,U,U,U)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt a).
                  @ Data.Array.Accelerate.Smart.Exp
                  @ (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a))
                  (Data.Array.Accelerate.Data.Complex.$fUnliftExpComplex_$cp1Unlift
                     @ a
                     $dElt)
                  (Data.Array.Accelerate.Data.Complex.$fUnliftExpComplex_$cunlift
                     @ a
                     $dElt) -}
100136077e2128035889dc67a9dbd487
  $fUnliftExpComplex_$cp1Unlift ::
    Data.Array.Accelerate.Array.Sugar.Elt a =>
    Data.Array.Accelerate.Lift.Lift
      Data.Array.Accelerate.Smart.Exp
      (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a))
  {- Arity: 1, Strictness: <L,U(U(U,U,U),U,U,U,U,U,U)>,
     Unfolding: (\ @ a
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt a) ->
                 let {
                   $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.Plain
                                     (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 (\ (ds :: Data.Complex.Complex
                             (Data.Array.Accelerate.Smart.Exp a)) ->
                  case ds of wild { Data.Complex.:+ x1 x2 ->
                  (Data.Array.Accelerate.Smart.Tuple
                     @ Data.Array.Accelerate.Smart.Acc
                     @ Data.Array.Accelerate.Smart.Exp
                     @ (Data.Complex.Complex
                          (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a)))
                     $dElt1
                     $dIsProduct
                     (Data.Array.Accelerate.Array.Sugar.SnocTup
                        @ Data.Array.Accelerate.Smart.Exp
                        @ (((),
                            Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp a)),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ ((),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @~ <(((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a)),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))>_N
                        $dElt
                          `cast`
                        (Data.Array.Accelerate.Array.Sugar.Elt
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                        (Data.Array.Accelerate.Array.Sugar.SnocTup
                           @ Data.Array.Accelerate.Smart.Exp
                           @ ((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ (Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ ()
                           @~ <((),
                                Data.Array.Accelerate.Lift.Plain
                                  (Data.Array.Accelerate.Smart.Exp a))>_N
                           $dElt
                             `cast`
                           (Data.Array.Accelerate.Array.Sugar.Elt
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                           (Data.Array.Accelerate.Array.Sugar.$WNilTup
                              @ Data.Array.Accelerate.Smart.Exp)
                           x1
                             `cast`
                           (Data.Array.Accelerate.Smart.Exp
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                        x2
                          `cast`
                        (Data.Array.Accelerate.Smart.Exp
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                       `cast`
                     (Data.Array.Accelerate.Array.Sugar.Tuple
                        <Data.Array.Accelerate.Smart.Exp>_R
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))
                             (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))))_R)
                    `cast`
                  (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                                                        <Data.Array.Accelerate.Smart.Exp
                                                                           a>_N))) })
                   `cast`
                 (Sym (Data.Array.Accelerate.Lift.N:Lift[0]
                           <Data.Array.Accelerate.Smart.Exp>_N
                           <Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a)>_N))) -}
12c299e38de7241aed6aac6d18611eaf
  $fUnliftExpComplex_$cunlift ::
    Data.Array.Accelerate.Array.Sugar.Elt a =>
    Data.Array.Accelerate.Smart.Exp
      (Data.Array.Accelerate.Lift.Plain
         (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a)))
    -> Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a)
  {- Arity: 1, Strictness: <L,U(U(U,U,U),U,U,U,U,U,U)>,
     Unfolding: (\ @ a
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt a) ->
                 let {
                   $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                    (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ a
                       $dElt
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex @ a $dElt
                 } in
                 \ (e :: Data.Array.Accelerate.Smart.Exp
                           (Data.Array.Accelerate.Lift.Plain
                              (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a)))) ->
                 Data.Complex.:+
                   @ (Data.Array.Accelerate.Smart.Exp a)
                   (Data.Array.Accelerate.Smart.Prj
                      @ Data.Array.Accelerate.Smart.Acc
                      @ Data.Array.Accelerate.Smart.Exp
                      @ a
                      @ (Data.Complex.Complex a)
                      $dElt1
                      $dIsProduct
                      $dElt
                      (Data.Array.Accelerate.Data.Complex.$fEqComplex2 @ a)
                        `cast`
                      (Data.Array.Accelerate.Product.TupleIdx
                         (Trans
                              (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                        <a>_N <a>_N))
                              (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                        <a>_N)))
                         <a>_N)_R
                      e `cast`
                      (Data.Array.Accelerate.Smart.Exp
                         (Trans
                              (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                   <Data.Array.Accelerate.Smart.Exp a>_N)
                              (Data.Complex.Complex
                                 (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                     `cast`
                   (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                   (Data.Array.Accelerate.Smart.Prj
                      @ Data.Array.Accelerate.Smart.Acc
                      @ Data.Array.Accelerate.Smart.Exp
                      @ a
                      @ (Data.Complex.Complex a)
                      $dElt1
                      $dIsProduct
                      $dElt
                      (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                        `cast`
                      (Data.Array.Accelerate.Product.TupleIdx
                         (Trans
                              (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                        <a>_N <a>_N))
                              (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                        <a>_N)))
                         <a>_N)_R
                      e `cast`
                      (Data.Array.Accelerate.Smart.Exp
                         (Trans
                              (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                   <Data.Array.Accelerate.Smart.Exp a>_N)
                              (Data.Complex.Complex
                                 (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)
                     `cast`
                   (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)) -}
764ed05a6b70628dcdd4a2573c5c4d4b
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Data.Array.Accelerate.Data.Complex.$trModule2
                   Data.Array.Accelerate.Data.Complex.$trModule1) -}
37debde96a341a81a2c9382fd5c88d4b
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "Data.Array.Accelerate.Data.Complex"#) -}
bc1aed78113837c5ddaf9856cc0a4480
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw"#) -}
53ef8ec6177ded6694e69e581085c4b2
  $w$cp4Elt ::
    Data.Array.Accelerate.Array.Sugar.Elt a =>
    (# Data.Array.Accelerate.Array.Data.ArrayEltR
         (Data.Array.Accelerate.Array.Sugar.EltRepr
            (Data.Complex.Complex a)),
       Data.Array.Accelerate.Array.Data.ArrayData
         (Data.Array.Accelerate.Array.Sugar.EltRepr
            (Data.Complex.Complex a))
       -> GHC.Types.Int
       -> Data.Array.Accelerate.Array.Sugar.EltRepr
            (Data.Complex.Complex a),
       Data.Array.Accelerate.Array.Data.ArrayData
         (Data.Array.Accelerate.Array.Sugar.EltRepr
            (Data.Complex.Complex a))
       -> Data.Array.Accelerate.Array.Data.ArrayPtrs
            (Data.Array.Accelerate.Array.Sugar.EltRepr
               (Data.Complex.Complex a)),
       Data.Array.Accelerate.Array.Data.ArrayData
         (Data.Array.Accelerate.Array.Sugar.EltRepr
            (Data.Complex.Complex a))
       -> GHC.Types.IO (),
       GHC.Types.Int
       -> GHC.Types.IO
            (Data.Array.Accelerate.Array.Data.MutableArrayData
               (Data.Array.Accelerate.Array.Sugar.EltRepr
                  (Data.Complex.Complex a))),
       Data.Array.Accelerate.Array.Data.MutableArrayData
         (Data.Array.Accelerate.Array.Sugar.EltRepr
            (Data.Complex.Complex a))
       -> GHC.Types.Int
       -> GHC.Types.IO
            (Data.Array.Accelerate.Array.Sugar.EltRepr
               (Data.Complex.Complex a)),
       Data.Array.Accelerate.Array.Data.MutableArrayData
         (Data.Array.Accelerate.Array.Sugar.EltRepr
            (Data.Complex.Complex a))
       -> GHC.Types.Int
       -> Data.Array.Accelerate.Array.Sugar.EltRepr
            (Data.Complex.Complex a)
       -> GHC.Types.IO (),
       Data.Array.Accelerate.Array.Data.MutableArrayData
         (Data.Array.Accelerate.Array.Sugar.EltRepr
            (Data.Complex.Complex a))
       -> GHC.Types.IO
            (Data.Array.Accelerate.Array.Data.ArrayData
               (Data.Array.Accelerate.Array.Sugar.EltRepr
                  (Data.Complex.Complex a))),
       Data.Array.Accelerate.Array.Data.MutableArrayData
         (Data.Array.Accelerate.Array.Sugar.EltRepr
            (Data.Complex.Complex a))
       -> GHC.Types.IO
            (Data.Array.Accelerate.Array.Data.ArrayPtrs
               (Data.Array.Accelerate.Array.Sugar.EltRepr
                  (Data.Complex.Complex a))) #)
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*U(A,A,A,1*U,A,A,A)>,
     Inline: [0],
     Unfolding: (\ @ a (w :: Data.Array.Accelerate.Array.Sugar.Elt a) ->
                 let {
                   $dArrayElt :: Data.Array.Accelerate.Array.Data.ArrayElt
                                   (Data.Array.Accelerate.Array.Sugar.EltRepr a)
                   = Data.Array.Accelerate.Array.Sugar.$p4Elt @ a w
                 } in
                 (# (Data.Array.Accelerate.Array.Data.ArrayEltRpair
                       @ (((), Data.Array.Accelerate.Array.Sugar.EltRepr a),
                          Data.Array.Accelerate.Array.Sugar.EltRepr a)
                       @ ((), Data.Array.Accelerate.Array.Sugar.EltRepr a)
                       @ (Data.Array.Accelerate.Array.Sugar.EltRepr a)
                       @~ <(((), Data.Array.Accelerate.Array.Sugar.EltRepr a),
                            Data.Array.Accelerate.Array.Sugar.EltRepr a)>_N
                       (Data.Array.Accelerate.Array.Data.$fArrayElt(,)
                          @ ()
                          @ (Data.Array.Accelerate.Array.Sugar.EltRepr a)
                          Data.Array.Accelerate.Array.Data.$fArrayElt()
                          $dArrayElt)
                       $dArrayElt
                       (Data.Array.Accelerate.Array.Data.ArrayEltRpair
                          @ ((), Data.Array.Accelerate.Array.Sugar.EltRepr a)
                          @ ()
                          @ (Data.Array.Accelerate.Array.Sugar.EltRepr a)
                          @~ <((), Data.Array.Accelerate.Array.Sugar.EltRepr a)>_N
                          Data.Array.Accelerate.Array.Data.$fArrayElt()
                          $dArrayElt
                          Data.Array.Accelerate.Array.Data.$WArrayEltRunit
                          (Data.Array.Accelerate.Array.Data.arrayElt
                             @ (Data.Array.Accelerate.Array.Sugar.EltRepr a)
                             $dArrayElt))
                       (Data.Array.Accelerate.Array.Data.arrayElt
                          @ (Data.Array.Accelerate.Array.Sugar.EltRepr a)
                          $dArrayElt))
                      `cast`
                    (Data.Array.Accelerate.Array.Data.ArrayEltR
                       (Trans
                            (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                      <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N
                                      <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N))
                            (Trans
                                 (Sym (Data.Array.Accelerate.Array.Sugar.D:R:EltRepr(,)[0]
                                           <a>_N <a>_N))
                                 (Sym (Data.Array.Accelerate.Data.Complex.D:R:EltReprComplex[0]
                                           <a>_N)))))_R,
                    (Data.Array.Accelerate.Array.Data.$fArrayElt(,)_$cunsafeIndexArrayData
                       @ ((), Data.Array.Accelerate.Array.Sugar.EltRepr a)
                       @ (Data.Array.Accelerate.Array.Sugar.EltRepr a)
                       (Data.Array.Accelerate.Array.Data.$fArrayElt(,)
                          @ ()
                          @ (Data.Array.Accelerate.Array.Sugar.EltRepr a)
                          Data.Array.Accelerate.Array.Data.$fArrayElt()
                          $dArrayElt)
                       $dArrayElt)
                      `cast`
                    ((Data.Array.Accelerate.Array.Data.GArrayData
                        <Data.Array.Accelerate.Array.Unique.UniqueArray>_N
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N
                                       <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N))
                             (Trans
                                  (Sym (Data.Array.Accelerate.Array.Sugar.D:R:EltRepr(,)[0]
                                            <a>_N <a>_N))
                                  (Sym (Data.Array.Accelerate.Data.Complex.D:R:EltReprComplex[0]
                                            <a>_N)))))_R
                     ->_R <GHC.Types.Int>_R
                     ->_R Trans
                              (Sub (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                             <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N
                                             <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N)))
                              (Trans
                                   (Sub (Sym (Data.Array.Accelerate.Array.Sugar.D:R:EltRepr(,)[0]
                                                  <a>_N <a>_N)))
                                   (Sub (Sym (Data.Array.Accelerate.Data.Complex.D:R:EltReprComplex[0]
                                                  <a>_N))))),
                    (Data.Array.Accelerate.Array.Data.$fArrayElt(,)_$cptrsOfArrayData
                       @ ((), Data.Array.Accelerate.Array.Sugar.EltRepr a)
                       @ (Data.Array.Accelerate.Array.Sugar.EltRepr a)
                       (Data.Array.Accelerate.Array.Data.$fArrayElt(,)
                          @ ()
                          @ (Data.Array.Accelerate.Array.Sugar.EltRepr a)
                          Data.Array.Accelerate.Array.Data.$fArrayElt()
                          $dArrayElt)
                       $dArrayElt)
                      `cast`
                    ((Data.Array.Accelerate.Array.Data.GArrayData
                        <Data.Array.Accelerate.Array.Unique.UniqueArray>_N
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N
                                       <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N))
                             (Trans
                                  (Sym (Data.Array.Accelerate.Array.Sugar.D:R:EltRepr(,)[0]
                                            <a>_N <a>_N))
                                  (Sym (Data.Array.Accelerate.Data.Complex.D:R:EltReprComplex[0]
                                            <a>_N)))))_R
                     ->_R (Data.Array.Accelerate.Array.Data.ArrayPtrs
                             (Trans
                                  (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                            <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N
                                            <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N))
                                  (Trans
                                       (Sym (Data.Array.Accelerate.Array.Sugar.D:R:EltRepr(,)[0]
                                                 <a>_N <a>_N))
                                       (Sym (Data.Array.Accelerate.Data.Complex.D:R:EltReprComplex[0]
                                                 <a>_N)))))_R),
                    (Data.Array.Accelerate.Array.Data.$fArrayElt(,)_$ctouchArrayData
                       @ ((), Data.Array.Accelerate.Array.Sugar.EltRepr a)
                       @ (Data.Array.Accelerate.Array.Sugar.EltRepr a)
                       (Data.Array.Accelerate.Array.Data.$fArrayElt(,)
                          @ ()
                          @ (Data.Array.Accelerate.Array.Sugar.EltRepr a)
                          Data.Array.Accelerate.Array.Data.$fArrayElt()
                          $dArrayElt)
                       $dArrayElt)
                      `cast`
                    ((Data.Array.Accelerate.Array.Data.GArrayData
                        <Data.Array.Accelerate.Array.Unique.UniqueArray>_N
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N
                                       <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N))
                             (Trans
                                  (Sym (Data.Array.Accelerate.Array.Sugar.D:R:EltRepr(,)[0]
                                            <a>_N <a>_N))
                                  (Sym (Data.Array.Accelerate.Data.Complex.D:R:EltReprComplex[0]
                                            <a>_N)))))_R
                     ->_R <GHC.Types.IO ()>_R),
                    (Data.Array.Accelerate.Array.Data.$fArrayElt(,)_$cnewArrayData
                       @ ((), Data.Array.Accelerate.Array.Sugar.EltRepr a)
                       @ (Data.Array.Accelerate.Array.Sugar.EltRepr a)
                       (Data.Array.Accelerate.Array.Data.$fArrayElt(,)
                          @ ()
                          @ (Data.Array.Accelerate.Array.Sugar.EltRepr a)
                          Data.Array.Accelerate.Array.Data.$fArrayElt()
                          $dArrayElt)
                       $dArrayElt)
                      `cast`
                    (<GHC.Types.Int>_R
                     ->_R (GHC.Types.IO
                             (Data.Array.Accelerate.Array.Data.GArrayData
                                <Data.Array.Accelerate.Array.Unique.UniqueArray>_N
                                (Trans
                                     (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                               <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N
                                               <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N))
                                     (Trans
                                          (Sym (Data.Array.Accelerate.Array.Sugar.D:R:EltRepr(,)[0]
                                                    <a>_N <a>_N))
                                          (Sym (Data.Array.Accelerate.Data.Complex.D:R:EltReprComplex[0]
                                                    <a>_N)))))_R)_R),
                    (Data.Array.Accelerate.Array.Data.$fArrayElt(,)_$cunsafeReadArrayData
                       @ ((), Data.Array.Accelerate.Array.Sugar.EltRepr a)
                       @ (Data.Array.Accelerate.Array.Sugar.EltRepr a)
                       (Data.Array.Accelerate.Array.Data.$fArrayElt(,)
                          @ ()
                          @ (Data.Array.Accelerate.Array.Sugar.EltRepr a)
                          Data.Array.Accelerate.Array.Data.$fArrayElt()
                          $dArrayElt)
                       $dArrayElt)
                      `cast`
                    ((Data.Array.Accelerate.Array.Data.GArrayData
                        <Data.Array.Accelerate.Array.Unique.UniqueArray>_N
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N
                                       <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N))
                             (Trans
                                  (Sym (Data.Array.Accelerate.Array.Sugar.D:R:EltRepr(,)[0]
                                            <a>_N <a>_N))
                                  (Sym (Data.Array.Accelerate.Data.Complex.D:R:EltReprComplex[0]
                                            <a>_N)))))_R
                     ->_R <GHC.Types.Int>_R
                     ->_R (GHC.Types.IO
                             (Trans
                                  (Sub (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                                 <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N
                                                 <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N)))
                                  (Trans
                                       (Sub (Sym (Data.Array.Accelerate.Array.Sugar.D:R:EltRepr(,)[0]
                                                      <a>_N <a>_N)))
                                       (Sub (Sym (Data.Array.Accelerate.Data.Complex.D:R:EltReprComplex[0]
                                                      <a>_N))))))_R),
                    (Data.Array.Accelerate.Array.Data.$fArrayElt(,)_$cunsafeWriteArrayData
                       @ ((), Data.Array.Accelerate.Array.Sugar.EltRepr a)
                       @ (Data.Array.Accelerate.Array.Sugar.EltRepr a)
                       (Data.Array.Accelerate.Array.Data.$fArrayElt(,)
                          @ ()
                          @ (Data.Array.Accelerate.Array.Sugar.EltRepr a)
                          Data.Array.Accelerate.Array.Data.$fArrayElt()
                          $dArrayElt)
                       $dArrayElt)
                      `cast`
                    ((Data.Array.Accelerate.Array.Data.GArrayData
                        <Data.Array.Accelerate.Array.Unique.UniqueArray>_N
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N
                                       <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N))
                             (Trans
                                  (Sym (Data.Array.Accelerate.Array.Sugar.D:R:EltRepr(,)[0]
                                            <a>_N <a>_N))
                                  (Sym (Data.Array.Accelerate.Data.Complex.D:R:EltReprComplex[0]
                                            <a>_N)))))_R
                     ->_R <GHC.Types.Int>_R
                     ->_R Trans
                              (Sub (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                             <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N
                                             <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N)))
                              (Trans
                                   (Sub (Sym (Data.Array.Accelerate.Array.Sugar.D:R:EltRepr(,)[0]
                                                  <a>_N <a>_N)))
                                   (Sub (Sym (Data.Array.Accelerate.Data.Complex.D:R:EltReprComplex[0]
                                                  <a>_N))))
                     ->_R <GHC.Types.IO ()>_R),
                    (Data.Array.Accelerate.Array.Data.$fArrayElt(,)_$cunsafeFreezeArrayData
                       @ ((), Data.Array.Accelerate.Array.Sugar.EltRepr a)
                       @ (Data.Array.Accelerate.Array.Sugar.EltRepr a)
                       (Data.Array.Accelerate.Array.Data.$fArrayElt(,)
                          @ ()
                          @ (Data.Array.Accelerate.Array.Sugar.EltRepr a)
                          Data.Array.Accelerate.Array.Data.$fArrayElt()
                          $dArrayElt)
                       $dArrayElt)
                      `cast`
                    ((Data.Array.Accelerate.Array.Data.GArrayData
                        <Data.Array.Accelerate.Array.Unique.UniqueArray>_N
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N
                                       <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N))
                             (Trans
                                  (Sym (Data.Array.Accelerate.Array.Sugar.D:R:EltRepr(,)[0]
                                            <a>_N <a>_N))
                                  (Sym (Data.Array.Accelerate.Data.Complex.D:R:EltReprComplex[0]
                                            <a>_N)))))_R
                     ->_R (GHC.Types.IO
                             (Data.Array.Accelerate.Array.Data.GArrayData
                                <Data.Array.Accelerate.Array.Unique.UniqueArray>_N
                                (Trans
                                     (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                               <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N
                                               <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N))
                                     (Trans
                                          (Sym (Data.Array.Accelerate.Array.Sugar.D:R:EltRepr(,)[0]
                                                    <a>_N <a>_N))
                                          (Sym (Data.Array.Accelerate.Data.Complex.D:R:EltReprComplex[0]
                                                    <a>_N)))))_R)_R),
                    (Data.Array.Accelerate.Array.Data.$fArrayElt(,)_$cptrsOfMutableArrayData
                       @ ((), Data.Array.Accelerate.Array.Sugar.EltRepr a)
                       @ (Data.Array.Accelerate.Array.Sugar.EltRepr a)
                       (Data.Array.Accelerate.Array.Data.$fArrayElt(,)
                          @ ()
                          @ (Data.Array.Accelerate.Array.Sugar.EltRepr a)
                          Data.Array.Accelerate.Array.Data.$fArrayElt()
                          $dArrayElt)
                       $dArrayElt)
                      `cast`
                    ((Data.Array.Accelerate.Array.Data.GArrayData
                        <Data.Array.Accelerate.Array.Unique.UniqueArray>_N
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N
                                       <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N))
                             (Trans
                                  (Sym (Data.Array.Accelerate.Array.Sugar.D:R:EltRepr(,)[0]
                                            <a>_N <a>_N))
                                  (Sym (Data.Array.Accelerate.Data.Complex.D:R:EltReprComplex[0]
                                            <a>_N)))))_R
                     ->_R (GHC.Types.IO
                             (Data.Array.Accelerate.Array.Data.ArrayPtrs
                                (Trans
                                     (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                               <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N
                                               <Data.Array.Accelerate.Array.Sugar.EltRepr a>_N))
                                     (Trans
                                          (Sym (Data.Array.Accelerate.Array.Sugar.D:R:EltRepr(,)[0]
                                                    <a>_N <a>_N))
                                          (Sym (Data.Array.Accelerate.Data.Complex.D:R:EltReprComplex[0]
                                                    <a>_N)))))_R)_R) #)) -}
c13bb70ea7539f0739e168cded39c6ea
  $w$cpi ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    (# Data.Array.Accelerate.Array.Sugar.Elt
         (Data.Array.Accelerate.Lift.Plain
            (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a))),
       Data.Array.Accelerate.Array.Sugar.IsTuple
         (Data.Array.Accelerate.Lift.Plain
            (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a))),
       Data.Array.Accelerate.Array.Sugar.Tuple
         Data.Array.Accelerate.Smart.Exp
         (Data.Array.Accelerate.Array.Sugar.TupleRepr
            (Data.Array.Accelerate.Lift.Plain
               (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a)))) #)
  {- Arity: 1,
     Strictness: <S(S(S(LLS(S(LLLLLLC(S))LL))LLLLLL)S(LS(LSLLLLLLLLLLLLLLLLLLLLL))LLLLLLLLLLLLLL),U(U(U(U,U,U(U(U,U,U,U,U,U,U),U,U)),U,U,U,U,U,U),1*U(A,1*U(A,1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: Data.Array.Accelerate.Classes.RealFloat.RealFloat a) ->
                 case (GHC.Float.pi
                         @ (Data.Array.Accelerate.Smart.Exp a)
                         (GHC.Classes.$p2(%,%)
                            @ (Data.Array.Accelerate.Classes.Fractional.Fractional a)
                            @ (GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp a))
                            (Data.Array.Accelerate.Classes.RealFloat.$p2RealFloat @ a w)))
                        `cast`
                      (Data.Array.Accelerate.Smart.N:Exp[0] <a>_N) of nt { DEFAULT ->
                 case (GHC.Num.fromInteger
                         @ (Data.Array.Accelerate.Smart.Exp a)
                         (GHC.Real.$p1Real
                            @ (Data.Array.Accelerate.Smart.Exp a)
                            (GHC.Classes.$p3(%,,%)
                               @ (Data.Array.Accelerate.Classes.Num.Num a)
                               @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                               @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                               (Data.Array.Accelerate.Classes.RealFrac.$p1RealFrac
                                  @ a
                                  (Data.Array.Accelerate.Classes.RealFloat.$p1RealFloat @ a w))))
                         Data.Complex.$fFloatingComplex13)
                        `cast`
                      (Data.Array.Accelerate.Smart.N:Exp[0] <a>_N) of nt1 { DEFAULT ->
                 let {
                   $dElt :: Data.Array.Accelerate.Classes.RealFrac.RealFrac a
                   = Data.Array.Accelerate.Classes.RealFloat.$p1RealFloat @ a w
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Classes.Real.Real a
                   = Data.Array.Accelerate.Classes.RealFrac.$p1RealFrac @ a $dElt
                 } in
                 let {
                   $dElt2 :: Data.Array.Accelerate.Classes.Num.Num a
                   = GHC.Classes.$p1(%,,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                       @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                       $dElt1
                 } in
                 let {
                   $dElt3 :: Data.Array.Accelerate.Array.Sugar.Elt a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                       $dElt2
                 } in
                 (# (Data.Array.Accelerate.Data.Complex.$fEltComplex
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt3
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                      `cast`
                    (Data.Array.Accelerate.Array.Sugar.Elt
                       (Sym (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                 <Data.Array.Accelerate.Smart.Exp a>_N)))_R,
                    (Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt3
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                      `cast`
                    (Data.Array.Accelerate.Product.IsProduct
                       <Data.Array.Accelerate.Array.Sugar.Elt>_N
                       (Sym (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                 <Data.Array.Accelerate.Smart.Exp a>_N)))_R,
                    (Data.Array.Accelerate.Array.Sugar.SnocTup
                       @ Data.Array.Accelerate.Smart.Exp
                       @ (((),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a)),
                          Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       @ ((),
                          Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       @~ <(((),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a)),
                            Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp a))>_N
                       $dElt3
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                       (Data.Array.Accelerate.Array.Sugar.SnocTup
                          @ Data.Array.Accelerate.Smart.Exp
                          @ ((),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))
                          @ (Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))
                          @ ()
                          @~ <((),
                               Data.Array.Accelerate.Lift.Plain
                                 (Data.Array.Accelerate.Smart.Exp a))>_N
                          $dElt3
                            `cast`
                          (Data.Array.Accelerate.Array.Sugar.Elt
                             (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                          (Data.Array.Accelerate.Array.Sugar.$WNilTup
                             @ Data.Array.Accelerate.Smart.Exp)
                          nt
                            `cast`
                          (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0]
                                                                                <a>_N))))
                       nt1
                         `cast`
                       (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0]
                                                                             <a>_N))))
                      `cast`
                    (Data.Array.Accelerate.Array.Sugar.Tuple
                       <Data.Array.Accelerate.Smart.Exp>_R
                       (Trans
                            (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                      <Data.Array.Accelerate.Lift.Plain
                                         (Data.Array.Accelerate.Smart.Exp a)>_N
                                      <Data.Array.Accelerate.Lift.Plain
                                         (Data.Array.Accelerate.Smart.Exp a)>_N))
                            (Trans
                                 (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                           <Data.Array.Accelerate.Lift.Plain
                                              (Data.Array.Accelerate.Smart.Exp a)>_N))
                                 (Data.Array.Accelerate.Product.ProdRepr
                                    (Sym (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                              <Data.Array.Accelerate.Smart.Exp
                                                 a>_N)))_N)))_R #) } }) -}
85841faae1c405bd1a9ba31ef9fd46df
  $wpolar ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> (# Data.Array.Accelerate.Array.Sugar.Elt (a, a),
          Data.Array.Accelerate.Array.Sugar.IsTuple (a, a),
          Data.Array.Accelerate.Array.Sugar.Tuple
            Data.Array.Accelerate.Smart.Exp
            (Data.Array.Accelerate.Array.Sugar.TupleRepr (a, a)) #)
  {- Arity: 2,
     Strictness: <L,U(U,U(A,U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)),A,A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)))><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: Data.Array.Accelerate.Classes.RealFloat.RealFloat a)
                   (w1 :: Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)) ->
                 let {
                   $dRealFrac :: Data.Array.Accelerate.Classes.RealFrac.RealFrac a
                   = Data.Array.Accelerate.Classes.RealFloat.$p1RealFloat @ a w
                 } in
                 let {
                   $d(%,,%) :: Data.Array.Accelerate.Classes.Real.Real a
                   = Data.Array.Accelerate.Classes.RealFrac.$p1RealFrac @ a $dRealFrac
                 } in
                 let {
                   $d(%,%) :: Data.Array.Accelerate.Classes.Num.Num a
                   = GHC.Classes.$p1(%,,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                       @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,,%)
                 } in
                 let {
                   $dElt :: Data.Array.Accelerate.Array.Sugar.Elt a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,%)
                 } in
                 (# (Data.Array.Accelerate.Array.Sugar.$fElt(,)
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                      `cast`
                    (Data.Array.Accelerate.Array.Sugar.Elt
                       ((,)
                          (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)
                          (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N)_R,
                    (Data.Array.Accelerate.Product.$fIsProductcst(,)
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                      `cast`
                    (Data.Array.Accelerate.Product.IsProduct
                       <Data.Array.Accelerate.Array.Sugar.Elt>_N
                       ((,)
                          (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)
                          (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N)_R,
                    (Data.Array.Accelerate.Array.Sugar.SnocTup
                       @ Data.Array.Accelerate.Smart.Exp
                       @ (((),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a)),
                          Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       @ ((),
                          Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       @~ <(((),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a)),
                            Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp a))>_N
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                       (Data.Array.Accelerate.Array.Sugar.SnocTup
                          @ Data.Array.Accelerate.Smart.Exp
                          @ ((),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))
                          @ (Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))
                          @ ()
                          @~ <((),
                               Data.Array.Accelerate.Lift.Plain
                                 (Data.Array.Accelerate.Smart.Exp a))>_N
                          $dElt
                            `cast`
                          (Data.Array.Accelerate.Array.Sugar.Elt
                             (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                          (Data.Array.Accelerate.Array.Sugar.$WNilTup
                             @ Data.Array.Accelerate.Smart.Exp)
                          (Data.Array.Accelerate.Data.Complex.magnitude @ a w w1)
                            `cast`
                          (Data.Array.Accelerate.Smart.Exp
                             (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                       (Data.Array.Accelerate.Data.Complex.phase @ a w w1)
                         `cast`
                       (Data.Array.Accelerate.Smart.Exp
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                      `cast`
                    (Data.Array.Accelerate.Array.Sugar.Tuple
                       <Data.Array.Accelerate.Smart.Exp>_R
                       (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                 (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))
                                 (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0]
                                           <a>_N)))))_R #)) -}
438d1c19ffbfd808890357a27fd3e7ec
  axiom D:R:EltReprComplex::
    [a]
      Data.Array.Accelerate.Array.Sugar.EltRepr (Data.Complex.Complex a)
        = Data.Array.Accelerate.Array.Sugar.EltRepr (a, a)
ed8fb2bcd1e1e3e5d707a860e0c66653
  axiom D:R:PlainComplex::
    [a]
      Data.Array.Accelerate.Lift.Plain (Data.Complex.Complex a)
        = Data.Complex.Complex (Data.Array.Accelerate.Lift.Plain a)
00783ae9ab7e28a1984d75fe96e10e7c
  axiom D:R:ProdReprComplex::
    [a]
      Data.Array.Accelerate.Product.ProdRepr (Data.Complex.Complex a)
        = Data.Array.Accelerate.Product.ProdRepr (a, a)
b46485ca02571a3a60381240a8dc951c
  cis ::
    Data.Array.Accelerate.Classes.Floating.Floating a =>
    Data.Array.Accelerate.Smart.Exp a
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 1, Strictness: <L,U(1*U,1*U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Data.Complex.cis1
                  `cast`
                (forall (a :: <*>_N).
                 <Data.Array.Accelerate.Classes.Floating.Floating a>_R
                 ->_R (Data.Array.Accelerate.Smart.Exp
                         (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_R
                 ->_R (Data.Array.Accelerate.Smart.Exp
                         (Trans
                              (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                   <Data.Array.Accelerate.Smart.Exp a>_N)
                              (Data.Complex.Complex
                                 (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R) -}
aa1005421e30dc2a9996413e37e54b1f
  cis1 ::
    Data.Array.Accelerate.Classes.Floating.Floating a =>
    Data.Array.Accelerate.Smart.Exp
      (Data.Array.Accelerate.Lift.Plain
         (Data.Array.Accelerate.Smart.Exp a))
    -> Data.Array.Accelerate.Smart.Exp
         (Data.Array.Accelerate.Lift.Plain
            (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a)))
  {- Arity: 1, Strictness: <L,U(1*U,1*U)>,
     Unfolding: (\ @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Floating.Floating a) ->
                 let {
                   $dElt :: Data.Array.Accelerate.Classes.Fractional.Fractional a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Classes.Fractional.Fractional a)
                       @ (GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,%)
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Classes.Num.Num a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (GHC.Real.Fractional (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                 } in
                 let {
                   $dElt2 :: Data.Array.Accelerate.Array.Sugar.Elt a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                       $dElt1
                 } in
                 let {
                   $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt2
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dElt3 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.Plain
                                     (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt2
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dFloating :: GHC.Float.Floating
                                   (Data.Array.Accelerate.Smart.Exp a)
                   = GHC.Classes.$p2(%,%)
                       @ (Data.Array.Accelerate.Classes.Fractional.Fractional a)
                       @ (GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,%)
                 } in
                 \ (eta :: Data.Array.Accelerate.Smart.Exp
                             (Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))) ->
                 case (GHC.Float.cos
                         @ (Data.Array.Accelerate.Smart.Exp a)
                         $dFloating
                         eta
                           `cast`
                         (Data.Array.Accelerate.Smart.Exp
                            (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_R)
                        `cast`
                      (Data.Array.Accelerate.Smart.N:Exp[0] <a>_N) of nt { DEFAULT ->
                 case (GHC.Float.sin
                         @ (Data.Array.Accelerate.Smart.Exp a)
                         $dFloating
                         eta
                           `cast`
                         (Data.Array.Accelerate.Smart.Exp
                            (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_R)
                        `cast`
                      (Data.Array.Accelerate.Smart.N:Exp[0] <a>_N) of nt1 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.Tuple
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ (Data.Complex.Complex
                         (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a)))
                    $dElt3
                    $dIsProduct
                    (Data.Array.Accelerate.Array.Sugar.SnocTup
                       @ Data.Array.Accelerate.Smart.Exp
                       @ (((),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a)),
                          Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       @ ((),
                          Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       @~ <(((),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a)),
                            Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp a))>_N
                       $dElt2
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                       (Data.Array.Accelerate.Array.Sugar.SnocTup
                          @ Data.Array.Accelerate.Smart.Exp
                          @ ((),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))
                          @ (Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))
                          @ ()
                          @~ <((),
                               Data.Array.Accelerate.Lift.Plain
                                 (Data.Array.Accelerate.Smart.Exp a))>_N
                          $dElt2
                            `cast`
                          (Data.Array.Accelerate.Array.Sugar.Elt
                             (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                          (Data.Array.Accelerate.Array.Sugar.$WNilTup
                             @ Data.Array.Accelerate.Smart.Exp)
                          nt
                            `cast`
                          (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0]
                                                                                <a>_N))))
                       nt1
                         `cast`
                       (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0]
                                                                             <a>_N))))
                      `cast`
                    (Data.Array.Accelerate.Array.Sugar.Tuple
                       <Data.Array.Accelerate.Smart.Exp>_R
                       (Trans
                            (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                      <Data.Array.Accelerate.Lift.Plain
                                         (Data.Array.Accelerate.Smart.Exp a)>_N
                                      <Data.Array.Accelerate.Lift.Plain
                                         (Data.Array.Accelerate.Smart.Exp a)>_N))
                            (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                      <Data.Array.Accelerate.Lift.Plain
                                         (Data.Array.Accelerate.Smart.Exp a)>_N))))_R)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                                                       <Data.Array.Accelerate.Smart.Exp
                                                                          a>_N))) } }) -}
556749ecc0cb440d0c3c16bf99d81997
  conjugate ::
    Data.Array.Accelerate.Classes.Num.Num a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 1, Strictness: <L,U(1*U,1*U)>,
     Unfolding: (\ @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num a) ->
                 let {
                   $dElt :: Data.Array.Accelerate.Array.Sugar.Elt a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,%)
                 } in
                 let {
                   lvl13 :: Data.Array.Accelerate.Array.Sugar.Elt
                              (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex @ a $dElt
                 } in
                 let {
                   lvl14 :: Data.Array.Accelerate.Product.IsProduct
                              Data.Array.Accelerate.Array.Sugar.Elt (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ a
                       $dElt
                 } in
                 let {
                   $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.Plain
                                     (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dNum :: GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a)
                   = GHC.Classes.$p2(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,%)
                 } in
                 (\ (z :: Data.Array.Accelerate.Smart.Exp
                            (Data.Complex.Complex a)) ->
                  case (GHC.Num.negate
                          @ (Data.Array.Accelerate.Smart.Exp a)
                          $dNum
                          (Data.Array.Accelerate.Smart.Prj
                             @ Data.Array.Accelerate.Smart.Acc
                             @ Data.Array.Accelerate.Smart.Exp
                             @ a
                             @ (Data.Complex.Complex a)
                             lvl13
                             lvl14
                             $dElt
                             (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                               `cast`
                             (Data.Array.Accelerate.Product.TupleIdx
                                (Trans
                                     (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                               <a>_N <a>_N))
                                     (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                               <a>_N)))
                                <a>_N)_R
                             z)
                            `cast`
                          (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N))
                         `cast`
                       (Data.Array.Accelerate.Smart.N:Exp[0] <a>_N) of nt { DEFAULT ->
                  (Data.Array.Accelerate.Smart.Tuple
                     @ Data.Array.Accelerate.Smart.Acc
                     @ Data.Array.Accelerate.Smart.Exp
                     @ (Data.Complex.Complex
                          (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a)))
                     $dElt1
                     $dIsProduct
                     (Data.Array.Accelerate.Array.Sugar.SnocTup
                        @ Data.Array.Accelerate.Smart.Exp
                        @ (((),
                            Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp a)),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ (Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @ ((),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a))
                        @~ <(((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a)),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))>_N
                        $dElt
                          `cast`
                        (Data.Array.Accelerate.Array.Sugar.Elt
                           (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                        (Data.Array.Accelerate.Array.Sugar.SnocTup
                           @ Data.Array.Accelerate.Smart.Exp
                           @ ((),
                              Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ (Data.Array.Accelerate.Lift.Plain
                                (Data.Array.Accelerate.Smart.Exp a))
                           @ ()
                           @~ <((),
                                Data.Array.Accelerate.Lift.Plain
                                  (Data.Array.Accelerate.Smart.Exp a))>_N
                           $dElt
                             `cast`
                           (Data.Array.Accelerate.Array.Sugar.Elt
                              (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                           (Data.Array.Accelerate.Array.Sugar.$WNilTup
                              @ Data.Array.Accelerate.Smart.Exp)
                           (Data.Array.Accelerate.Smart.Prj
                              @ Data.Array.Accelerate.Smart.Acc
                              @ Data.Array.Accelerate.Smart.Exp
                              @ a
                              @ (Data.Complex.Complex a)
                              lvl13
                              lvl14
                              $dElt
                              (Data.Array.Accelerate.Data.Complex.$fEqComplex2 @ a)
                                `cast`
                              (Data.Array.Accelerate.Product.TupleIdx
                                 (Trans
                                      (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                                <a>_N <a>_N))
                                      (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                                <a>_N)))
                                 <a>_N)_R
                              z)
                             `cast`
                           (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0]
                                                                                 <a>_N))))
                        nt
                          `cast`
                        (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0]
                                                                              <a>_N))))
                       `cast`
                     (Data.Array.Accelerate.Array.Sugar.Tuple
                        <Data.Array.Accelerate.Smart.Exp>_R
                        (Trans
                             (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))
                             (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                       <Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)>_N))))_R)
                    `cast`
                  (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                                                        <Data.Array.Accelerate.Smart.Exp
                                                                           a>_N))) })
                   `cast`
                 (<Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)>_R
                  ->_R (Data.Array.Accelerate.Smart.Exp
                          (Trans
                               (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                    <Data.Array.Accelerate.Smart.Exp a>_N)
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R)) -}
69e7658cc0b433a1562c3c4fef44849f
  imag ::
    Data.Array.Accelerate.Array.Sugar.Elt a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp a
  {- Arity: 2, Strictness: <L,U(U(U,U,U),U,U,U,U,U,U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Data.Complex.imag1
                  `cast`
                (forall (a :: <*>_N).
                 <Data.Array.Accelerate.Array.Sugar.Elt a>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N) -}
2fcd676aac95ff1765a7309b4dbb6b99
  imag1 ::
    Data.Array.Accelerate.Array.Sugar.Elt a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc Data.Array.Accelerate.Smart.Exp a
  {- Arity: 2, Strictness: <L,U(U(U,U,U),U,U,U,U,U,U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt a)
                   (c :: Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)) ->
                 Data.Array.Accelerate.Smart.Prj
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ a
                   @ (Data.Complex.Complex a)
                   (Data.Array.Accelerate.Data.Complex.$fEltComplex @ a $dElt)
                   (Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                      @ Data.Array.Accelerate.Array.Sugar.Elt
                      @ a
                      $dElt)
                   $dElt
                   (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                     `cast`
                   (Data.Array.Accelerate.Product.TupleIdx
                      (Trans
                           (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                     <a>_N <a>_N))
                           (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                     <a>_N)))
                      <a>_N)_R
                   c) -}
3fd609ffb9b8e9f1b17f866a75ec5721
  magnitude ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp a
  {- Arity: 2,
     Strictness: <S(LS(LS(LLLLC(S)LLLLLLLLLLLLLLLLLL))LLLLLLLLLLLLLL),U(1*U,1*U(A,1*U(A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
     Unfolding: (\ @ a
                   ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                     a)
                   (eta :: Data.Array.Accelerate.Smart.Exp
                             (Data.Complex.Complex a)) ->
                 GHC.Float.sqrt
                   @ (Data.Array.Accelerate.Smart.Exp a)
                   (GHC.Classes.$p2(%,%)
                      @ (Data.Array.Accelerate.Classes.Fractional.Fractional a)
                      @ (GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp a))
                      (Data.Array.Accelerate.Classes.RealFloat.$p2RealFloat
                         @ a
                         $dRealFloat))
                   (let {
                      $dRealFrac :: Data.Array.Accelerate.Classes.RealFrac.RealFrac a
                      = Data.Array.Accelerate.Classes.RealFloat.$p1RealFloat
                          @ a
                          $dRealFloat
                    } in
                    let {
                      $d(%,,%) :: Data.Array.Accelerate.Classes.Real.Real a
                      = Data.Array.Accelerate.Classes.RealFrac.$p1RealFrac @ a $dRealFrac
                    } in
                    let {
                      $d(%,%) :: Data.Array.Accelerate.Classes.Num.Num a
                      = GHC.Classes.$p1(%,,%)
                          @ (Data.Array.Accelerate.Classes.Num.Num a)
                          @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                          @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                          $d(%,,%)
                    } in
                    let {
                      $dNum :: GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a)
                      = GHC.Classes.$p2(%,%)
                          @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                          @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                          $d(%,%)
                    } in
                    let {
                      $dElt :: Data.Array.Accelerate.Array.Sugar.Elt a
                      = GHC.Classes.$p1(%,%)
                          @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                          @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                          $d(%,%)
                    } in
                    let {
                      $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                       (Data.Complex.Complex a)
                      = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                          @ Data.Array.Accelerate.Array.Sugar.Elt
                          @ a
                          $dElt
                    } in
                    let {
                      $dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt
                                  (Data.Complex.Complex a)
                      = Data.Array.Accelerate.Data.Complex.$fEltComplex @ a $dElt
                    } in
                    GHC.Num.+
                      @ (Data.Array.Accelerate.Smart.Exp a)
                      $dNum
                      (let {
                         ds :: Data.Array.Accelerate.Smart.PreExp
                                 Data.Array.Accelerate.Smart.Acc Data.Array.Accelerate.Smart.Exp a
                         = Data.Array.Accelerate.Smart.Prj
                             @ Data.Array.Accelerate.Smart.Acc
                             @ Data.Array.Accelerate.Smart.Exp
                             @ a
                             @ (Data.Complex.Complex a)
                             $dElt1
                             $dIsProduct
                             $dElt
                             (Data.Array.Accelerate.Data.Complex.$fEqComplex2 @ a)
                               `cast`
                             (Data.Array.Accelerate.Product.TupleIdx
                                (Trans
                                     (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                               <a>_N <a>_N))
                                     (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                               <a>_N)))
                                <a>_N)_R
                             eta
                       } in
                       GHC.Num.*
                         @ (Data.Array.Accelerate.Smart.Exp a)
                         $dNum
                         ds `cast` (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                         ds `cast` (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N))
                      (let {
                         ds :: Data.Array.Accelerate.Smart.PreExp
                                 Data.Array.Accelerate.Smart.Acc Data.Array.Accelerate.Smart.Exp a
                         = Data.Array.Accelerate.Smart.Prj
                             @ Data.Array.Accelerate.Smart.Acc
                             @ Data.Array.Accelerate.Smart.Exp
                             @ a
                             @ (Data.Complex.Complex a)
                             $dElt1
                             $dIsProduct
                             $dElt
                             (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                               `cast`
                             (Data.Array.Accelerate.Product.TupleIdx
                                (Trans
                                     (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                               <a>_N <a>_N))
                                     (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                               <a>_N)))
                                <a>_N)_R
                             eta
                       } in
                       GHC.Num.*
                         @ (Data.Array.Accelerate.Smart.Exp a)
                         $dNum
                         ds `cast` (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                         ds `cast` (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)))) -}
1688e91494fadbeb4d7a581776405c9e
  mkPolar ::
    Data.Array.Accelerate.Classes.Floating.Floating a =>
    Data.Array.Accelerate.Smart.Exp a
    -> Data.Array.Accelerate.Smart.Exp a
    -> Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
  {- Arity: 1, Strictness: <L,U(1*U,1*U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Data.Complex.mkPolar1
                  `cast`
                (forall (a :: <*>_N).
                 <Data.Array.Accelerate.Classes.Floating.Floating a>_R
                 ->_R (Data.Array.Accelerate.Smart.Exp
                         (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_R
                 ->_R (Data.Array.Accelerate.Smart.Exp
                         (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_R
                 ->_R (Data.Array.Accelerate.Smart.Exp
                         (Trans
                              (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                   <Data.Array.Accelerate.Smart.Exp a>_N)
                              (Data.Complex.Complex
                                 (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_N))_R) -}
a9f03f164039179e76301e11bc217ab0
  mkPolar1 ::
    Data.Array.Accelerate.Classes.Floating.Floating a =>
    Data.Array.Accelerate.Smart.Exp
      (Data.Array.Accelerate.Lift.Plain
         (Data.Array.Accelerate.Smart.Exp a))
    -> Data.Array.Accelerate.Smart.Exp
         (Data.Array.Accelerate.Lift.Plain
            (Data.Array.Accelerate.Smart.Exp a))
    -> Data.Array.Accelerate.Smart.Exp
         (Data.Array.Accelerate.Lift.Plain
            (Data.Complex.Complex (Data.Array.Accelerate.Smart.Exp a)))
  {- Arity: 1, Strictness: <L,U(1*U,1*U)>,
     Unfolding: (\ @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Floating.Floating a) ->
                 let {
                   $dElt :: Data.Array.Accelerate.Classes.Fractional.Fractional a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Classes.Fractional.Fractional a)
                       @ (GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,%)
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Classes.Num.Num a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (GHC.Real.Fractional (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                 } in
                 let {
                   $dElt2 :: Data.Array.Accelerate.Array.Sugar.Elt a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                       $dElt1
                 } in
                 let {
                   $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                    (Data.Complex.Complex
                                       (Data.Array.Accelerate.Lift.Plain
                                          (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt2
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   $dElt3 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex
                                  (Data.Array.Accelerate.Lift.Plain
                                     (Data.Array.Accelerate.Smart.Exp a)))
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       $dElt2
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                 } in
                 let {
                   f :: GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp a)
                   = GHC.Classes.$p2(%,%)
                       @ (Data.Array.Accelerate.Classes.Fractional.Fractional a)
                       @ (GHC.Float.Floating (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,%)
                 } in
                 \ (x :: Data.Array.Accelerate.Smart.Exp
                           (Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp a)))
                   (y :: Data.Array.Accelerate.Smart.Exp
                           (Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp a))) ->
                 case Data.Complex.$wmkPolar
                        @ (Data.Array.Accelerate.Smart.Exp a)
                        f
                        x `cast`
                        (Data.Array.Accelerate.Smart.Exp
                           (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N))_R
                        y `cast`
                        (Data.Array.Accelerate.Smart.Exp
                           (Data.Array.Accelerate.Lift.D:R:PlainExp[0]
                                <a>_N))_R of ww { (#,#) ww1 ww2 ->
                 (Data.Array.Accelerate.Smart.Tuple
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ (Data.Complex.Complex
                         (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a)))
                    $dElt3
                    $dIsProduct
                    (Data.Array.Accelerate.Array.Sugar.SnocTup
                       @ Data.Array.Accelerate.Smart.Exp
                       @ (((),
                           Data.Array.Accelerate.Lift.Plain
                             (Data.Array.Accelerate.Smart.Exp a)),
                          Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       @ (Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       @ ((),
                          Data.Array.Accelerate.Lift.Plain
                            (Data.Array.Accelerate.Smart.Exp a))
                       @~ <(((),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a)),
                            Data.Array.Accelerate.Lift.Plain
                              (Data.Array.Accelerate.Smart.Exp a))>_N
                       $dElt2
                         `cast`
                       (Data.Array.Accelerate.Array.Sugar.Elt
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                       (Data.Array.Accelerate.Array.Sugar.SnocTup
                          @ Data.Array.Accelerate.Smart.Exp
                          @ ((),
                             Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))
                          @ (Data.Array.Accelerate.Lift.Plain
                               (Data.Array.Accelerate.Smart.Exp a))
                          @ ()
                          @~ <((),
                               Data.Array.Accelerate.Lift.Plain
                                 (Data.Array.Accelerate.Smart.Exp a))>_N
                          $dElt2
                            `cast`
                          (Data.Array.Accelerate.Array.Sugar.Elt
                             (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R
                          (Data.Array.Accelerate.Array.Sugar.$WNilTup
                             @ Data.Array.Accelerate.Smart.Exp)
                          ww1
                            `cast`
                          (Data.Array.Accelerate.Smart.Exp
                             (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                       ww2
                         `cast`
                       (Data.Array.Accelerate.Smart.Exp
                          (Sym (Data.Array.Accelerate.Lift.D:R:PlainExp[0] <a>_N)))_R)
                      `cast`
                    (Data.Array.Accelerate.Array.Sugar.Tuple
                       <Data.Array.Accelerate.Smart.Exp>_R
                       (Trans
                            (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                      <Data.Array.Accelerate.Lift.Plain
                                         (Data.Array.Accelerate.Smart.Exp a)>_N
                                      <Data.Array.Accelerate.Lift.Plain
                                         (Data.Array.Accelerate.Smart.Exp a)>_N))
                            (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                      <Data.Array.Accelerate.Lift.Plain
                                         (Data.Array.Accelerate.Smart.Exp a)>_N))))_R)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) (Sym (Data.Array.Accelerate.Data.Complex.D:R:PlainComplex[0]
                                                                       <Data.Array.Accelerate.Smart.Exp
                                                                          a>_N))) }) -}
81a244e274b71b6e853088b01fc4d61e
  phase ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp a
  {- Arity: 2,
     Strictness: <S(LLLLLLLLLLLLLLLC(C(S))),U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)))><L,U>,
     Unfolding: (\ @ a
                   ($dRealFloat :: Data.Array.Accelerate.Classes.RealFloat.RealFloat
                                     a)
                   (eta :: Data.Array.Accelerate.Smart.Exp
                             (Data.Complex.Complex a)) ->
                 let {
                   $dElt :: Data.Array.Accelerate.Classes.RealFrac.RealFrac a
                   = Data.Array.Accelerate.Classes.RealFloat.$p1RealFloat
                       @ a
                       $dRealFloat
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Classes.Real.Real a
                   = Data.Array.Accelerate.Classes.RealFrac.$p1RealFrac @ a $dElt
                 } in
                 let {
                   $dElt2 :: Data.Array.Accelerate.Classes.Num.Num a
                   = GHC.Classes.$p1(%,,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                       @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                       $dElt1
                 } in
                 let {
                   $dElt3 :: Data.Array.Accelerate.Array.Sugar.Elt a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                       $dElt2
                 } in
                 let {
                   $dIsProduct :: Data.Array.Accelerate.Array.Sugar.IsTuple
                                    (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ a
                       $dElt3
                 } in
                 let {
                   $dElt4 :: Data.Array.Accelerate.Array.Sugar.Elt
                               (Data.Complex.Complex a)
                   = Data.Array.Accelerate.Data.Complex.$fEltComplex @ a $dElt3
                 } in
                 Data.Array.Accelerate.Classes.RealFloat.atan2
                   @ a
                   $dRealFloat
                   (Data.Array.Accelerate.Smart.Prj
                      @ Data.Array.Accelerate.Smart.Acc
                      @ Data.Array.Accelerate.Smart.Exp
                      @ a
                      @ (Data.Complex.Complex a)
                      $dElt4
                      $dIsProduct
                      $dElt3
                      (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                        `cast`
                      (Data.Array.Accelerate.Product.TupleIdx
                         (Trans
                              (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                        <a>_N <a>_N))
                              (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                        <a>_N)))
                         <a>_N)_R
                      eta)
                     `cast`
                   (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                   (Data.Array.Accelerate.Smart.Prj
                      @ Data.Array.Accelerate.Smart.Acc
                      @ Data.Array.Accelerate.Smart.Exp
                      @ a
                      @ (Data.Complex.Complex a)
                      $dElt4
                      $dIsProduct
                      $dElt3
                      (Data.Array.Accelerate.Data.Complex.$fEqComplex2 @ a)
                        `cast`
                      (Data.Array.Accelerate.Product.TupleIdx
                         (Trans
                              (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                        <a>_N <a>_N))
                              (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                        <a>_N)))
                         <a>_N)_R
                      eta)
                     `cast`
                   (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)) -}
0331bdb44c96dd3971fd132130c4c1c5
  polar ::
    Data.Array.Accelerate.Classes.RealFloat.RealFloat a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp (a, a)
  {- Arity: 2,
     Strictness: <L,U(U,U(A,U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)),A,A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)))><L,U>m3,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: Data.Array.Accelerate.Classes.RealFloat.RealFloat a)
                   (w1 :: Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)) ->
                 case Data.Array.Accelerate.Data.Complex.$wpolar
                        @ a
                        w
                        w1 of ww { (#,,#) ww1 ww2 ww3 ->
                 (Data.Array.Accelerate.Smart.Tuple
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ (a, a)
                    ww1
                    ww2
                    ww3)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <(a, a)>_N) }) -}
fc92892f4c4e355c06cd59ba66f08433
  real ::
    Data.Array.Accelerate.Array.Sugar.Elt a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.Exp a
  {- Arity: 2, Strictness: <L,U(U(U,U,U),U,U,U,U,U,U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Data.Complex.real1
                  `cast`
                (forall (a :: <*>_N).
                 <Data.Array.Accelerate.Array.Sugar.Elt a>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N) -}
cc956717cdec9f5d337eee82127c0ff5
  real1 ::
    Data.Array.Accelerate.Array.Sugar.Elt a =>
    Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc Data.Array.Accelerate.Smart.Exp a
  {- Arity: 2, Strictness: <L,U(U(U,U,U),U,U,U,U,U,U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt a)
                   (c :: Data.Array.Accelerate.Smart.Exp (Data.Complex.Complex a)) ->
                 Data.Array.Accelerate.Smart.Prj
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ a
                   @ (Data.Complex.Complex a)
                   (Data.Array.Accelerate.Data.Complex.$fEltComplex @ a $dElt)
                   (Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
                      @ Data.Array.Accelerate.Array.Sugar.Elt
                      @ a
                      $dElt)
                   $dElt
                   (Data.Array.Accelerate.Data.Complex.$fEqComplex2 @ a)
                     `cast`
                   (Data.Array.Accelerate.Product.TupleIdx
                      (Trans
                           (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                     <a>_N <a>_N))
                           (Sym (Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex[0]
                                     <a>_N)))
                      <a>_N)_R
                   c) -}
instance Data.Array.Accelerate.Array.Sugar.Elt [Data.Complex.Complex]
  = Data.Array.Accelerate.Data.Complex.$fEltComplex
instance Data.Array.Accelerate.Classes.Eq.Eq [Data.Complex.Complex]
  = Data.Array.Accelerate.Data.Complex.$fEqComplex
instance GHC.Float.Floating [Data.Array.Accelerate.Smart.Exp]
  = Data.Array.Accelerate.Data.Complex.$fFloatingExp
instance GHC.Real.Fractional [Data.Array.Accelerate.Smart.Exp]
  = Data.Array.Accelerate.Data.Complex.$fFractionalExp
instance Data.Array.Accelerate.Classes.FromIntegral.FromIntegral [.,
                                                                  Data.Complex.Complex]
  = Data.Array.Accelerate.Data.Complex.$fFromIntegralaComplex
instance Data.Array.Accelerate.Product.IsProduct [.,
                                                  Data.Complex.Complex]
  = Data.Array.Accelerate.Data.Complex.$fIsProductcstComplex
instance Data.Array.Accelerate.Lift.Lift [Data.Array.Accelerate.Smart.Exp,
                                          Data.Complex.Complex]
  = Data.Array.Accelerate.Data.Complex.$fLiftExpComplex
instance GHC.Num.Num [Data.Array.Accelerate.Smart.Exp]
  = Data.Array.Accelerate.Data.Complex.$fNumExp
instance Data.Array.Accelerate.Lift.Unlift [Data.Array.Accelerate.Smart.Exp,
                                            Data.Complex.Complex]
  = Data.Array.Accelerate.Data.Complex.$fUnliftExpComplex
family instance Data.Array.Accelerate.Array.Sugar.EltRepr [Data.Complex.Complex]
  = Data.Array.Accelerate.Data.Complex.D:R:EltReprComplex
family instance Data.Array.Accelerate.Lift.Plain [Data.Complex.Complex]
  = Data.Array.Accelerate.Data.Complex.D:R:PlainComplex
family instance Data.Array.Accelerate.Product.ProdRepr [Data.Complex.Complex]
  = Data.Array.Accelerate.Data.Complex.D:R:ProdReprComplex
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

