
==================== FINAL INTERFACE ====================
2017-08-29 05:27:47.934858 UTC

interface accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Language 8002
  interface hash: 2a72014c57ce30b20aef401e80f1ad07
  ABI hash: 524bed6c61291389f36fc32a525eca39
  export-list hash: a284cd1d10aeff227064b59c0864f9a0
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: cb1cc85827f88ae1250d733c7e73e62f
  sig of: Nothing
  used TH splices: False
  where
exports:
  Data.Array.Accelerate.Language.!
  Data.Array.Accelerate.Language.!!
  Data.Array.Accelerate.Language.>->
  Data.Array.Accelerate.Language.^
  Data.Array.Accelerate.Language.^^
  Data.Array.Accelerate.Language.acond
  Data.Array.Accelerate.Language.awhile
  Data.Array.Accelerate.Language.backpermute
  Data.Array.Accelerate.Language.bitcast
  Data.Array.Accelerate.Language.boolToInt
  Data.Array.Accelerate.Language.chr
  Data.Array.Accelerate.Language.clamp
  Data.Array.Accelerate.Language.cond
  Data.Array.Accelerate.Language.even
  Data.Array.Accelerate.Language.fold
  Data.Array.Accelerate.Language.fold1
  Data.Array.Accelerate.Language.fold1Seg
  Data.Array.Accelerate.Language.foldSeg
  Data.Array.Accelerate.Language.foreignAcc
  Data.Array.Accelerate.Language.foreignExp
  Data.Array.Accelerate.Language.fromIndex
  Data.Array.Accelerate.Language.function
  Data.Array.Accelerate.Language.gcd
  Data.Array.Accelerate.Language.generate
  Data.Array.Accelerate.Language.ignore
  Data.Array.Accelerate.Language.indexHead
  Data.Array.Accelerate.Language.indexTail
  Data.Array.Accelerate.Language.intersect
  Data.Array.Accelerate.Language.lcm
  Data.Array.Accelerate.Language.map
  Data.Array.Accelerate.Language.mirror
  Data.Array.Accelerate.Language.odd
  Data.Array.Accelerate.Language.ord
  Data.Array.Accelerate.Language.permute
  Data.Array.Accelerate.Language.replicate
  Data.Array.Accelerate.Language.reshape
  Data.Array.Accelerate.Language.scanl
  Data.Array.Accelerate.Language.scanl'
  Data.Array.Accelerate.Language.scanl1
  Data.Array.Accelerate.Language.scanr
  Data.Array.Accelerate.Language.scanr'
  Data.Array.Accelerate.Language.scanr1
  Data.Array.Accelerate.Language.shape
  Data.Array.Accelerate.Language.shapeSize
  Data.Array.Accelerate.Language.size
  Data.Array.Accelerate.Language.slice
  Data.Array.Accelerate.Language.stencil
  Data.Array.Accelerate.Language.stencil2
  Data.Array.Accelerate.Language.subtract
  Data.Array.Accelerate.Language.toIndex
  Data.Array.Accelerate.Language.union
  Data.Array.Accelerate.Language.unit
  Data.Array.Accelerate.Language.use
  Data.Array.Accelerate.Language.while
  Data.Array.Accelerate.Language.wrap
  Data.Array.Accelerate.Language.zipWith
  Data.Array.Accelerate.Smart.constant
  Data.Array.Accelerate.Language.Stencil3
  Data.Array.Accelerate.Language.Stencil3x3
  Data.Array.Accelerate.Language.Stencil3x3x3
  Data.Array.Accelerate.Language.Stencil3x3x5
  Data.Array.Accelerate.Language.Stencil3x5
  Data.Array.Accelerate.Language.Stencil3x5x3
  Data.Array.Accelerate.Language.Stencil3x5x5
  Data.Array.Accelerate.Language.Stencil5
  Data.Array.Accelerate.Language.Stencil5x3
  Data.Array.Accelerate.Language.Stencil5x3x3
  Data.Array.Accelerate.Language.Stencil5x3x5
  Data.Array.Accelerate.Language.Stencil5x5
  Data.Array.Accelerate.Language.Stencil5x5x3
  Data.Array.Accelerate.Language.Stencil5x5x5
  Data.Array.Accelerate.Language.Stencil7
  Data.Array.Accelerate.Language.Stencil9
  Data.Array.Accelerate.Smart.Acc
  Data.Array.Accelerate.Smart.Boundary
  Data.Array.Accelerate.Smart.Exp
  Data.Array.Accelerate.Smart.Stencil
module dependencies: Data.Array.Accelerate.AST
                     Data.Array.Accelerate.Array.Data
                     Data.Array.Accelerate.Array.Representation
                     Data.Array.Accelerate.Array.Sugar
                     Data.Array.Accelerate.Array.Unique
                     Data.Array.Accelerate.Classes.Enum Data.Array.Accelerate.Classes.Eq
                     Data.Array.Accelerate.Classes.Fractional
                     Data.Array.Accelerate.Classes.Integral
                     Data.Array.Accelerate.Classes.Num Data.Array.Accelerate.Classes.Ord
                     Data.Array.Accelerate.Classes.Real
                     Data.Array.Accelerate.Debug.Flags
                     Data.Array.Accelerate.Debug.Monitoring
                     Data.Array.Accelerate.Debug.Trace Data.Array.Accelerate.Error
                     Data.Array.Accelerate.Lifetime Data.Array.Accelerate.Product
                     Data.Array.Accelerate.Smart Data.Array.Accelerate.Type
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.1.0
                      base-orphans-0.6@base-orphans-0.6-AbJ3lKVXygDCG0eeQEv8Iu
                      binary-0.8.3.0@binary-0.8.3.0
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0
                      fclabels-2.0.3.2@fclabels-2.0.3.2-4EezQlp7n1w9uoh5Y3yxAt
                      ghc-boot-th-8.0.2@ghc-boot-th-8.0.2 ghc-prim-0.5.0.0
                      hashable-1.2.6.1@hashable-1.2.6.1-2ZLNuHq395GGIHwEHuqZol
                      integer-gmp-1.0.0.1 pretty-1.1.3.3@pretty-1.1.3.3
                      template-haskell-2.11.1.0
                      text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00
                      unique-0@unique-0-9CJQKYGbqiDaFUmoekKeA
orphans: accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.Enum
         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.Eq
         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.Fractional
         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.Integral
         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.Num
         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.Ord
         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.Real
         base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         base-orphans-0.6@base-orphans-0.6-AbJ3lKVXygDCG0eeQEv8Iu:Data.Orphans
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
         fclabels-2.0.3.2@fclabels-2.0.3.2-4EezQlp7n1w9uoh5Y3yxAt:Data.Label.Point
         hashable-1.2.6.1@hashable-1.2.6.1-2ZLNuHq395GGIHwEHuqZol:Data.Hashable.Generic
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Lazy
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Show
family instance modules: accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Array.Data
                         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Array.Representation
                         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Array.Sugar
                         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Product
                         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Smart
                         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Type
                         base-4.9.1.0:Control.Applicative base-4.9.1.0:Data.Complex
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Compose
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.Functor.Product base-4.9.1.0:Data.Functor.Sum
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         ghc-boot-th-8.0.2@ghc-boot-th-8.0.2:GHC.LanguageExtensions.Type
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.HughesPJ
                         template-haskell-2.11.1.0:Language.Haskell.TH.Syntax
                         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text
                         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Lazy
import  -/  Data.Array.Accelerate.Array.Sugar 1095a84a969562bd64b7800341e0d23c
  exports: a6dd551b39ab2a3a217fc8c2a6979cd5
  :. 78f23e81404aaf1e43268a71a575425c
  Array 78f23e81404aaf1e43268a71a575425c
  Arrays 3cc6db7d6b3c36ee0c840e1566f75d38
  Elt 78f23e81404aaf1e43268a71a575425c
  Foreign 2d363443f4f8396630ebdd68ab1f2543
  FullShape b7faae048fa0a842f86460a6c84a131d
  Scalar 78f23e81404aaf1e43268a71a575425c
  Segments 1aaba37901236c62a5f4ce21960ed8e9
  Shape 78f23e81404aaf1e43268a71a575425c
  Slice 78f23e81404aaf1e43268a71a575425c
  SliceShape bd501b3c0eaee4d3c0c33e67a5d6690a
  ignore 273f2be4096da6a39b0f035cf17a0f03
import  -/  Data.Array.Accelerate.Classes.Eq b5abcb6d2b1b2f77926ba32e74c56bfd
  exports: 6d08b503170f674ec3fef36c5a59035f
  /= bfd246b5fc13bff4fe92c8890493d0d4
  == 373f16d63bf36dcf6c5be36579a78740
  || 385cac0096364cd1168d80272fce6db4
import  -/  Data.Array.Accelerate.Classes.Fractional 74c1164036fe4be54acc34add9158746
  exports: 880c91e8ac0c615b5198682ab744764f
  Fractional 6f99f01ef298935759845630a1e863d2
import  -/  Data.Array.Accelerate.Classes.Integral a60aaecd6e207deee19ca96483ccfae0
  exports: bc100fffba1159ea81ec5fb738bd1c61
  Integral a4731d1481a3ada4e7f0f61536fc3d73
import  -/  Data.Array.Accelerate.Classes.Num 5830cb8ce2e6617e88ff07c7f188117f
  exports: 00b7c9e56019df3c44ef51ed8ebd4236
  Num 13b6af1dd60ee5505ca10fef83916e95
import  -/  Data.Array.Accelerate.Classes.Ord 838718467444fc3520e0ce057ae54e2a
  exports: 73bb94b1a06727c01aa4a74d6dab52ae
  <= 18b2f445721b05c9c734aa0fa453ef9d
  >= 32c65a49eff2528ed35f750a60be2b01
import  -/  Data.Array.Accelerate.Smart c6a471aeed497009ce791e94dc05d100
  exports: 1e3a20050ce25466608a82a26d24d5f0
  $$ 4e666b7ab0aca7a12bbbe02f2261937c
  $$$ 4f6917b3080b09a726160e72a6fc06af
  $$$$ be3e6d4c5cac2ed32d602872601f25c4
  Acc 4a164f5e174079736ad2d5fe6620f3ae
  Acc dff601899922d9e86e5ab6941dfbac5f
  Acond 1f46b8659b8858228bc976e8ddccd16d
  Aforeign a0f9d770c77b06425e0ebe709581fbb9
  Awhile c8105d184eeabd25a132bc012affd004
  Backpermute 0ff8597c27f580824016f0f72ffcd035
  Boundary 5a132084444556b45945e309c14326c0
  Boundary 60020c1f9d8d102ec6cebfc89294e4f2
  Clamp f6cd9b1637b002a73502a2d0202cb3ed
  Cond 4628c12b51c834347b1c399b590eac59
  Exp 2fd934232a7ed8f151cd01d9504e7b9f
  Exp dff601899922d9e86e5ab6941dfbac5f
  Fold 4208a2ab124e96cd8753f60366f41435
  Fold1 582c997327b9340df6ef912bfaa1c84a
  Fold1Seg 98512b552e2cf2b36570daf816bf3c91
  FoldSeg 0c138273c3ff338784d416078e6cfc84
  Foreign 7136ca05e947b0e73597810ce09cc8f7
  FromIndex 57562549b71f62a1ac9db4be9177ca63
  Function 996d7382fc5ec29fd9f2fb15a32925d4
  Generate afe3516c724a80fe5a3154bf64a85f82
  Index eee4c69772eb20abfa2354224c1cf803
  IndexHead a3dcf1c37cc1041b1d46d74292b92f3c
  IndexTail 012019a307d07ab5e2f2dd4fe141658c
  Intersect 800043d747c4cb12272b7af51ba022c8
  LinearIndex 97db30a134eadf78bc5d366b6002b044
  Map abe29321659061f4e44a3fc91b038f4b
  Mirror 4abcfe839571340865dd2eec73f37073
  Permute 35cd9489778ef203ff30f00a5b09e3d4
  Pipe 64db37be62324623ceb32890015f8ed7
  Replicate 9e1d2fc0343423f1e86df4c365e83616
  Reshape 3ec2cd19d0a147b57ae6902ddec3685b
  Scanl 4c1edf31dc45b07d2b60ba1eadaf0623
  Scanl' bea8dca1fee4008016a91f77113793ff
  Scanl1 2289844b50a8be3060fcfe7faa4ad0e0
  Scanr 0f6842b0e29995092cef54d232f5dfd9
  Scanr' 3c92a034a1165eefdcc4ff24a09c3af1
  Scanr1 7b59b540aa797fe9e56db3254d857c11
  Shape e23aa05dcaf566623d034b4d3f2790ec
  ShapeSize 78fd09917250e4dac01bded99dbba41f
  Slice f8ce11da95bb3bb50f406603f6181a4e
  Stencil ac40c388323d5f1a5c911217a0e5f37a
  Stencil dff601899922d9e86e5ab6941dfbac5f
  Stencil2 7d100851ff73a197e0f3904146d9427d
  ToIndex 29c696db6a0470459a6e9071cbf64f93
  Union 46c521b8b314eb58ceaab3dbbcb6caec
  Unit b2c96fa4340cdfaf589d4ac7b8963cf2
  Use 53e7f68a57506a8f88e3b18e8730b626
  While cfa001692d2530a211574d427e1300f3
  Wrap e3f6d61f066455bed8bf0f06aed9b8ed
  ZipWith 6a5445d8dc6243d6471c9223e905f61d
  constant 8196d527ad9044191643ad6b39858685
  mkBitcast 4acd76684d80054c2819dda281e05aef
  mkBoolToInt 0d2c56676cef32112943caf6c8229e79
  mkChr bafb800e8064383ab075b09ec849a670
  mkOrd ae821be81de92b71d2b52341eb0a4daf
  tup2 c501dd227fe5d3d61a446c8db6829c7a
  tup3 ebdb68a7e81c25436d21dfab0bff78b9
  untup2 751a423afd0ba14775d3a5cf0fe0a975
  untup3 a872de1aa1e286d98d4e71dcdc0df473
import  -/  Data.Array.Accelerate.Type a1c7885f4a79193eaa1f192a9acbec78
  exports: 7aad7ca015788892b1349ebab929b71f
  BitSizeEq 08b339c5e1c2596f47bb59a6ee6c7358
  IsIntegral b2c4f7b6108c37809735ca127f59a1fe
  IsScalar b39315a91b81ff18413f7fb7d8fed68c
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Real 82e4e59051a13dba1da63e1e970a69e6
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
fixities infixl 9 !, infixl 9 !!, infixl 1 >->, infixr 8 ^,
         infixr 8 ^^
61a5eca2e09125cbeec78774e75ee661
  (!) ::
    (Data.Array.Accelerate.Array.Sugar.Shape sh,
     Data.Array.Accelerate.Array.Sugar.Elt e) =>
    Data.Array.Accelerate.Smart.Acc
      (Data.Array.Accelerate.Array.Sugar.Array sh e)
    -> Data.Array.Accelerate.Smart.Exp sh
    -> Data.Array.Accelerate.Smart.Exp e
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(U,U,U,U(U),U(U),U(U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U><L,U>,
     Unfolding: (\ @ sh
                   @ e
                   ($dShape :: Data.Array.Accelerate.Array.Sugar.Shape sh)
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt e)
                   (eta :: Data.Array.Accelerate.Smart.Acc
                             (Data.Array.Accelerate.Array.Sugar.Array sh e))
                   (eta1 :: Data.Array.Accelerate.Smart.Exp sh) ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh>_N <sh>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh>_N <sh>_N) of cobox2 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.Index
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ e
                    @ sh
                    $dShape
                    $dElt
                    eta
                    eta1)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <e>_N) } } }) -}
2329cbea8fc5fdeb4358f74748c43618
  (!!) ::
    (Data.Array.Accelerate.Array.Sugar.Shape sh,
     Data.Array.Accelerate.Array.Sugar.Elt e) =>
    Data.Array.Accelerate.Smart.Acc
      (Data.Array.Accelerate.Array.Sugar.Array sh e)
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Int
    -> Data.Array.Accelerate.Smart.Exp e
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(U,U,U,U(U),U(U),U(U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U><L,U>,
     Unfolding: (\ @ sh
                   @ e
                   ($dShape :: Data.Array.Accelerate.Array.Sugar.Shape sh)
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt e)
                   (eta :: Data.Array.Accelerate.Smart.Acc
                             (Data.Array.Accelerate.Array.Sugar.Array sh e))
                   (eta1 :: Data.Array.Accelerate.Smart.Exp GHC.Types.Int) ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh>_N <sh>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh>_N <sh>_N) of cobox2 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.LinearIndex
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ e
                    @ sh
                    $dShape
                    $dElt
                    eta
                    eta1)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <e>_N) } } }) -}
d6082afbff7099fcacbd855132062a5a
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Data.Array.Accelerate.Language.$trModule2
                   Data.Array.Accelerate.Language.$trModule1) -}
9ce455c3847181b730779b8bd5984338
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Data.Array.Accelerate.Language"#) -}
67e072c38076106f4212edcaa27337cb
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw"#) -}
6a8d228d2095036f990a63307417a1b1
  $w^^ ::
    (Data.Array.Accelerate.Classes.Fractional.Fractional a,
     Data.Array.Accelerate.Classes.Integral.Integral b) =>
    Data.Array.Accelerate.Smart.Exp a
    -> Data.Array.Accelerate.Smart.Exp b
    -> (# Data.Array.Accelerate.Array.Sugar.Elt a,
          Data.Array.Accelerate.Smart.Exp GHC.Types.Bool,
          Data.Array.Accelerate.Smart.Exp a,
          Data.Array.Accelerate.Smart.Exp a #)
  {- Arity: 4,
     Strictness: <L,U(1*U,1*U(A,A,1*C1(U),A))><L,U(A,U(U,U(U(U,U,U),U,U,U,U,U,U),U),U)><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: Data.Array.Accelerate.Classes.Fractional.Fractional a)
                   (w1 :: Data.Array.Accelerate.Classes.Integral.Integral b)
                   (w2 :: Data.Array.Accelerate.Smart.Exp a)
                   (w3 :: Data.Array.Accelerate.Smart.Exp b) ->
                 let {
                   $d(%,%) :: Data.Array.Accelerate.Classes.Num.Num a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (GHC.Real.Fractional (Data.Array.Accelerate.Smart.Exp a))
                       w
                 } in
                 let {
                   $dIntegral :: GHC.Real.Integral (Data.Array.Accelerate.Smart.Exp b)
                   = GHC.Classes.$p3(%,,%)
                       @ (Data.Array.Accelerate.Classes.Enum.Enum b)
                       @ (Data.Array.Accelerate.Classes.Real.Real b)
                       @ (GHC.Real.Integral (Data.Array.Accelerate.Smart.Exp b))
                       w1
                 } in
                 let {
                   $dReal :: GHC.Real.Real (Data.Array.Accelerate.Smart.Exp b)
                   = GHC.Real.$p1Integral
                       @ (Data.Array.Accelerate.Smart.Exp b)
                       $dIntegral
                 } in
                 let {
                   $dNum :: GHC.Num.Num (Data.Array.Accelerate.Smart.Exp b)
                   = GHC.Real.$p1Real @ (Data.Array.Accelerate.Smart.Exp b) $dReal
                 } in
                 (# GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                      $d(%,%),
                    Data.Array.Accelerate.Classes.Ord.>=
                      @ b
                      (GHC.Classes.$p2(%,,%)
                         @ (Data.Array.Accelerate.Classes.Num.Num b)
                         @ (Data.Array.Accelerate.Classes.Ord.Ord b)
                         @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp b))
                         (GHC.Classes.$p2(%,,%)
                            @ (Data.Array.Accelerate.Classes.Enum.Enum b)
                            @ (Data.Array.Accelerate.Classes.Real.Real b)
                            @ (GHC.Real.Integral (Data.Array.Accelerate.Smart.Exp b))
                            w1))
                      w3
                      (GHC.Num.fromInteger
                         @ (Data.Array.Accelerate.Smart.Exp b)
                         $dNum
                         Data.Array.Accelerate.Language.^^1),
                    Data.Array.Accelerate.Language.^ @ a @ b $d(%,%) w1 w2 w3,
                    GHC.Real.recip
                      @ (Data.Array.Accelerate.Smart.Exp a)
                      (GHC.Classes.$p2(%,%)
                         @ (Data.Array.Accelerate.Classes.Num.Num a)
                         @ (GHC.Real.Fractional (Data.Array.Accelerate.Smart.Exp a))
                         w)
                      (Data.Array.Accelerate.Language.^
                         @ a
                         @ b
                         $d(%,%)
                         w1
                         w2
                         (GHC.Num.negate
                            @ (Data.Array.Accelerate.Smart.Exp b)
                            $dNum
                            w3)) #)) -}
a1370560e2e31bf7618a1a614b67be31
  $wignore ::
    Data.Array.Accelerate.Array.Sugar.Shape sh =>
    (# Data.Array.Accelerate.Array.Sugar.Elt sh, sh #)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(1*U,A,A,1*U(1*U),1*U(1*U),1*U(1*U),A,A,A,1*U,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Inline: [0],
     Unfolding: (\ @ sh
                   (w :: Data.Array.Accelerate.Array.Sugar.Shape sh) ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh w)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh w)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh>_N <sh>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh w)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh>_N <sh>_N) of cobox2 { DEFAULT ->
                 (# Data.Array.Accelerate.Array.Sugar.$p1Shape @ sh w,
                    Data.Array.Accelerate.Array.Sugar.ignore @ sh w #) } } }) -}
e9af3a0101d436826a331cd6fd8e323a
  $wlcm ::
    Data.Array.Accelerate.Classes.Integral.Integral a =>
    Data.Array.Accelerate.Smart.Exp a
    -> Data.Array.Accelerate.Smart.Exp a
    -> (# Data.Array.Accelerate.Array.Sugar.Elt a,
          Data.Array.Accelerate.Smart.Exp GHC.Types.Bool,
          Data.Array.Accelerate.Smart.Exp a,
          Data.Array.Accelerate.Smart.Exp a #)
  {- Arity: 3, Strictness: <L,U(A,U,U)><L,U><L,U>, Inline: [0],
     Unfolding: (\ @ a
                   (w :: Data.Array.Accelerate.Classes.Integral.Integral a)
                   (w1 :: Data.Array.Accelerate.Smart.Exp a)
                   (w2 :: Data.Array.Accelerate.Smart.Exp a) ->
                 let {
                   $dIntegral :: GHC.Real.Integral (Data.Array.Accelerate.Smart.Exp a)
                   = GHC.Classes.$p3(%,,%)
                       @ (Data.Array.Accelerate.Classes.Enum.Enum a)
                       @ (Data.Array.Accelerate.Classes.Real.Real a)
                       @ (GHC.Real.Integral (Data.Array.Accelerate.Smart.Exp a))
                       w
                 } in
                 let {
                   $dReal :: GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a)
                   = GHC.Real.$p1Integral
                       @ (Data.Array.Accelerate.Smart.Exp a)
                       $dIntegral
                 } in
                 let {
                   $dNum :: GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a)
                   = GHC.Real.$p1Real @ (Data.Array.Accelerate.Smart.Exp a) $dReal
                 } in
                 let {
                   $d(%,,%) :: Data.Array.Accelerate.Classes.Real.Real a
                   = GHC.Classes.$p2(%,,%)
                       @ (Data.Array.Accelerate.Classes.Enum.Enum a)
                       @ (Data.Array.Accelerate.Classes.Real.Real a)
                       @ (GHC.Real.Integral (Data.Array.Accelerate.Smart.Exp a))
                       w
                 } in
                 (# GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                      (GHC.Classes.$p1(%,,%)
                         @ (Data.Array.Accelerate.Classes.Num.Num a)
                         @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                         @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                         $d(%,,%)),
                    (Data.Array.Accelerate.Smart.PrimApp
                       @ Data.Array.Accelerate.Smart.Acc
                       @ Data.Array.Accelerate.Smart.Exp
                       @ GHC.Types.Bool
                       @ (GHC.Types.Bool, GHC.Types.Bool)
                       Data.Array.Accelerate.Smart.$s$fElt(,)
                       Data.Array.Accelerate.Array.Sugar.$fEltBool
                       Data.Array.Accelerate.AST.$WPrimLOr
                       (Data.Array.Accelerate.Smart.Tuple
                          @ Data.Array.Accelerate.Smart.Acc
                          @ Data.Array.Accelerate.Smart.Exp
                          @ (GHC.Types.Bool, GHC.Types.Bool)
                          Data.Array.Accelerate.Smart.$s$fElt(,)
                          Data.Array.Accelerate.Smart.$s$fIsProductcst(,)
                          (let {
                             $dEq :: Data.Array.Accelerate.Classes.Ord.Ord a
                             = GHC.Classes.$p2(%,,%)
                                 @ (Data.Array.Accelerate.Classes.Num.Num a)
                                 @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                                 @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                                 $d(%,,%)
                           } in
                           let {
                             $dEq1 :: Data.Array.Accelerate.Classes.Eq.Eq a
                             = Data.Array.Accelerate.Classes.Ord.$p1Ord @ a $dEq
                           } in
                           (Data.Array.Accelerate.Array.Sugar.SnocTup
                              @ Data.Array.Accelerate.Smart.Exp
                              @ (((), GHC.Types.Bool), GHC.Types.Bool)
                              @ GHC.Types.Bool
                              @ ((), GHC.Types.Bool)
                              @~ <(((), GHC.Types.Bool), GHC.Types.Bool)>_N
                              Data.Array.Accelerate.Array.Sugar.$fEltBool
                              (Data.Array.Accelerate.Array.Sugar.SnocTup
                                 @ Data.Array.Accelerate.Smart.Exp
                                 @ ((), GHC.Types.Bool)
                                 @ GHC.Types.Bool
                                 @ ()
                                 @~ <((), GHC.Types.Bool)>_N
                                 Data.Array.Accelerate.Array.Sugar.$fEltBool
                                 (Data.Array.Accelerate.Array.Sugar.$WNilTup
                                    @ Data.Array.Accelerate.Smart.Exp)
                                 (Data.Array.Accelerate.Classes.Eq.==
                                    @ a
                                    $dEq1
                                    w1
                                    (GHC.Num.fromInteger
                                       @ (Data.Array.Accelerate.Smart.Exp a)
                                       $dNum
                                       Data.Array.Accelerate.Language.^^1)))
                              (Data.Array.Accelerate.Classes.Eq.==
                                 @ a
                                 $dEq1
                                 w2
                                 (GHC.Num.fromInteger
                                    @ (Data.Array.Accelerate.Smart.Exp a)
                                    $dNum
                                    Data.Array.Accelerate.Language.^^1)))
                             `cast`
                           (Data.Array.Accelerate.Array.Sugar.Tuple
                              <Data.Array.Accelerate.Smart.Exp>_R
                              (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                        <GHC.Types.Bool>_N <GHC.Types.Bool>_N)))_R))
                         `cast`
                       (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <(GHC.Types.Bool,
                                                                     GHC.Types.Bool)>_N))
                      `cast`
                    (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Bool>_N),
                    GHC.Num.fromInteger
                      @ (Data.Array.Accelerate.Smart.Exp a)
                      $dNum
                      Data.Array.Accelerate.Language.^^1,
                    GHC.Num.abs
                      @ (Data.Array.Accelerate.Smart.Exp a)
                      $dNum
                      (GHC.Num.*
                         @ (Data.Array.Accelerate.Smart.Exp a)
                         $dNum
                         (GHC.Real.quot
                            @ (Data.Array.Accelerate.Smart.Exp a)
                            $dIntegral
                            w1
                            (Data.Array.Accelerate.Language.gcd @ a w w1 w2))
                         w2) #)) -}
805f0d5dec4a134b9950ec24bac12f5e
  (>->) ::
    (Data.Array.Accelerate.Array.Sugar.Arrays a,
     Data.Array.Accelerate.Array.Sugar.Arrays b,
     Data.Array.Accelerate.Array.Sugar.Arrays c) =>
    (Data.Array.Accelerate.Smart.Acc a
     -> Data.Array.Accelerate.Smart.Acc b)
    -> (Data.Array.Accelerate.Smart.Acc b
        -> Data.Array.Accelerate.Smart.Acc c)
    -> Data.Array.Accelerate.Smart.Acc a
    -> Data.Array.Accelerate.Smart.Acc c
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,U><L,U><L,U><L,U><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Language.>->1
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                 <Data.Array.Accelerate.Array.Sugar.Arrays a>_R
                 ->_R <Data.Array.Accelerate.Array.Sugar.Arrays b>_R
                 ->_R <Data.Array.Accelerate.Array.Sugar.Arrays c>_R
                 ->_R <Data.Array.Accelerate.Smart.Acc a
                       -> Data.Array.Accelerate.Smart.Acc b>_R
                 ->_R <Data.Array.Accelerate.Smart.Acc b
                       -> Data.Array.Accelerate.Smart.Acc c>_R
                 ->_R <Data.Array.Accelerate.Smart.Acc a>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Acc[0]) <c>_N) -}
1694de086b7f8290e631b885c91bfc23
  >->1 ::
    (Data.Array.Accelerate.Array.Sugar.Arrays a,
     Data.Array.Accelerate.Array.Sugar.Arrays b,
     Data.Array.Accelerate.Array.Sugar.Arrays c) =>
    (Data.Array.Accelerate.Smart.Acc a
     -> Data.Array.Accelerate.Smart.Acc b)
    -> (Data.Array.Accelerate.Smart.Acc b
        -> Data.Array.Accelerate.Smart.Acc c)
    -> Data.Array.Accelerate.Smart.Acc a
    -> Data.Array.Accelerate.Smart.PreAcc
         Data.Array.Accelerate.Smart.Acc Data.Array.Accelerate.Smart.Exp c
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,U><L,U><L,U><L,U><L,U><L,U>,
     Unfolding: InlineRule (6, True, True)
                (\ @ a
                   @ b
                   @ c
                   ($dArrays :: Data.Array.Accelerate.Array.Sugar.Arrays a)
                   ($dArrays1 :: Data.Array.Accelerate.Array.Sugar.Arrays b)
                   ($dArrays2 :: Data.Array.Accelerate.Array.Sugar.Arrays c)
                   (eta :: Data.Array.Accelerate.Smart.Acc a
                           -> Data.Array.Accelerate.Smart.Acc b)
                   (eta1 :: Data.Array.Accelerate.Smart.Acc b
                            -> Data.Array.Accelerate.Smart.Acc c)
                   (eta2 :: Data.Array.Accelerate.Smart.Acc a) ->
                 Data.Array.Accelerate.Smart.Pipe
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ c
                   @ a
                   @ b
                   $dArrays
                   $dArrays1
                   $dArrays2
                   eta
                   eta1
                   eta2) -}
2ff77bff99da69ebf0db26ab043517d0
  type Stencil3 a =
    (Data.Array.Accelerate.Smart.Exp a,
     Data.Array.Accelerate.Smart.Exp a,
     Data.Array.Accelerate.Smart.Exp a)
9ce51099dcf85a5a16faf297c3980fd8
  type Stencil3x3 a =
    (Data.Array.Accelerate.Language.Stencil3 a,
     Data.Array.Accelerate.Language.Stencil3 a,
     Data.Array.Accelerate.Language.Stencil3 a)
e8b2a890a6568141be93d7e8411d2974
  type Stencil3x3x3 a =
    (Data.Array.Accelerate.Language.Stencil3x3 a,
     Data.Array.Accelerate.Language.Stencil3x3 a,
     Data.Array.Accelerate.Language.Stencil3x3 a)
c5128b38c453c7e6872fa7d9adafa9ca
  type Stencil3x3x5 a =
    (Data.Array.Accelerate.Language.Stencil3x3 a,
     Data.Array.Accelerate.Language.Stencil3x3 a,
     Data.Array.Accelerate.Language.Stencil3x3 a,
     Data.Array.Accelerate.Language.Stencil3x3 a,
     Data.Array.Accelerate.Language.Stencil3x3 a)
3aa660b81ae6161d447b1dd470b9eaec
  type Stencil3x5 a =
    (Data.Array.Accelerate.Language.Stencil3 a,
     Data.Array.Accelerate.Language.Stencil3 a,
     Data.Array.Accelerate.Language.Stencil3 a,
     Data.Array.Accelerate.Language.Stencil3 a,
     Data.Array.Accelerate.Language.Stencil3 a)
4f2e9d3a8af0265453a89778dcfc6d37
  type Stencil3x5x3 a =
    (Data.Array.Accelerate.Language.Stencil3x5 a,
     Data.Array.Accelerate.Language.Stencil3x5 a,
     Data.Array.Accelerate.Language.Stencil3x5 a)
07dcd2fa44f5cff363cc834286629fa0
  type Stencil3x5x5 a =
    (Data.Array.Accelerate.Language.Stencil3x5 a,
     Data.Array.Accelerate.Language.Stencil3x5 a,
     Data.Array.Accelerate.Language.Stencil3x5 a,
     Data.Array.Accelerate.Language.Stencil3x5 a,
     Data.Array.Accelerate.Language.Stencil3x5 a)
cfb2b2e03cc793dd94d4ad908cdf4b44
  type Stencil5 a =
    (Data.Array.Accelerate.Smart.Exp a,
     Data.Array.Accelerate.Smart.Exp a,
     Data.Array.Accelerate.Smart.Exp a,
     Data.Array.Accelerate.Smart.Exp a,
     Data.Array.Accelerate.Smart.Exp a)
4dc09e241d5106ba355106458136c25b
  type Stencil5x3 a =
    (Data.Array.Accelerate.Language.Stencil5 a,
     Data.Array.Accelerate.Language.Stencil5 a,
     Data.Array.Accelerate.Language.Stencil5 a)
7a6f6d5d0a97126c3aa6ddb37ae31e71
  type Stencil5x3x3 a =
    (Data.Array.Accelerate.Language.Stencil5x3 a,
     Data.Array.Accelerate.Language.Stencil5x3 a,
     Data.Array.Accelerate.Language.Stencil5x3 a)
effc9dc284c596123e4ec55f90dd346f
  type Stencil5x3x5 a =
    (Data.Array.Accelerate.Language.Stencil5x3 a,
     Data.Array.Accelerate.Language.Stencil5x3 a,
     Data.Array.Accelerate.Language.Stencil5x3 a,
     Data.Array.Accelerate.Language.Stencil5x3 a,
     Data.Array.Accelerate.Language.Stencil5x3 a)
7e43c8e9751da0964bca97fcff8c35da
  type Stencil5x5 a =
    (Data.Array.Accelerate.Language.Stencil5 a,
     Data.Array.Accelerate.Language.Stencil5 a,
     Data.Array.Accelerate.Language.Stencil5 a,
     Data.Array.Accelerate.Language.Stencil5 a,
     Data.Array.Accelerate.Language.Stencil5 a)
6b9792aa38374909c261da5184b0a710
  type Stencil5x5x3 a =
    (Data.Array.Accelerate.Language.Stencil5x5 a,
     Data.Array.Accelerate.Language.Stencil5x5 a,
     Data.Array.Accelerate.Language.Stencil5x5 a)
41f4fb384e2b58b23cbbb6d71f9141e8
  type Stencil5x5x5 a =
    (Data.Array.Accelerate.Language.Stencil5x5 a,
     Data.Array.Accelerate.Language.Stencil5x5 a,
     Data.Array.Accelerate.Language.Stencil5x5 a,
     Data.Array.Accelerate.Language.Stencil5x5 a,
     Data.Array.Accelerate.Language.Stencil5x5 a)
9374e6ff1c11873cd0a1b76bc06b1949
  type Stencil7 a =
    (Data.Array.Accelerate.Smart.Exp a,
     Data.Array.Accelerate.Smart.Exp a,
     Data.Array.Accelerate.Smart.Exp a,
     Data.Array.Accelerate.Smart.Exp a,
     Data.Array.Accelerate.Smart.Exp a,
     Data.Array.Accelerate.Smart.Exp a,
     Data.Array.Accelerate.Smart.Exp a)
6283bfdc45a2608e45fba9536e13a30b
  type Stencil9 a =
    (Data.Array.Accelerate.Smart.Exp a,
     Data.Array.Accelerate.Smart.Exp a,
     Data.Array.Accelerate.Smart.Exp a,
     Data.Array.Accelerate.Smart.Exp a,
     Data.Array.Accelerate.Smart.Exp a,
     Data.Array.Accelerate.Smart.Exp a,
     Data.Array.Accelerate.Smart.Exp a,
     Data.Array.Accelerate.Smart.Exp a,
     Data.Array.Accelerate.Smart.Exp a)
a54bbc3965f85840fab0b1ed6b350d59
  (^) ::
    (Data.Array.Accelerate.Classes.Num.Num a,
     Data.Array.Accelerate.Classes.Integral.Integral b) =>
    Data.Array.Accelerate.Smart.Exp a
    -> Data.Array.Accelerate.Smart.Exp b
    -> Data.Array.Accelerate.Smart.Exp a
  {- Arity: 2,
     Strictness: <L,U(1*U,1*U)><L,U(A,U(U,U(U(U,U,U),U,U,U,U,U,U),U),U)> -}
4fbe7719ff71f54768b49d15d246624a
  (^^) ::
    (Data.Array.Accelerate.Classes.Fractional.Fractional a,
     Data.Array.Accelerate.Classes.Integral.Integral b) =>
    Data.Array.Accelerate.Smart.Exp a
    -> Data.Array.Accelerate.Smart.Exp b
    -> Data.Array.Accelerate.Smart.Exp a
  {- Arity: 4,
     Strictness: <L,U(1*U,1*U(A,A,1*C1(U),A))><L,U(A,U(U,U(U(U,U,U),U,U,U,U,U,U),U),U)><L,U><L,U>m12,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   (w :: Data.Array.Accelerate.Classes.Fractional.Fractional a)
                   (w1 :: Data.Array.Accelerate.Classes.Integral.Integral b)
                   (w2 :: Data.Array.Accelerate.Smart.Exp a)
                   (w3 :: Data.Array.Accelerate.Smart.Exp b) ->
                 case Data.Array.Accelerate.Language.$w^^
                        @ a
                        @ b
                        w
                        w1
                        w2
                        w3 of ww { (#,,,#) ww1 ww2 ww3 ww4 ->
                 (Data.Array.Accelerate.Smart.Cond
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ a
                    ww1
                    ww2
                    ww3
                    ww4)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N) }) -}
58e5a6cc35efb1137e2fcea4c9122bdb
  ^^1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (0) -}
650bcaf8acec2f453697c3309fca1bf7
  acond ::
    Data.Array.Accelerate.Array.Sugar.Arrays a =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Bool
    -> Data.Array.Accelerate.Smart.Acc a
    -> Data.Array.Accelerate.Smart.Acc a
    -> Data.Array.Accelerate.Smart.Acc a
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,U><L,U><L,U>m4,
     Unfolding: InlineRule (0, True, True)
                (Data.Array.Accelerate.Smart.Acond
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp)
                  `cast`
                (forall (a :: <*>_N).
                 <Data.Array.Accelerate.Array.Sugar.Arrays a>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Types.Bool>_R
                 ->_R <Data.Array.Accelerate.Smart.Acc a>_R
                 ->_R <Data.Array.Accelerate.Smart.Acc a>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Acc[0]) <a>_N) -}
3c195ea51cd68a323935c560020b3393
  awhile ::
    Data.Array.Accelerate.Array.Sugar.Arrays a =>
    (Data.Array.Accelerate.Smart.Acc a
     -> Data.Array.Accelerate.Smart.Acc
          (Data.Array.Accelerate.Array.Sugar.Scalar GHC.Types.Bool))
    -> (Data.Array.Accelerate.Smart.Acc a
        -> Data.Array.Accelerate.Smart.Acc a)
    -> Data.Array.Accelerate.Smart.Acc a
    -> Data.Array.Accelerate.Smart.Acc a
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,U><L,U><L,U>m5,
     Unfolding: InlineRule (0, True, True)
                (Data.Array.Accelerate.Smart.Awhile
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp)
                  `cast`
                (forall (a :: <*>_N).
                 <Data.Array.Accelerate.Array.Sugar.Arrays a>_R
                 ->_R <Data.Array.Accelerate.Smart.Acc a
                       -> Data.Array.Accelerate.Smart.Acc
                            (Data.Array.Accelerate.Array.Sugar.Scalar GHC.Types.Bool)>_R
                 ->_R <Data.Array.Accelerate.Smart.Acc a
                       -> Data.Array.Accelerate.Smart.Acc a>_R
                 ->_R <Data.Array.Accelerate.Smart.Acc a>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Acc[0]) <a>_N) -}
3d1a826d5049d1c8e8adf20d9962eacc
  backpermute ::
    (Data.Array.Accelerate.Array.Sugar.Shape sh,
     Data.Array.Accelerate.Array.Sugar.Shape sh',
     Data.Array.Accelerate.Array.Sugar.Elt a) =>
    Data.Array.Accelerate.Smart.Exp sh'
    -> (Data.Array.Accelerate.Smart.Exp sh'
        -> Data.Array.Accelerate.Smart.Exp sh)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array sh a)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array sh' a)
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(U,U,U,U(U),U(U),U(U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(U,U,U,U(U),U(U),U(U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U><L,U><L,U>,
     Unfolding: (\ @ sh
                   @ sh'
                   @ a
                   ($dShape :: Data.Array.Accelerate.Array.Sugar.Shape sh)
                   ($dShape1 :: Data.Array.Accelerate.Array.Sugar.Shape sh')
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt a)
                   (eta :: Data.Array.Accelerate.Smart.Exp sh')
                   (eta1 :: Data.Array.Accelerate.Smart.Exp sh'
                            -> Data.Array.Accelerate.Smart.Exp sh)
                   (eta2 :: Data.Array.Accelerate.Smart.Acc
                              (Data.Array.Accelerate.Array.Sugar.Array sh a)) ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh')
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh' $dShape1)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh'>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh')
                        @ sh'
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh' $dShape1)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh'>_N <sh'>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh')
                        @ sh'
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh' $dShape1)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh'>_N <sh'>_N) of cobox2 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox3 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh>_N <sh>_N) of cobox4 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh>_N <sh>_N) of cobox5 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.$WBackpermute
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ sh
                    @ sh'
                    @ a
                    $dShape
                    $dShape1
                    $dElt
                    eta
                    eta1
                    eta2)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Acc[0]) <Data.Array.Accelerate.Array.Sugar.Array
                                                                sh' a>_N) } } } } } }) -}
8d8ec3b064df852c83409b3f2b604c57
  bitcast ::
    (Data.Array.Accelerate.Array.Sugar.Elt a,
     Data.Array.Accelerate.Array.Sugar.Elt b,
     Data.Array.Accelerate.Type.IsScalar a,
     Data.Array.Accelerate.Type.IsScalar b,
     Data.Array.Accelerate.Type.BitSizeEq a b) =>
    Data.Array.Accelerate.Smart.Exp a
    -> Data.Array.Accelerate.Smart.Exp b
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,U><L,U><L,1*U(A,1*U)><L,1*U(A,1*U)><S(S),U(U)><L,U>,
     Unfolding: InlineRule (6, True, False)
                (\ @ a
                   @ b
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt a)
                   ($dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt b)
                   ($dIsScalar :: Data.Array.Accelerate.Type.IsScalar a)
                   ($dIsScalar1 :: Data.Array.Accelerate.Type.IsScalar b)
                   ($d~ :: Data.Array.Accelerate.Type.BitSizeEq a b)
                   (eta :: Data.Array.Accelerate.Smart.Exp a) ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.Bool
                        @ GHC.Types.Bool
                        @ (Data.Array.Accelerate.Type.BitSize a
                           Data.Type.Equality.== Data.Array.Accelerate.Type.BitSize b)
                        @ 'GHC.Types.True
                        $d~
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.Bool>_N <Data.Array.Accelerate.Type.BitSize a
                                                 Data.Type.Equality.== Data.Array.Accelerate.Type.BitSize
                                                                         b>_N <'GHC.Types.True>_N) of cobox0 { DEFAULT ->
                 Data.Array.Accelerate.Smart.mkBitcast
                   @ a
                   @ b
                   $dElt
                   $dElt1
                   $dIsScalar
                   $dIsScalar1
                   $d~
                   eta }) -}
4bf1c91b68a3c5015b836a3acd14bf97
  boolToInt ::
    Data.Array.Accelerate.Smart.Exp GHC.Types.Bool
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Int
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Smart.mkBoolToInt1
                  `cast`
                (<Data.Array.Accelerate.Smart.Exp GHC.Types.Bool>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Int>_N) -}
9c9adc8877aaa47b73a702340a626ac5
  chr ::
    Data.Array.Accelerate.Smart.Exp GHC.Types.Int
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Char
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Smart.mkChr1
                  `cast`
                (<Data.Array.Accelerate.Smart.Exp GHC.Types.Int>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Char>_N) -}
1c331d64ba047a155012403515501394
  clamp ::
    Data.Array.Accelerate.Smart.Boundary
      (Data.Array.Accelerate.Array.Sugar.Array sh e)
  {- HasNoCafRefs,
     Unfolding: InlineRule (0, True, True)
                (\ @ sh @ e ->
                 Data.Array.Accelerate.Smart.Clamp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ (Data.Array.Accelerate.Array.Sugar.Array sh e))
                  `cast`
                (forall (sh :: <GHC.Types.*>_N) (e :: <*>_N).
                 Sym (Data.Array.Accelerate.Smart.N:Boundary[0]) <Data.Array.Accelerate.Array.Sugar.Array
                                                                    sh e>_N) -}
1ad22d0d07dca5cab36a411c4b5a6965
  cond ::
    Data.Array.Accelerate.Array.Sugar.Elt t =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Bool
    -> Data.Array.Accelerate.Smart.Exp t
    -> Data.Array.Accelerate.Smart.Exp t
    -> Data.Array.Accelerate.Smart.Exp t
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,U><L,U><L,U>m12,
     Unfolding: InlineRule (0, True, True)
                (Data.Array.Accelerate.Smart.Cond
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp)
                  `cast`
                (forall (t :: <*>_N).
                 <Data.Array.Accelerate.Array.Sugar.Elt t>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Types.Bool>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp t>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp t>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <t>_N) -}
6c919d80c95baff4f4e1dc3efbae5180
  even ::
    Data.Array.Accelerate.Classes.Integral.Integral a =>
    Data.Array.Accelerate.Smart.Exp a
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS(LS(S(LC(C(S))L)LLLLLL)L)L),U(A,1*U(A,1*U(1*U(A,1*C1(C1(U)),A),A,A,A,A,A,A),A),1*U)><L,U>,
     Unfolding: (\ @ a
                   ($d(%,,%) :: Data.Array.Accelerate.Classes.Integral.Integral a)
                   (eta :: Data.Array.Accelerate.Smart.Exp a) ->
                 let {
                   $dIntegral :: GHC.Real.Integral (Data.Array.Accelerate.Smart.Exp a)
                   = GHC.Classes.$p3(%,,%)
                       @ (Data.Array.Accelerate.Classes.Enum.Enum a)
                       @ (Data.Array.Accelerate.Classes.Real.Real a)
                       @ (GHC.Real.Integral (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,,%)
                 } in
                 let {
                   $dReal :: GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a)
                   = GHC.Real.$p1Integral
                       @ (Data.Array.Accelerate.Smart.Exp a)
                       $dIntegral
                 } in
                 let {
                   $dNum :: GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a)
                   = GHC.Real.$p1Real @ (Data.Array.Accelerate.Smart.Exp a) $dReal
                 } in
                 Data.Array.Accelerate.Classes.Eq.==
                   @ a
                   (Data.Array.Accelerate.Classes.Ord.$p1Ord
                      @ a
                      (GHC.Classes.$p2(%,,%)
                         @ (Data.Array.Accelerate.Classes.Num.Num a)
                         @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                         @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                         (GHC.Classes.$p2(%,,%)
                            @ (Data.Array.Accelerate.Classes.Enum.Enum a)
                            @ (Data.Array.Accelerate.Classes.Real.Real a)
                            @ (GHC.Real.Integral (Data.Array.Accelerate.Smart.Exp a))
                            $d(%,,%))))
                   (GHC.Real.rem
                      @ (Data.Array.Accelerate.Smart.Exp a)
                      $dIntegral
                      eta
                      (GHC.Num.fromInteger
                         @ (Data.Array.Accelerate.Smart.Exp a)
                         $dNum
                         Data.Array.Accelerate.Language.even1))
                   (GHC.Num.fromInteger
                      @ (Data.Array.Accelerate.Smart.Exp a)
                      $dNum
                      Data.Array.Accelerate.Language.^^1)) -}
d55a34252194083297aa997358028034
  even1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (2) -}
f7d77a209a3a47753e68a79091cae799
  fold ::
    (Data.Array.Accelerate.Array.Sugar.Shape sh,
     Data.Array.Accelerate.Array.Sugar.Elt a) =>
    (Data.Array.Accelerate.Smart.Exp a
     -> Data.Array.Accelerate.Smart.Exp a
     -> Data.Array.Accelerate.Smart.Exp a)
    -> Data.Array.Accelerate.Smart.Exp a
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array
            (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) a)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array sh a)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(U,U,U,U(U),U(U),U(U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U><L,U><L,U>,
     Unfolding: (\ @ sh
                   @ a
                   ($dShape :: Data.Array.Accelerate.Array.Sugar.Shape sh)
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt a)
                   (eta :: Data.Array.Accelerate.Smart.Exp a
                           -> Data.Array.Accelerate.Smart.Exp a
                           -> Data.Array.Accelerate.Smart.Exp a)
                   (eta1 :: Data.Array.Accelerate.Smart.Exp a)
                   (eta2 :: Data.Array.Accelerate.Smart.Acc
                              (Data.Array.Accelerate.Array.Sugar.Array
                                 (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) a)) ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh>_N <sh>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh>_N <sh>_N) of cobox2 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.$WFold
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ sh
                    @ a
                    $dShape
                    $dElt
                    eta
                    eta1
                    eta2)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Acc[0]) <Data.Array.Accelerate.Array.Sugar.Array
                                                                sh a>_N) } } }) -}
427b1e39f18390c6ba9706b75ca95bb6
  fold1 ::
    (Data.Array.Accelerate.Array.Sugar.Shape sh,
     Data.Array.Accelerate.Array.Sugar.Elt a) =>
    (Data.Array.Accelerate.Smart.Exp a
     -> Data.Array.Accelerate.Smart.Exp a
     -> Data.Array.Accelerate.Smart.Exp a)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array
            (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) a)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array sh a)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(U,U,U,U(U),U(U),U(U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U><L,U>,
     Unfolding: (\ @ sh
                   @ a
                   ($dShape :: Data.Array.Accelerate.Array.Sugar.Shape sh)
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt a)
                   (eta :: Data.Array.Accelerate.Smart.Exp a
                           -> Data.Array.Accelerate.Smart.Exp a
                           -> Data.Array.Accelerate.Smart.Exp a)
                   (eta1 :: Data.Array.Accelerate.Smart.Acc
                              (Data.Array.Accelerate.Array.Sugar.Array
                                 (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) a)) ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh>_N <sh>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh>_N <sh>_N) of cobox2 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.$WFold1
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ sh
                    @ a
                    $dShape
                    $dElt
                    eta
                    eta1)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Acc[0]) <Data.Array.Accelerate.Array.Sugar.Array
                                                                sh a>_N) } } }) -}
bca77a7a9a62425d452f0918d8dd375a
  fold1Seg ::
    (Data.Array.Accelerate.Array.Sugar.Shape sh,
     Data.Array.Accelerate.Array.Sugar.Elt a,
     Data.Array.Accelerate.Array.Sugar.Elt i,
     Data.Array.Accelerate.Type.IsIntegral i) =>
    (Data.Array.Accelerate.Smart.Exp a
     -> Data.Array.Accelerate.Smart.Exp a
     -> Data.Array.Accelerate.Smart.Exp a)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array
            (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) a)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Segments i)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array
            (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) a)
  {- Arity: 7, HasNoCafRefs,
     Strictness: <S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(U,U,U,U(U),U(U),U(U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U><L,U><L,U><L,U><L,U>,
     Unfolding: (\ @ sh
                   @ a
                   @ i
                   ($dShape :: Data.Array.Accelerate.Array.Sugar.Shape sh)
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt a)
                   ($dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt i)
                   ($dIsIntegral :: Data.Array.Accelerate.Type.IsIntegral i)
                   (eta :: Data.Array.Accelerate.Smart.Exp a
                           -> Data.Array.Accelerate.Smart.Exp a
                           -> Data.Array.Accelerate.Smart.Exp a)
                   (eta1 :: Data.Array.Accelerate.Smart.Acc
                              (Data.Array.Accelerate.Array.Sugar.Array
                                 (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) a))
                   (eta2 :: Data.Array.Accelerate.Smart.Acc
                              (Data.Array.Accelerate.Array.Sugar.Segments i)) ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh>_N <sh>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh>_N <sh>_N) of cobox2 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.$WFold1Seg
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ sh
                    @ a
                    @ i
                    $dShape
                    $dElt
                    $dElt1
                    $dIsIntegral
                    eta
                    eta1
                    eta2)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Acc[0]) <Data.Array.Accelerate.Array.Sugar.Array
                                                                (sh
                                                                 Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int)
                                                                a>_N) } } }) -}
6a092174d2d22ed32fafa11e381cb1c5
  foldSeg ::
    (Data.Array.Accelerate.Array.Sugar.Shape sh,
     Data.Array.Accelerate.Array.Sugar.Elt a,
     Data.Array.Accelerate.Array.Sugar.Elt i,
     Data.Array.Accelerate.Type.IsIntegral i) =>
    (Data.Array.Accelerate.Smart.Exp a
     -> Data.Array.Accelerate.Smart.Exp a
     -> Data.Array.Accelerate.Smart.Exp a)
    -> Data.Array.Accelerate.Smart.Exp a
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array
            (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) a)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Segments i)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array
            (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) a)
  {- Arity: 8, HasNoCafRefs,
     Strictness: <S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(U,U,U,U(U),U(U),U(U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U><L,U><L,U><L,U><L,U><L,U>,
     Unfolding: (\ @ sh
                   @ a
                   @ i
                   ($dShape :: Data.Array.Accelerate.Array.Sugar.Shape sh)
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt a)
                   ($dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt i)
                   ($dIsIntegral :: Data.Array.Accelerate.Type.IsIntegral i)
                   (eta :: Data.Array.Accelerate.Smart.Exp a
                           -> Data.Array.Accelerate.Smart.Exp a
                           -> Data.Array.Accelerate.Smart.Exp a)
                   (eta1 :: Data.Array.Accelerate.Smart.Exp a)
                   (eta2 :: Data.Array.Accelerate.Smart.Acc
                              (Data.Array.Accelerate.Array.Sugar.Array
                                 (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) a))
                   (eta3 :: Data.Array.Accelerate.Smart.Acc
                              (Data.Array.Accelerate.Array.Sugar.Segments i)) ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh>_N <sh>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh>_N <sh>_N) of cobox2 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.$WFoldSeg
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ sh
                    @ a
                    @ i
                    $dShape
                    $dElt
                    $dElt1
                    $dIsIntegral
                    eta
                    eta1
                    eta2
                    eta3)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Acc[0]) <Data.Array.Accelerate.Array.Sugar.Array
                                                                (sh
                                                                 Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int)
                                                                a>_N) } } }) -}
5d8586b9c4d9bf3278981a4b72428b47
  foreignAcc ::
    (Data.Array.Accelerate.Array.Sugar.Arrays as,
     Data.Array.Accelerate.Array.Sugar.Arrays bs,
     Data.Array.Accelerate.Array.Sugar.Foreign asm) =>
    asm (as -> bs)
    -> (Data.Array.Accelerate.Smart.Acc as
        -> Data.Array.Accelerate.Smart.Acc bs)
    -> Data.Array.Accelerate.Smart.Acc as
    -> Data.Array.Accelerate.Smart.Acc bs
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,U><L,U><L,U><L,U><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Language.foreignAcc1
                  `cast`
                (forall (as :: <*>_N) (bs :: <*>_N) (asm :: <* -> *>_N).
                 <Data.Array.Accelerate.Array.Sugar.Arrays as>_R
                 ->_R <Data.Array.Accelerate.Array.Sugar.Arrays bs>_R
                 ->_R <Data.Array.Accelerate.Array.Sugar.Foreign asm>_R
                 ->_R <asm (as -> bs)>_R
                 ->_R <Data.Array.Accelerate.Smart.Acc as
                       -> Data.Array.Accelerate.Smart.Acc bs>_R
                 ->_R <Data.Array.Accelerate.Smart.Acc as>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Acc[0]) <bs>_N) -}
ef631ff9ec8108d4cd9f0607c3c3a999
  foreignAcc1 ::
    (Data.Array.Accelerate.Array.Sugar.Arrays as,
     Data.Array.Accelerate.Array.Sugar.Arrays bs,
     Data.Array.Accelerate.Array.Sugar.Foreign asm) =>
    asm (as -> bs)
    -> (Data.Array.Accelerate.Smart.Acc as
        -> Data.Array.Accelerate.Smart.Acc bs)
    -> Data.Array.Accelerate.Smart.Acc as
    -> Data.Array.Accelerate.Smart.PreAcc
         Data.Array.Accelerate.Smart.Acc Data.Array.Accelerate.Smart.Exp bs
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,U><L,U><L,U><L,U><L,U><L,U>,
     Unfolding: InlineRule (6, True, True)
                (\ @ as
                   @ bs
                   @ (asm :: * -> *)
                   ($dArrays :: Data.Array.Accelerate.Array.Sugar.Arrays as)
                   ($dArrays1 :: Data.Array.Accelerate.Array.Sugar.Arrays bs)
                   ($dForeign :: Data.Array.Accelerate.Array.Sugar.Foreign asm)
                   (eta :: asm (as -> bs))
                   (eta1 :: Data.Array.Accelerate.Smart.Acc as
                            -> Data.Array.Accelerate.Smart.Acc bs)
                   (eta2 :: Data.Array.Accelerate.Smart.Acc as) ->
                 Data.Array.Accelerate.Smart.Aforeign
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ bs
                   @ as
                   @ asm
                   $dArrays
                   $dArrays1
                   $dForeign
                   eta
                   eta1
                   eta2) -}
0f2d4c14280876633f1aabc14fbf20c2
  foreignExp ::
    (Data.Array.Accelerate.Array.Sugar.Elt x,
     Data.Array.Accelerate.Array.Sugar.Elt y,
     Data.Array.Accelerate.Array.Sugar.Foreign asm) =>
    asm (x -> y)
    -> (Data.Array.Accelerate.Smart.Exp x
        -> Data.Array.Accelerate.Smart.Exp y)
    -> Data.Array.Accelerate.Smart.Exp x
    -> Data.Array.Accelerate.Smart.Exp y
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,U><L,U><L,U><L,U><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Language.foreignExp1
                  `cast`
                (forall (x :: <*>_N) (y :: <*>_N) (asm :: <* -> *>_N).
                 <Data.Array.Accelerate.Array.Sugar.Elt x>_R
                 ->_R <Data.Array.Accelerate.Array.Sugar.Elt y>_R
                 ->_R <Data.Array.Accelerate.Array.Sugar.Foreign asm>_R
                 ->_R <asm (x -> y)>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp x
                       -> Data.Array.Accelerate.Smart.Exp y>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp x>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <y>_N) -}
0b922055c6c18f12ddf3cc10785539f4
  foreignExp1 ::
    (Data.Array.Accelerate.Array.Sugar.Elt x,
     Data.Array.Accelerate.Array.Sugar.Elt y,
     Data.Array.Accelerate.Array.Sugar.Foreign asm) =>
    asm (x -> y)
    -> (Data.Array.Accelerate.Smart.Exp x
        -> Data.Array.Accelerate.Smart.Exp y)
    -> Data.Array.Accelerate.Smart.Exp x
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc Data.Array.Accelerate.Smart.Exp y
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,U><L,U><L,U><L,U><L,U><L,U>,
     Unfolding: InlineRule (6, True, True)
                (\ @ x
                   @ y
                   @ (asm :: * -> *)
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt x)
                   ($dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt y)
                   ($dForeign :: Data.Array.Accelerate.Array.Sugar.Foreign asm)
                   (eta :: asm (x -> y))
                   (eta1 :: Data.Array.Accelerate.Smart.Exp x
                            -> Data.Array.Accelerate.Smart.Exp y)
                   (eta2 :: Data.Array.Accelerate.Smart.Exp x) ->
                 Data.Array.Accelerate.Smart.Foreign
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ y
                   @ x
                   @ asm
                   $dElt
                   $dElt1
                   $dForeign
                   eta
                   eta1
                   eta2) -}
a444ade550c17d9cc13c47e8af270d31
  fromIndex ::
    Data.Array.Accelerate.Array.Sugar.Shape sh =>
    Data.Array.Accelerate.Smart.Exp sh
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Int
    -> Data.Array.Accelerate.Smart.Exp sh
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(U,U,U,U(U),U(U),U(U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U>m11,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ sh
                   (w :: Data.Array.Accelerate.Array.Sugar.Shape sh)
                   (w1 :: Data.Array.Accelerate.Smart.Exp sh)
                   (w2 :: Data.Array.Accelerate.Smart.Exp GHC.Types.Int) ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh w)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh w)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh>_N <sh>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh w)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh>_N <sh>_N) of cobox2 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.FromIndex
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ sh
                    w
                    w1
                    w2)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <sh>_N) } } }) -}
b6e53c6f98b14f153208f52381de4302
  function ::
    (Data.Array.Accelerate.Array.Sugar.Shape sh,
     Data.Array.Accelerate.Array.Sugar.Elt e) =>
    (Data.Array.Accelerate.Smart.Exp sh
     -> Data.Array.Accelerate.Smart.Exp e)
    -> Data.Array.Accelerate.Smart.Boundary
         (Data.Array.Accelerate.Array.Sugar.Array sh e)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(U,U,U,U(U),U(U),U(U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U>,
     Unfolding: (\ @ sh
                   @ e
                   ($dShape :: Data.Array.Accelerate.Array.Sugar.Shape sh)
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt e)
                   (eta :: Data.Array.Accelerate.Smart.Exp sh
                           -> Data.Array.Accelerate.Smart.Exp e) ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh>_N <sh>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh>_N <sh>_N) of cobox2 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.$WFunction
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ sh
                    @ e
                    $dShape
                    $dElt
                    eta)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Boundary[0]) <Data.Array.Accelerate.Array.Sugar.Array
                                                                     sh e>_N) } } }) -}
6816aca83d6ad374319e73dc5d29ef09
  gcd ::
    Data.Array.Accelerate.Classes.Integral.Integral a =>
    Data.Array.Accelerate.Smart.Exp a
    -> Data.Array.Accelerate.Smart.Exp a
    -> Data.Array.Accelerate.Smart.Exp a
  {- Arity: 3, Strictness: <L,U(A,1*U,U)><L,U><L,U>,
     Unfolding: (\ @ a
                   ($d(%,,%) :: Data.Array.Accelerate.Classes.Integral.Integral a)
                   (eta :: Data.Array.Accelerate.Smart.Exp a)
                   (eta1 :: Data.Array.Accelerate.Smart.Exp a) ->
                 let {
                   $d(%,,%)1 :: Data.Array.Accelerate.Classes.Real.Real a
                   = GHC.Classes.$p2(%,,%)
                       @ (Data.Array.Accelerate.Classes.Enum.Enum a)
                       @ (Data.Array.Accelerate.Classes.Real.Real a)
                       @ (GHC.Real.Integral (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,,%)
                 } in
                 let {
                   $dElt :: Data.Array.Accelerate.Classes.Num.Num a
                   = GHC.Classes.$p1(%,,%)
                       @ (Data.Array.Accelerate.Classes.Num.Num a)
                       @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                       @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,,%)1
                 } in
                 let {
                   $dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt a
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                       $dElt
                 } in
                 let {
                   lvl1 :: Data.Array.Accelerate.Array.Sugar.Elt (a, a)
                   = Data.Array.Accelerate.Array.Sugar.$fElt(,) @ a @ a $dElt1 $dElt1
                 } in
                 let {
                   lvl2 :: Data.Array.Accelerate.Product.IsProduct
                             Data.Array.Accelerate.Array.Sugar.Elt (a, a)
                   = Data.Array.Accelerate.Product.$fIsProductcst(,)
                       @ Data.Array.Accelerate.Array.Sugar.Elt
                       @ a
                       @ a
                       $dElt1
                       $dElt1
                 } in
                 (Data.Array.Accelerate.Smart.Prj
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ a
                    @ (a, a)
                    lvl1
                    lvl2
                    $dElt1
                    (Data.Array.Accelerate.Smart.tix1 @ () @ a @ a)
                      `cast`
                    (Data.Array.Accelerate.Product.TupleIdx
                       (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                 <a>_N <a>_N))
                       <a>_N)_R
                    (let {
                       $dIntegral :: GHC.Real.Integral (Data.Array.Accelerate.Smart.Exp a)
                       = GHC.Classes.$p3(%,,%)
                           @ (Data.Array.Accelerate.Classes.Enum.Enum a)
                           @ (Data.Array.Accelerate.Classes.Real.Real a)
                           @ (GHC.Real.Integral (Data.Array.Accelerate.Smart.Exp a))
                           $d(%,,%)
                     } in
                     let {
                       lvl3 :: Data.Array.Accelerate.Smart.Exp a
                       = GHC.Num.fromInteger
                           @ (Data.Array.Accelerate.Smart.Exp a)
                           (GHC.Real.$p1Real
                              @ (Data.Array.Accelerate.Smart.Exp a)
                              (GHC.Real.$p1Integral
                                 @ (Data.Array.Accelerate.Smart.Exp a)
                                 $dIntegral))
                           Data.Array.Accelerate.Language.^^1
                     } in
                     let {
                       $dEq :: Data.Array.Accelerate.Classes.Ord.Ord a
                       = GHC.Classes.$p2(%,,%)
                           @ (Data.Array.Accelerate.Classes.Num.Num a)
                           @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                           @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                           $d(%,,%)1
                     } in
                     let {
                       $dEq1 :: Data.Array.Accelerate.Classes.Eq.Eq a
                       = Data.Array.Accelerate.Classes.Ord.$p1Ord @ a $dEq
                     } in
                     (Data.Array.Accelerate.Smart.While
                        @ Data.Array.Accelerate.Smart.Acc
                        @ Data.Array.Accelerate.Smart.Exp
                        @ (a, a)
                        lvl1
                        (\ (ds :: Data.Array.Accelerate.Smart.Exp (a, a)) ->
                         Data.Array.Accelerate.Classes.Eq./=
                           @ a
                           $dEq1
                           (Data.Array.Accelerate.Smart.Prj
                              @ Data.Array.Accelerate.Smart.Acc
                              @ Data.Array.Accelerate.Smart.Exp
                              @ a
                              @ (a, a)
                              lvl1
                              lvl2
                              $dElt1
                              (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                                `cast`
                              (Data.Array.Accelerate.Product.TupleIdx
                                 (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                           <a>_N <a>_N))
                                 <a>_N)_R
                              ds)
                             `cast`
                           (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                           lvl3)
                        (\ (ds :: Data.Array.Accelerate.Smart.Exp (a, a)) ->
                         Data.Array.Accelerate.Smart.Tuple
                           @ Data.Array.Accelerate.Smart.Acc
                           @ Data.Array.Accelerate.Smart.Exp
                           @ (a, a)
                           lvl1
                           lvl2
                           (let {
                              b :: Data.Array.Accelerate.Smart.PreExp
                                     Data.Array.Accelerate.Smart.Acc
                                     Data.Array.Accelerate.Smart.Exp
                                     a
                              = Data.Array.Accelerate.Smart.Prj
                                  @ Data.Array.Accelerate.Smart.Acc
                                  @ Data.Array.Accelerate.Smart.Exp
                                  @ a
                                  @ (a, a)
                                  lvl1
                                  lvl2
                                  $dElt1
                                  (Data.Array.Accelerate.Product.$WZeroTupIdx @ a @ ((), a))
                                    `cast`
                                  (Data.Array.Accelerate.Product.TupleIdx
                                     (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                               <a>_N <a>_N))
                                     <a>_N)_R
                                  ds
                            } in
                            (Data.Array.Accelerate.Array.Sugar.SnocTup
                               @ Data.Array.Accelerate.Smart.Exp
                               @ (((), a), a)
                               @ a
                               @ ((), a)
                               @~ <(((), a), a)>_N
                               $dElt1
                               (Data.Array.Accelerate.Array.Sugar.SnocTup
                                  @ Data.Array.Accelerate.Smart.Exp
                                  @ ((), a)
                                  @ a
                                  @ ()
                                  @~ <((), a)>_N
                                  $dElt1
                                  (Data.Array.Accelerate.Array.Sugar.$WNilTup
                                     @ Data.Array.Accelerate.Smart.Exp)
                                  b `cast` (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N))
                               (GHC.Real.rem
                                  @ (Data.Array.Accelerate.Smart.Exp a)
                                  $dIntegral
                                  (Data.Array.Accelerate.Smart.Prj
                                     @ Data.Array.Accelerate.Smart.Acc
                                     @ Data.Array.Accelerate.Smart.Exp
                                     @ a
                                     @ (a, a)
                                     lvl1
                                     lvl2
                                     $dElt1
                                     (Data.Array.Accelerate.Smart.tix1 @ () @ a @ a)
                                       `cast`
                                     (Data.Array.Accelerate.Product.TupleIdx
                                        (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                                  <a>_N <a>_N))
                                        <a>_N)_R
                                     ds)
                                    `cast`
                                  (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)
                                  b `cast` (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)))
                              `cast`
                            (Data.Array.Accelerate.Array.Sugar.Tuple
                               <Data.Array.Accelerate.Smart.Exp>_R
                               (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                         <a>_N <a>_N)))_R))
                          `cast`
                        (<Data.Array.Accelerate.Smart.Exp (a, a)>_R
                         ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <(a, a)>_N)
                        (Data.Array.Accelerate.Smart.Tuple
                           @ Data.Array.Accelerate.Smart.Acc
                           @ Data.Array.Accelerate.Smart.Exp
                           @ (a, a)
                           lvl1
                           lvl2
                           (let {
                              $dReal :: GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a)
                              = GHC.Real.$p1Integral
                                  @ (Data.Array.Accelerate.Smart.Exp a)
                                  $dIntegral
                            } in
                            let {
                              $dNum :: GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a)
                              = GHC.Real.$p1Real @ (Data.Array.Accelerate.Smart.Exp a) $dReal
                            } in
                            (Data.Array.Accelerate.Array.Sugar.SnocTup
                               @ Data.Array.Accelerate.Smart.Exp
                               @ (((), a), a)
                               @ a
                               @ ((), a)
                               @~ <(((), a), a)>_N
                               $dElt1
                               (Data.Array.Accelerate.Array.Sugar.SnocTup
                                  @ Data.Array.Accelerate.Smart.Exp
                                  @ ((), a)
                                  @ a
                                  @ ()
                                  @~ <((), a)>_N
                                  $dElt1
                                  (Data.Array.Accelerate.Array.Sugar.$WNilTup
                                     @ Data.Array.Accelerate.Smart.Exp)
                                  (GHC.Num.abs @ (Data.Array.Accelerate.Smart.Exp a) $dNum eta))
                               (GHC.Num.abs @ (Data.Array.Accelerate.Smart.Exp a) $dNum eta1))
                              `cast`
                            (Data.Array.Accelerate.Array.Sugar.Tuple
                               <Data.Array.Accelerate.Smart.Exp>_R
                               (Sym (Data.Array.Accelerate.Product.D:R:ProdRepr(,)[0]
                                         <a>_N <a>_N)))_R))
                          `cast`
                        (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <(a, a)>_N))
                       `cast`
                     (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <(a, a)>_N)))
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N)) -}
94a7a8773407451e41d59e224bc2e958
  generate ::
    (Data.Array.Accelerate.Array.Sugar.Shape sh,
     Data.Array.Accelerate.Array.Sugar.Elt a) =>
    Data.Array.Accelerate.Smart.Exp sh
    -> (Data.Array.Accelerate.Smart.Exp sh
        -> Data.Array.Accelerate.Smart.Exp a)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array sh a)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(U,U,U,U(U),U(U),U(U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U><L,U>,
     Unfolding: (\ @ sh
                   @ a
                   ($dShape :: Data.Array.Accelerate.Array.Sugar.Shape sh)
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt a)
                   (eta :: Data.Array.Accelerate.Smart.Exp sh)
                   (eta1 :: Data.Array.Accelerate.Smart.Exp sh
                            -> Data.Array.Accelerate.Smart.Exp a) ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh>_N <sh>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh>_N <sh>_N) of cobox2 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.$WGenerate
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ sh
                    @ a
                    $dShape
                    $dElt
                    eta
                    eta1)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Acc[0]) <Data.Array.Accelerate.Array.Sugar.Array
                                                                sh a>_N) } } }) -}
7837ec041b2d112de61b43113358cc1b
  ignore ::
    Data.Array.Accelerate.Array.Sugar.Shape sh =>
    Data.Array.Accelerate.Smart.Exp sh
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(1*U,A,A,1*U(1*U),1*U(1*U),1*U(1*U),A,A,A,1*U,A,A,A,A,A,A,A,A,A,A,A,A)>m2,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ sh (w :: Data.Array.Accelerate.Array.Sugar.Shape sh) ->
                 case Data.Array.Accelerate.Language.$wignore
                        @ sh
                        w of ww { (#,#) ww1 ww2 ->
                 (Data.Array.Accelerate.Smart.Const
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ sh
                    ww1
                    ww2)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <sh>_N) }) -}
0d0608c0adf6de25f2f5173de1b50fc2
  indexHead ::
    (Data.Array.Accelerate.Array.Sugar.Slice sh,
     Data.Array.Accelerate.Array.Sugar.Elt a) =>
    Data.Array.Accelerate.Smart.Exp
      (sh Data.Array.Accelerate.Array.Sugar.:. a)
    -> Data.Array.Accelerate.Smart.Exp a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LSSSL),U(U,U,U,U,U)><L,U><L,U>,
     Unfolding: (\ @ sh
                   @ a
                   ($dSlice :: Data.Array.Accelerate.Array.Sugar.Slice sh)
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt a)
                   (eta :: Data.Array.Accelerate.Smart.Exp
                             (sh Data.Array.Accelerate.Array.Sugar.:. a)) ->
                 let {
                   $dShape :: Data.Array.Accelerate.Array.Sugar.Shape
                                (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                   = Data.Array.Accelerate.Array.Sugar.$p4Slice @ sh $dSlice
                 } in
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape
                             (Data.Array.Accelerate.Array.Sugar.FullShape sh))
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape
                           @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                           $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                (Data.Array.Accelerate.Array.Sugar.FullShape
                                                   sh)>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                             sh>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape
                             (Data.Array.Accelerate.Array.Sugar.FullShape sh))
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape
                           @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                           $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                (Data.Array.Accelerate.Array.Sugar.FullShape
                                                   sh)>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                             sh>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape
                             (Data.Array.Accelerate.Array.Sugar.FullShape sh))
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape
                           @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                           $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                (Data.Array.Accelerate.Array.Sugar.FullShape
                                                   sh)>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox2 { DEFAULT ->
                 let {
                   $dShape1 :: Data.Array.Accelerate.Array.Sugar.Shape
                                 (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                   = Data.Array.Accelerate.Array.Sugar.$p3Slice @ sh $dSlice
                 } in
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape
                             (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh))
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape
                           @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                           $dShape1)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                (Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                   sh)>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                             sh>_N) of cobox3 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape
                             (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh))
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape
                           @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                           $dShape1)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                (Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                   sh)>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                             sh>_N) of cobox4 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape
                             (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh))
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape
                           @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                           $dShape1)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                (Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                   sh)>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox5 { DEFAULT ->
                 let {
                   $dShape2 :: Data.Array.Accelerate.Array.Sugar.Shape
                                 (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                   = Data.Array.Accelerate.Array.Sugar.$p2Slice @ sh $dSlice
                 } in
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape
                             (Data.Array.Accelerate.Array.Sugar.SliceShape sh))
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape
                           @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                           $dShape2)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                (Data.Array.Accelerate.Array.Sugar.SliceShape
                                                   sh)>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                             sh>_N) of cobox6 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape
                             (Data.Array.Accelerate.Array.Sugar.SliceShape sh))
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape
                           @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                           $dShape2)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                (Data.Array.Accelerate.Array.Sugar.SliceShape
                                                   sh)>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                             sh>_N) of cobox7 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape
                             (Data.Array.Accelerate.Array.Sugar.SliceShape sh))
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape
                           @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                           $dShape2)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                (Data.Array.Accelerate.Array.Sugar.SliceShape
                                                   sh)>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox8 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.IndexHead
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ a
                    @ sh
                    $dSlice
                    $dElt
                    eta)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N) } } } } } } } } }) -}
211189ec6e436bda888aec339a902201
  indexTail ::
    (Data.Array.Accelerate.Array.Sugar.Slice sh,
     Data.Array.Accelerate.Array.Sugar.Elt a) =>
    Data.Array.Accelerate.Smart.Exp
      (sh Data.Array.Accelerate.Array.Sugar.:. a)
    -> Data.Array.Accelerate.Smart.Exp sh
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LSSSL),U(U,U,U,U,U)><L,U><L,U>,
     Unfolding: (\ @ sh
                   @ a
                   ($dSlice :: Data.Array.Accelerate.Array.Sugar.Slice sh)
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt a)
                   (eta :: Data.Array.Accelerate.Smart.Exp
                             (sh Data.Array.Accelerate.Array.Sugar.:. a)) ->
                 let {
                   $dShape :: Data.Array.Accelerate.Array.Sugar.Shape
                                (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                   = Data.Array.Accelerate.Array.Sugar.$p4Slice @ sh $dSlice
                 } in
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape
                             (Data.Array.Accelerate.Array.Sugar.FullShape sh))
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape
                           @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                           $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                (Data.Array.Accelerate.Array.Sugar.FullShape
                                                   sh)>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                             sh>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape
                             (Data.Array.Accelerate.Array.Sugar.FullShape sh))
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape
                           @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                           $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                (Data.Array.Accelerate.Array.Sugar.FullShape
                                                   sh)>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                             sh>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape
                             (Data.Array.Accelerate.Array.Sugar.FullShape sh))
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape
                           @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                           $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                (Data.Array.Accelerate.Array.Sugar.FullShape
                                                   sh)>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox2 { DEFAULT ->
                 let {
                   $dShape1 :: Data.Array.Accelerate.Array.Sugar.Shape
                                 (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                   = Data.Array.Accelerate.Array.Sugar.$p3Slice @ sh $dSlice
                 } in
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape
                             (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh))
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape
                           @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                           $dShape1)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                (Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                   sh)>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                             sh>_N) of cobox3 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape
                             (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh))
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape
                           @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                           $dShape1)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                (Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                   sh)>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                             sh>_N) of cobox4 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape
                             (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh))
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape
                           @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                           $dShape1)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                (Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                   sh)>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox5 { DEFAULT ->
                 let {
                   $dShape2 :: Data.Array.Accelerate.Array.Sugar.Shape
                                 (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                   = Data.Array.Accelerate.Array.Sugar.$p2Slice @ sh $dSlice
                 } in
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape
                             (Data.Array.Accelerate.Array.Sugar.SliceShape sh))
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape
                           @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                           $dShape2)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                (Data.Array.Accelerate.Array.Sugar.SliceShape
                                                   sh)>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                             sh>_N) of cobox6 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape
                             (Data.Array.Accelerate.Array.Sugar.SliceShape sh))
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape
                           @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                           $dShape2)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                (Data.Array.Accelerate.Array.Sugar.SliceShape
                                                   sh)>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                             sh>_N) of cobox7 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape
                             (Data.Array.Accelerate.Array.Sugar.SliceShape sh))
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape
                           @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                           $dShape2)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                (Data.Array.Accelerate.Array.Sugar.SliceShape
                                                   sh)>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox8 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.IndexTail
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ sh
                    @ a
                    $dSlice
                    $dElt
                    eta)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <sh>_N) } } } } } } } } }) -}
103cab0d557d8a74cf0123e197a56020
  intersect ::
    Data.Array.Accelerate.Array.Sugar.Shape sh =>
    Data.Array.Accelerate.Smart.Exp sh
    -> Data.Array.Accelerate.Smart.Exp sh
    -> Data.Array.Accelerate.Smart.Exp sh
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(U,U,U,U(U),U(U),U(U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U>m20,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ sh
                   (w :: Data.Array.Accelerate.Array.Sugar.Shape sh)
                   (w1 :: Data.Array.Accelerate.Smart.Exp sh)
                   (w2 :: Data.Array.Accelerate.Smart.Exp sh) ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh w)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh w)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh>_N <sh>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh w)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh>_N <sh>_N) of cobox2 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.Intersect
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ sh
                    w
                    w1
                    w2)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <sh>_N) } } }) -}
aa88c2b19cdca930ee844b6ed831c346
  lcm ::
    Data.Array.Accelerate.Classes.Integral.Integral a =>
    Data.Array.Accelerate.Smart.Exp a
    -> Data.Array.Accelerate.Smart.Exp a
    -> Data.Array.Accelerate.Smart.Exp a
  {- Arity: 3, Strictness: <L,U(A,U,U)><L,U><L,U>m12,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: Data.Array.Accelerate.Classes.Integral.Integral a)
                   (w1 :: Data.Array.Accelerate.Smart.Exp a)
                   (w2 :: Data.Array.Accelerate.Smart.Exp a) ->
                 case Data.Array.Accelerate.Language.$wlcm
                        @ a
                        w
                        w1
                        w2 of ww { (#,,,#) ww1 ww2 ww3 ww4 ->
                 (Data.Array.Accelerate.Smart.Cond
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ a
                    ww1
                    ww2
                    ww3
                    ww4)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <a>_N) }) -}
5b504dcdeac486970efeb2aa6abad1c8
  map ::
    (Data.Array.Accelerate.Array.Sugar.Shape sh,
     Data.Array.Accelerate.Array.Sugar.Elt a,
     Data.Array.Accelerate.Array.Sugar.Elt b) =>
    (Data.Array.Accelerate.Smart.Exp a
     -> Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array sh a)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array sh b)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(U,U,U,U(U),U(U),U(U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U><L,U><L,U>,
     Unfolding: (\ @ sh
                   @ a
                   @ b
                   ($dShape :: Data.Array.Accelerate.Array.Sugar.Shape sh)
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt a)
                   ($dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt b)
                   (eta :: Data.Array.Accelerate.Smart.Exp a
                           -> Data.Array.Accelerate.Smart.Exp b)
                   (eta1 :: Data.Array.Accelerate.Smart.Acc
                              (Data.Array.Accelerate.Array.Sugar.Array sh a)) ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh>_N <sh>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh>_N <sh>_N) of cobox2 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.$WMap
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ sh
                    @ a
                    @ b
                    $dShape
                    $dElt
                    $dElt1
                    eta
                    eta1)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Acc[0]) <Data.Array.Accelerate.Array.Sugar.Array
                                                                sh b>_N) } } }) -}
ee0bd559636c188a31091a1ed3cec7e0
  mirror ::
    Data.Array.Accelerate.Smart.Boundary
      (Data.Array.Accelerate.Array.Sugar.Array sh e)
  {- HasNoCafRefs,
     Unfolding: InlineRule (0, True, True)
                (\ @ sh @ e ->
                 Data.Array.Accelerate.Smart.Mirror
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ (Data.Array.Accelerate.Array.Sugar.Array sh e))
                  `cast`
                (forall (sh :: <GHC.Types.*>_N) (e :: <*>_N).
                 Sym (Data.Array.Accelerate.Smart.N:Boundary[0]) <Data.Array.Accelerate.Array.Sugar.Array
                                                                    sh e>_N) -}
46ce7e8f920cd36f2854b5f4987a30b5
  odd ::
    Data.Array.Accelerate.Classes.Integral.Integral a =>
    Data.Array.Accelerate.Smart.Exp a
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS(LS(S(LLC(C(S)))LLLLLL)L)L),U(A,1*U(A,1*U(1*U(A,A,1*C1(C1(U))),A,A,A,A,A,A),A),1*U)><L,U>,
     Unfolding: (\ @ a
                   ($d(%,,%) :: Data.Array.Accelerate.Classes.Integral.Integral a)
                   (eta :: Data.Array.Accelerate.Smart.Exp a) ->
                 let {
                   $dIntegral :: GHC.Real.Integral (Data.Array.Accelerate.Smart.Exp a)
                   = GHC.Classes.$p3(%,,%)
                       @ (Data.Array.Accelerate.Classes.Enum.Enum a)
                       @ (Data.Array.Accelerate.Classes.Real.Real a)
                       @ (GHC.Real.Integral (Data.Array.Accelerate.Smart.Exp a))
                       $d(%,,%)
                 } in
                 let {
                   $dReal :: GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a)
                   = GHC.Real.$p1Integral
                       @ (Data.Array.Accelerate.Smart.Exp a)
                       $dIntegral
                 } in
                 let {
                   $dNum :: GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a)
                   = GHC.Real.$p1Real @ (Data.Array.Accelerate.Smart.Exp a) $dReal
                 } in
                 Data.Array.Accelerate.Classes.Eq./=
                   @ a
                   (Data.Array.Accelerate.Classes.Ord.$p1Ord
                      @ a
                      (GHC.Classes.$p2(%,,%)
                         @ (Data.Array.Accelerate.Classes.Num.Num a)
                         @ (Data.Array.Accelerate.Classes.Ord.Ord a)
                         @ (GHC.Real.Real (Data.Array.Accelerate.Smart.Exp a))
                         (GHC.Classes.$p2(%,,%)
                            @ (Data.Array.Accelerate.Classes.Enum.Enum a)
                            @ (Data.Array.Accelerate.Classes.Real.Real a)
                            @ (GHC.Real.Integral (Data.Array.Accelerate.Smart.Exp a))
                            $d(%,,%))))
                   (GHC.Real.rem
                      @ (Data.Array.Accelerate.Smart.Exp a)
                      $dIntegral
                      eta
                      (GHC.Num.fromInteger
                         @ (Data.Array.Accelerate.Smart.Exp a)
                         $dNum
                         Data.Array.Accelerate.Language.even1))
                   (GHC.Num.fromInteger
                      @ (Data.Array.Accelerate.Smart.Exp a)
                      $dNum
                      Data.Array.Accelerate.Language.^^1)) -}
70d5f3bcafc14208278b7f59d3281db2
  ord ::
    Data.Array.Accelerate.Smart.Exp GHC.Types.Char
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Int
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Smart.mkOrd1
                  `cast`
                (<Data.Array.Accelerate.Smart.Exp GHC.Types.Char>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Int>_N) -}
cdeee58bd3e72476d24d2a62d2887cb5
  permute ::
    (Data.Array.Accelerate.Array.Sugar.Shape sh,
     Data.Array.Accelerate.Array.Sugar.Shape sh',
     Data.Array.Accelerate.Array.Sugar.Elt a) =>
    (Data.Array.Accelerate.Smart.Exp a
     -> Data.Array.Accelerate.Smart.Exp a
     -> Data.Array.Accelerate.Smart.Exp a)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array sh' a)
    -> (Data.Array.Accelerate.Smart.Exp sh
        -> Data.Array.Accelerate.Smart.Exp sh')
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array sh a)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array sh' a)
  {- Arity: 7, HasNoCafRefs,
     Strictness: <S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(U,U,U,U(U),U(U),U(U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(U,U,U,U(U),U(U),U(U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U><L,U><L,U><L,U>,
     Unfolding: (\ @ sh
                   @ sh'
                   @ a
                   ($dShape :: Data.Array.Accelerate.Array.Sugar.Shape sh)
                   ($dShape1 :: Data.Array.Accelerate.Array.Sugar.Shape sh')
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt a)
                   (eta :: Data.Array.Accelerate.Smart.Exp a
                           -> Data.Array.Accelerate.Smart.Exp a
                           -> Data.Array.Accelerate.Smart.Exp a)
                   (eta1 :: Data.Array.Accelerate.Smart.Acc
                              (Data.Array.Accelerate.Array.Sugar.Array sh' a))
                   (eta2 :: Data.Array.Accelerate.Smart.Exp sh
                            -> Data.Array.Accelerate.Smart.Exp sh')
                   (eta3 :: Data.Array.Accelerate.Smart.Acc
                              (Data.Array.Accelerate.Array.Sugar.Array sh a)) ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh')
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh' $dShape1)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh'>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh')
                        @ sh'
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh' $dShape1)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh'>_N <sh'>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh')
                        @ sh'
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh' $dShape1)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh'>_N <sh'>_N) of cobox2 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox3 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh>_N <sh>_N) of cobox4 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh>_N <sh>_N) of cobox5 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.$WPermute
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ sh
                    @ sh'
                    @ a
                    $dShape
                    $dShape1
                    $dElt
                    eta
                    eta1
                    eta2
                    eta3)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Acc[0]) <Data.Array.Accelerate.Array.Sugar.Array
                                                                sh' a>_N) } } } } } }) -}
36f2ccc66a8818b5e78229f44f6cc23c
  replicate ::
    (Data.Array.Accelerate.Array.Sugar.Slice slix,
     Data.Array.Accelerate.Array.Sugar.Elt e) =>
    Data.Array.Accelerate.Smart.Exp slix
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array
            (Data.Array.Accelerate.Array.Sugar.SliceShape slix) e)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array
            (Data.Array.Accelerate.Array.Sugar.FullShape slix) e)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LSSSL),U(U,U,U,U,U)><L,U><L,U><L,U>,
     Unfolding: (\ @ slix
                   @ e
                   ($dSlice :: Data.Array.Accelerate.Array.Sugar.Slice slix)
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt e)
                   (eta :: Data.Array.Accelerate.Smart.Exp slix)
                   (eta1 :: Data.Array.Accelerate.Smart.Acc
                              (Data.Array.Accelerate.Array.Sugar.Array
                                 (Data.Array.Accelerate.Array.Sugar.SliceShape slix) e)) ->
                 let {
                   $dShape :: Data.Array.Accelerate.Array.Sugar.Shape
                                (Data.Array.Accelerate.Array.Sugar.FullShape slix)
                   = Data.Array.Accelerate.Array.Sugar.$p4Slice @ slix $dSlice
                 } in
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape
                             (Data.Array.Accelerate.Array.Sugar.FullShape slix))
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape slix)
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape
                           @ (Data.Array.Accelerate.Array.Sugar.FullShape slix)
                           $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                (Data.Array.Accelerate.Array.Sugar.FullShape
                                                   slix)>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                               slix>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape
                             (Data.Array.Accelerate.Array.Sugar.FullShape slix))
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape slix)
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape
                           @ (Data.Array.Accelerate.Array.Sugar.FullShape slix)
                           $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                (Data.Array.Accelerate.Array.Sugar.FullShape
                                                   slix)>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                               slix>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape
                             (Data.Array.Accelerate.Array.Sugar.FullShape slix))
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape
                           @ (Data.Array.Accelerate.Array.Sugar.FullShape slix)
                           $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                (Data.Array.Accelerate.Array.Sugar.FullShape
                                                   slix)>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox2 { DEFAULT ->
                 let {
                   $dShape1 :: Data.Array.Accelerate.Array.Sugar.Shape
                                 (Data.Array.Accelerate.Array.Sugar.CoSliceShape slix)
                   = Data.Array.Accelerate.Array.Sugar.$p3Slice @ slix $dSlice
                 } in
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape
                             (Data.Array.Accelerate.Array.Sugar.CoSliceShape slix))
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape slix)
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape
                           @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape slix)
                           $dShape1)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                (Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                   slix)>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                               slix>_N) of cobox3 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape
                             (Data.Array.Accelerate.Array.Sugar.CoSliceShape slix))
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape slix)
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape
                           @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape slix)
                           $dShape1)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                (Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                   slix)>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                               slix>_N) of cobox4 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape
                             (Data.Array.Accelerate.Array.Sugar.CoSliceShape slix))
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape
                           @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape slix)
                           $dShape1)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                (Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                   slix)>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox5 { DEFAULT ->
                 let {
                   $dShape2 :: Data.Array.Accelerate.Array.Sugar.Shape
                                 (Data.Array.Accelerate.Array.Sugar.SliceShape slix)
                   = Data.Array.Accelerate.Array.Sugar.$p2Slice @ slix $dSlice
                 } in
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape
                             (Data.Array.Accelerate.Array.Sugar.SliceShape slix))
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape slix)
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape
                           @ (Data.Array.Accelerate.Array.Sugar.SliceShape slix)
                           $dShape2)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                (Data.Array.Accelerate.Array.Sugar.SliceShape
                                                   slix)>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                               slix>_N) of cobox6 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape
                             (Data.Array.Accelerate.Array.Sugar.SliceShape slix))
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape slix)
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape
                           @ (Data.Array.Accelerate.Array.Sugar.SliceShape slix)
                           $dShape2)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                (Data.Array.Accelerate.Array.Sugar.SliceShape
                                                   slix)>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                               slix>_N) of cobox7 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape
                             (Data.Array.Accelerate.Array.Sugar.SliceShape slix))
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape
                           @ (Data.Array.Accelerate.Array.Sugar.SliceShape slix)
                           $dShape2)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                (Data.Array.Accelerate.Array.Sugar.SliceShape
                                                   slix)>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox8 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.$WReplicate
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ slix
                    @ e
                    $dSlice
                    $dElt
                    eta
                    eta1)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Acc[0]) <Data.Array.Accelerate.Array.Sugar.Array
                                                                (Data.Array.Accelerate.Array.Sugar.FullShape
                                                                   slix)
                                                                e>_N) } } } } } } } } }) -}
1474d3140f3d1257e148edd688b5bd11
  reshape ::
    (Data.Array.Accelerate.Array.Sugar.Shape sh,
     Data.Array.Accelerate.Array.Sugar.Shape sh',
     Data.Array.Accelerate.Array.Sugar.Elt e) =>
    Data.Array.Accelerate.Smart.Exp sh
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array sh' e)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array sh e)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(U,U,U,U(U),U(U),U(U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(U,U,U,U(U),U(U),U(U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U><L,U>,
     Unfolding: (\ @ sh
                   @ sh'
                   @ e
                   ($dShape :: Data.Array.Accelerate.Array.Sugar.Shape sh)
                   ($dShape1 :: Data.Array.Accelerate.Array.Sugar.Shape sh')
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt e)
                   (eta :: Data.Array.Accelerate.Smart.Exp sh)
                   (eta1 :: Data.Array.Accelerate.Smart.Acc
                              (Data.Array.Accelerate.Array.Sugar.Array sh' e)) ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh')
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh' $dShape1)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh'>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh')
                        @ sh'
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh' $dShape1)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh'>_N <sh'>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh')
                        @ sh'
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh' $dShape1)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh'>_N <sh'>_N) of cobox2 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox3 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh>_N <sh>_N) of cobox4 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh>_N <sh>_N) of cobox5 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.$WReshape
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ sh
                    @ sh'
                    @ e
                    $dShape
                    $dShape1
                    $dElt
                    eta
                    eta1)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Acc[0]) <Data.Array.Accelerate.Array.Sugar.Array
                                                                sh e>_N) } } } } } }) -}
7c188a8c9cc49ae90b6cfac8059751a2
  scanl ::
    (Data.Array.Accelerate.Array.Sugar.Shape sh,
     Data.Array.Accelerate.Array.Sugar.Elt a) =>
    (Data.Array.Accelerate.Smart.Exp a
     -> Data.Array.Accelerate.Smart.Exp a
     -> Data.Array.Accelerate.Smart.Exp a)
    -> Data.Array.Accelerate.Smart.Exp a
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array
            (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) a)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array
            (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) a)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(U,U,U,U(U),U(U),U(U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U><L,U><L,U>,
     Unfolding: (\ @ sh
                   @ a
                   ($dShape :: Data.Array.Accelerate.Array.Sugar.Shape sh)
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt a)
                   (eta :: Data.Array.Accelerate.Smart.Exp a
                           -> Data.Array.Accelerate.Smart.Exp a
                           -> Data.Array.Accelerate.Smart.Exp a)
                   (eta1 :: Data.Array.Accelerate.Smart.Exp a)
                   (eta2 :: Data.Array.Accelerate.Smart.Acc
                              (Data.Array.Accelerate.Array.Sugar.Array
                                 (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) a)) ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh>_N <sh>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh>_N <sh>_N) of cobox2 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.$WScanl
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ sh
                    @ a
                    $dShape
                    $dElt
                    eta
                    eta1
                    eta2)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Acc[0]) <Data.Array.Accelerate.Array.Sugar.Array
                                                                (sh
                                                                 Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int)
                                                                a>_N) } } }) -}
7b06b28c72a5463b26998b3ea9c65005
  scanl' ::
    (Data.Array.Accelerate.Array.Sugar.Shape sh,
     Data.Array.Accelerate.Array.Sugar.Elt a) =>
    (Data.Array.Accelerate.Smart.Exp a
     -> Data.Array.Accelerate.Smart.Exp a
     -> Data.Array.Accelerate.Smart.Exp a)
    -> Data.Array.Accelerate.Smart.Exp a
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array
            (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) a)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array
            (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) a,
          Data.Array.Accelerate.Array.Sugar.Array sh a)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(U,U,U,U(U),U(U),U(U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U><L,U><L,U>,
     Unfolding: (\ @ sh
                   @ a
                   ($dShape :: Data.Array.Accelerate.Array.Sugar.Shape sh)
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt a)
                   (eta :: Data.Array.Accelerate.Smart.Exp a
                           -> Data.Array.Accelerate.Smart.Exp a
                           -> Data.Array.Accelerate.Smart.Exp a)
                   (eta1 :: Data.Array.Accelerate.Smart.Exp a)
                   (eta2 :: Data.Array.Accelerate.Smart.Acc
                              (Data.Array.Accelerate.Array.Sugar.Array
                                 (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) a)) ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh>_N <sh>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh>_N <sh>_N) of cobox2 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.$WScanl'
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ sh
                    @ a
                    $dShape
                    $dElt
                    eta
                    eta1
                    eta2)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Acc[0]) <(Data.Array.Accelerate.Array.Sugar.Array
                                                                 (sh
                                                                  Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int)
                                                                 a,
                                                               Data.Array.Accelerate.Array.Sugar.Array
                                                                 sh a)>_N) } } }) -}
f2717dcc1421f121f3bef1eac2145bb5
  scanl1 ::
    (Data.Array.Accelerate.Array.Sugar.Shape sh,
     Data.Array.Accelerate.Array.Sugar.Elt a) =>
    (Data.Array.Accelerate.Smart.Exp a
     -> Data.Array.Accelerate.Smart.Exp a
     -> Data.Array.Accelerate.Smart.Exp a)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array
            (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) a)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array
            (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) a)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(U,U,U,U(U),U(U),U(U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U><L,U>,
     Unfolding: (\ @ sh
                   @ a
                   ($dShape :: Data.Array.Accelerate.Array.Sugar.Shape sh)
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt a)
                   (eta :: Data.Array.Accelerate.Smart.Exp a
                           -> Data.Array.Accelerate.Smart.Exp a
                           -> Data.Array.Accelerate.Smart.Exp a)
                   (eta1 :: Data.Array.Accelerate.Smart.Acc
                              (Data.Array.Accelerate.Array.Sugar.Array
                                 (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) a)) ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh>_N <sh>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh>_N <sh>_N) of cobox2 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.$WScanl1
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ sh
                    @ a
                    $dShape
                    $dElt
                    eta
                    eta1)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Acc[0]) <Data.Array.Accelerate.Array.Sugar.Array
                                                                (sh
                                                                 Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int)
                                                                a>_N) } } }) -}
7372f778b7fb33979da128dfd3e304bf
  scanr ::
    (Data.Array.Accelerate.Array.Sugar.Shape sh,
     Data.Array.Accelerate.Array.Sugar.Elt a) =>
    (Data.Array.Accelerate.Smart.Exp a
     -> Data.Array.Accelerate.Smart.Exp a
     -> Data.Array.Accelerate.Smart.Exp a)
    -> Data.Array.Accelerate.Smart.Exp a
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array
            (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) a)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array
            (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) a)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(U,U,U,U(U),U(U),U(U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U><L,U><L,U>,
     Unfolding: (\ @ sh
                   @ a
                   ($dShape :: Data.Array.Accelerate.Array.Sugar.Shape sh)
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt a)
                   (eta :: Data.Array.Accelerate.Smart.Exp a
                           -> Data.Array.Accelerate.Smart.Exp a
                           -> Data.Array.Accelerate.Smart.Exp a)
                   (eta1 :: Data.Array.Accelerate.Smart.Exp a)
                   (eta2 :: Data.Array.Accelerate.Smart.Acc
                              (Data.Array.Accelerate.Array.Sugar.Array
                                 (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) a)) ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh>_N <sh>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh>_N <sh>_N) of cobox2 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.$WScanr
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ sh
                    @ a
                    $dShape
                    $dElt
                    eta
                    eta1
                    eta2)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Acc[0]) <Data.Array.Accelerate.Array.Sugar.Array
                                                                (sh
                                                                 Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int)
                                                                a>_N) } } }) -}
b495a44891919dafefab51ab4d51665b
  scanr' ::
    (Data.Array.Accelerate.Array.Sugar.Shape sh,
     Data.Array.Accelerate.Array.Sugar.Elt a) =>
    (Data.Array.Accelerate.Smart.Exp a
     -> Data.Array.Accelerate.Smart.Exp a
     -> Data.Array.Accelerate.Smart.Exp a)
    -> Data.Array.Accelerate.Smart.Exp a
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array
            (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) a)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array
            (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) a,
          Data.Array.Accelerate.Array.Sugar.Array sh a)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(U,U,U,U(U),U(U),U(U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U><L,U><L,U>,
     Unfolding: (\ @ sh
                   @ a
                   ($dShape :: Data.Array.Accelerate.Array.Sugar.Shape sh)
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt a)
                   (eta :: Data.Array.Accelerate.Smart.Exp a
                           -> Data.Array.Accelerate.Smart.Exp a
                           -> Data.Array.Accelerate.Smart.Exp a)
                   (eta1 :: Data.Array.Accelerate.Smart.Exp a)
                   (eta2 :: Data.Array.Accelerate.Smart.Acc
                              (Data.Array.Accelerate.Array.Sugar.Array
                                 (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) a)) ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh>_N <sh>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh>_N <sh>_N) of cobox2 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.$WScanr'
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ sh
                    @ a
                    $dShape
                    $dElt
                    eta
                    eta1
                    eta2)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Acc[0]) <(Data.Array.Accelerate.Array.Sugar.Array
                                                                 (sh
                                                                  Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int)
                                                                 a,
                                                               Data.Array.Accelerate.Array.Sugar.Array
                                                                 sh a)>_N) } } }) -}
7c37955e002f8c3f143fe0055e0310bd
  scanr1 ::
    (Data.Array.Accelerate.Array.Sugar.Shape sh,
     Data.Array.Accelerate.Array.Sugar.Elt a) =>
    (Data.Array.Accelerate.Smart.Exp a
     -> Data.Array.Accelerate.Smart.Exp a
     -> Data.Array.Accelerate.Smart.Exp a)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array
            (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) a)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array
            (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) a)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(U,U,U,U(U),U(U),U(U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U><L,U>,
     Unfolding: (\ @ sh
                   @ a
                   ($dShape :: Data.Array.Accelerate.Array.Sugar.Shape sh)
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt a)
                   (eta :: Data.Array.Accelerate.Smart.Exp a
                           -> Data.Array.Accelerate.Smart.Exp a
                           -> Data.Array.Accelerate.Smart.Exp a)
                   (eta1 :: Data.Array.Accelerate.Smart.Acc
                              (Data.Array.Accelerate.Array.Sugar.Array
                                 (sh Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int) a)) ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh>_N <sh>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh>_N <sh>_N) of cobox2 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.$WScanr1
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ sh
                    @ a
                    $dShape
                    $dElt
                    eta
                    eta1)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Acc[0]) <Data.Array.Accelerate.Array.Sugar.Array
                                                                (sh
                                                                 Data.Array.Accelerate.Array.Sugar.:. GHC.Types.Int)
                                                                a>_N) } } }) -}
875c9d0a6621c8377076e9515cf1ff04
  shape ::
    (Data.Array.Accelerate.Array.Sugar.Shape sh,
     Data.Array.Accelerate.Array.Sugar.Elt e) =>
    Data.Array.Accelerate.Smart.Acc
      (Data.Array.Accelerate.Array.Sugar.Array sh e)
    -> Data.Array.Accelerate.Smart.Exp sh
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(U,U,U,U(U),U(U),U(U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U>,
     Unfolding: (\ @ sh
                   @ e
                   ($dShape :: Data.Array.Accelerate.Array.Sugar.Shape sh)
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt e)
                   (eta :: Data.Array.Accelerate.Smart.Acc
                             (Data.Array.Accelerate.Array.Sugar.Array sh e)) ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh>_N <sh>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh>_N <sh>_N) of cobox2 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.Shape
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ sh
                    @ e
                    $dShape
                    $dElt
                    eta)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <sh>_N) } } }) -}
97ebeffe354ac457c62d9210f2e28df6
  shapeSize ::
    Data.Array.Accelerate.Array.Sugar.Shape sh =>
    Data.Array.Accelerate.Smart.Exp sh
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Int
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(U,U,U,U(U),U(U),U(U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U>,
     Unfolding: (\ @ sh
                   ($dShape :: Data.Array.Accelerate.Array.Sugar.Shape sh)
                   (eta :: Data.Array.Accelerate.Smart.Exp sh) ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh>_N <sh>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh>_N <sh>_N) of cobox2 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.$WShapeSize
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ sh
                    $dShape
                    eta)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Int>_N) } } }) -}
d3fb91af04b8e1f75716faa86563e07e
  size ::
    (Data.Array.Accelerate.Array.Sugar.Shape sh,
     Data.Array.Accelerate.Array.Sugar.Elt e) =>
    Data.Array.Accelerate.Smart.Acc
      (Data.Array.Accelerate.Array.Sugar.Array sh e)
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Int
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(U,U,U,U(U),U(U),U(U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U>,
     Unfolding: (\ @ sh
                   @ e
                   ($dShape :: Data.Array.Accelerate.Array.Sugar.Shape sh)
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt e)
                   (eta :: Data.Array.Accelerate.Smart.Acc
                             (Data.Array.Accelerate.Array.Sugar.Array sh e)) ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh>_N <sh>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh>_N <sh>_N) of cobox2 { DEFAULT ->
                 Data.Array.Accelerate.Language.shapeSize
                   @ sh
                   $dShape
                   (Data.Array.Accelerate.Language.shape
                      @ sh
                      @ e
                      $dShape
                      $dElt
                      eta) } } }) -}
c9fcaf28113fa3d7012c286750a3d7af
  slice ::
    (Data.Array.Accelerate.Array.Sugar.Slice slix,
     Data.Array.Accelerate.Array.Sugar.Elt e) =>
    Data.Array.Accelerate.Smart.Acc
      (Data.Array.Accelerate.Array.Sugar.Array
         (Data.Array.Accelerate.Array.Sugar.FullShape slix) e)
    -> Data.Array.Accelerate.Smart.Exp slix
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array
            (Data.Array.Accelerate.Array.Sugar.SliceShape slix) e)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LSSSL),U(U,U,U,U,U)><L,U><L,U><L,U>,
     Unfolding: (\ @ slix
                   @ e
                   ($dSlice :: Data.Array.Accelerate.Array.Sugar.Slice slix)
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt e)
                   (eta :: Data.Array.Accelerate.Smart.Acc
                             (Data.Array.Accelerate.Array.Sugar.Array
                                (Data.Array.Accelerate.Array.Sugar.FullShape slix) e))
                   (eta1 :: Data.Array.Accelerate.Smart.Exp slix) ->
                 let {
                   $dShape :: Data.Array.Accelerate.Array.Sugar.Shape
                                (Data.Array.Accelerate.Array.Sugar.FullShape slix)
                   = Data.Array.Accelerate.Array.Sugar.$p4Slice @ slix $dSlice
                 } in
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape
                             (Data.Array.Accelerate.Array.Sugar.FullShape slix))
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape slix)
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape
                           @ (Data.Array.Accelerate.Array.Sugar.FullShape slix)
                           $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                (Data.Array.Accelerate.Array.Sugar.FullShape
                                                   slix)>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                               slix>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape
                             (Data.Array.Accelerate.Array.Sugar.FullShape slix))
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape slix)
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape
                           @ (Data.Array.Accelerate.Array.Sugar.FullShape slix)
                           $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                (Data.Array.Accelerate.Array.Sugar.FullShape
                                                   slix)>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                               slix>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape
                             (Data.Array.Accelerate.Array.Sugar.FullShape slix))
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape
                           @ (Data.Array.Accelerate.Array.Sugar.FullShape slix)
                           $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                (Data.Array.Accelerate.Array.Sugar.FullShape
                                                   slix)>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox2 { DEFAULT ->
                 let {
                   $dShape1 :: Data.Array.Accelerate.Array.Sugar.Shape
                                 (Data.Array.Accelerate.Array.Sugar.CoSliceShape slix)
                   = Data.Array.Accelerate.Array.Sugar.$p3Slice @ slix $dSlice
                 } in
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape
                             (Data.Array.Accelerate.Array.Sugar.CoSliceShape slix))
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape slix)
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape
                           @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape slix)
                           $dShape1)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                (Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                   slix)>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                               slix>_N) of cobox3 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape
                             (Data.Array.Accelerate.Array.Sugar.CoSliceShape slix))
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape slix)
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape
                           @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape slix)
                           $dShape1)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                (Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                   slix)>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                               slix>_N) of cobox4 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape
                             (Data.Array.Accelerate.Array.Sugar.CoSliceShape slix))
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape
                           @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape slix)
                           $dShape1)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                (Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                   slix)>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox5 { DEFAULT ->
                 let {
                   $dShape2 :: Data.Array.Accelerate.Array.Sugar.Shape
                                 (Data.Array.Accelerate.Array.Sugar.SliceShape slix)
                   = Data.Array.Accelerate.Array.Sugar.$p2Slice @ slix $dSlice
                 } in
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape
                             (Data.Array.Accelerate.Array.Sugar.SliceShape slix))
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape slix)
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape
                           @ (Data.Array.Accelerate.Array.Sugar.SliceShape slix)
                           $dShape2)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                (Data.Array.Accelerate.Array.Sugar.SliceShape
                                                   slix)>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                               slix>_N) of cobox6 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape
                             (Data.Array.Accelerate.Array.Sugar.SliceShape slix))
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape slix)
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape
                           @ (Data.Array.Accelerate.Array.Sugar.SliceShape slix)
                           $dShape2)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                (Data.Array.Accelerate.Array.Sugar.SliceShape
                                                   slix)>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                               slix>_N) of cobox7 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape
                             (Data.Array.Accelerate.Array.Sugar.SliceShape slix))
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape
                           @ (Data.Array.Accelerate.Array.Sugar.SliceShape slix)
                           $dShape2)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                (Data.Array.Accelerate.Array.Sugar.SliceShape
                                                   slix)>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox8 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.$WSlice
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ slix
                    @ e
                    $dSlice
                    $dElt
                    eta
                    eta1)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Acc[0]) <Data.Array.Accelerate.Array.Sugar.Array
                                                                (Data.Array.Accelerate.Array.Sugar.SliceShape
                                                                   slix)
                                                                e>_N) } } } } } } } } }) -}
0f817807439223ad1e921436d2c07001
  stencil ::
    (Data.Array.Accelerate.Smart.Stencil sh a stencil,
     Data.Array.Accelerate.Array.Sugar.Elt b) =>
    (stencil -> Data.Array.Accelerate.Smart.Exp b)
    -> Data.Array.Accelerate.Smart.Boundary
         (Data.Array.Accelerate.Array.Sugar.Array sh a)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array sh a)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array sh b)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LSL),U(U,U,U)><L,U><L,U><L,U><L,U>,
     Unfolding: (\ @ sh
                   @ a
                   @ stencil1
                   @ b
                   ($dStencil :: Data.Array.Accelerate.Smart.Stencil sh a stencil1)
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt b)
                   (eta :: stencil1 -> Data.Array.Accelerate.Smart.Exp b)
                   (eta1 :: Data.Array.Accelerate.Smart.Boundary
                              (Data.Array.Accelerate.Array.Sugar.Array sh a))
                   (eta2 :: Data.Array.Accelerate.Smart.Acc
                              (Data.Array.Accelerate.Array.Sugar.Array sh a)) ->
                 let {
                   $dStencil1 :: Data.Array.Accelerate.AST.Stencil
                                   sh a (Data.Array.Accelerate.Smart.StencilRepr sh stencil1)
                   = Data.Array.Accelerate.Smart.$p2Stencil
                       @ sh
                       @ a
                       @ stencil1
                       $dStencil
                 } in
                 let {
                   $dShape :: Data.Array.Accelerate.Array.Sugar.Shape sh
                   = Data.Array.Accelerate.AST.$p1Stencil
                       @ sh
                       @ a
                       @ (Data.Array.Accelerate.Smart.StencilRepr sh stencil1)
                       $dStencil1
                 } in
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh>_N <sh>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh>_N <sh>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox2 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.Stencil
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ (Data.Array.Accelerate.Array.Sugar.Array sh b)
                    @ sh
                    @ a
                    @ b
                    @ stencil1
                    @~ <Data.Array.Accelerate.Array.Sugar.Array sh b>_N
                    $dShape
                    (Data.Array.Accelerate.AST.$p2Stencil
                       @ sh
                       @ a
                       @ (Data.Array.Accelerate.Smart.StencilRepr sh stencil1)
                       $dStencil1)
                    $dElt
                    $dStencil
                    eta
                    eta1
                      `cast`
                    (Data.Array.Accelerate.Smart.N:Boundary[0] <Data.Array.Accelerate.Array.Sugar.Array
                                                                  sh a>_N)
                    eta2)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Acc[0]) <Data.Array.Accelerate.Array.Sugar.Array
                                                                sh b>_N) } } }) -}
eabc13f3f97bd4023121cd0c910d872e
  stencil2 ::
    (Data.Array.Accelerate.Smart.Stencil sh a stencil1,
     Data.Array.Accelerate.Smart.Stencil sh b stencil2,
     Data.Array.Accelerate.Array.Sugar.Elt c) =>
    (stencil1 -> stencil2 -> Data.Array.Accelerate.Smart.Exp c)
    -> Data.Array.Accelerate.Smart.Boundary
         (Data.Array.Accelerate.Array.Sugar.Array sh a)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array sh a)
    -> Data.Array.Accelerate.Smart.Boundary
         (Data.Array.Accelerate.Array.Sugar.Array sh b)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array sh b)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array sh c)
  {- Arity: 8, HasNoCafRefs,
     Strictness: <S(LSL),U(U,U,U)><S(LSL),U(U,U,U)><L,U><L,U><L,U><L,U><L,U><L,U>,
     Unfolding: (\ @ sh
                   @ a
                   @ stencil1
                   @ b
                   @ stencil4
                   @ c
                   ($dStencil :: Data.Array.Accelerate.Smart.Stencil sh a stencil1)
                   ($dStencil1 :: Data.Array.Accelerate.Smart.Stencil sh b stencil4)
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt c)
                   (eta :: stencil1 -> stencil4 -> Data.Array.Accelerate.Smart.Exp c)
                   (eta1 :: Data.Array.Accelerate.Smart.Boundary
                              (Data.Array.Accelerate.Array.Sugar.Array sh a))
                   (eta2 :: Data.Array.Accelerate.Smart.Acc
                              (Data.Array.Accelerate.Array.Sugar.Array sh a))
                   (eta3 :: Data.Array.Accelerate.Smart.Boundary
                              (Data.Array.Accelerate.Array.Sugar.Array sh b))
                   (eta4 :: Data.Array.Accelerate.Smart.Acc
                              (Data.Array.Accelerate.Array.Sugar.Array sh b)) ->
                 let {
                   $dStencil2 :: Data.Array.Accelerate.AST.Stencil
                                   sh b (Data.Array.Accelerate.Smart.StencilRepr sh stencil4)
                   = Data.Array.Accelerate.Smart.$p2Stencil
                       @ sh
                       @ b
                       @ stencil4
                       $dStencil1
                 } in
                 let {
                   $dShape :: Data.Array.Accelerate.Array.Sugar.Shape sh
                   = Data.Array.Accelerate.AST.$p1Stencil
                       @ sh
                       @ b
                       @ (Data.Array.Accelerate.Smart.StencilRepr sh stencil4)
                       $dStencil2
                 } in
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh>_N <sh>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh>_N <sh>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox2 { DEFAULT ->
                 let {
                   $dStencil3 :: Data.Array.Accelerate.AST.Stencil
                                   sh a (Data.Array.Accelerate.Smart.StencilRepr sh stencil1)
                   = Data.Array.Accelerate.Smart.$p2Stencil
                       @ sh
                       @ a
                       @ stencil1
                       $dStencil
                 } in
                 let {
                   $dShape1 :: Data.Array.Accelerate.Array.Sugar.Shape sh
                   = Data.Array.Accelerate.AST.$p1Stencil
                       @ sh
                       @ a
                       @ (Data.Array.Accelerate.Smart.StencilRepr sh stencil1)
                       $dStencil3
                 } in
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh $dShape1)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh>_N <sh>_N) of cobox3 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh $dShape1)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh>_N <sh>_N) of cobox4 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh $dShape1)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox5 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.Stencil2
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ (Data.Array.Accelerate.Array.Sugar.Array sh c)
                    @ sh
                    @ a
                    @ b
                    @ c
                    @ stencil1
                    @ stencil4
                    @~ <Data.Array.Accelerate.Array.Sugar.Array sh c>_N
                    $dShape1
                    (Data.Array.Accelerate.AST.$p2Stencil
                       @ sh
                       @ a
                       @ (Data.Array.Accelerate.Smart.StencilRepr sh stencil1)
                       $dStencil3)
                    (Data.Array.Accelerate.AST.$p2Stencil
                       @ sh
                       @ b
                       @ (Data.Array.Accelerate.Smart.StencilRepr sh stencil4)
                       $dStencil2)
                    $dElt
                    $dStencil
                    $dStencil1
                    eta
                    eta1
                      `cast`
                    (Data.Array.Accelerate.Smart.N:Boundary[0] <Data.Array.Accelerate.Array.Sugar.Array
                                                                  sh a>_N)
                    eta2
                    eta3
                      `cast`
                    (Data.Array.Accelerate.Smart.N:Boundary[0] <Data.Array.Accelerate.Array.Sugar.Array
                                                                  sh b>_N)
                    eta4)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Acc[0]) <Data.Array.Accelerate.Array.Sugar.Array
                                                                sh c>_N) } } } } } }) -}
398e8598989689503a754584f3821f5a
  subtract ::
    Data.Array.Accelerate.Classes.Num.Num a =>
    Data.Array.Accelerate.Smart.Exp a
    -> Data.Array.Accelerate.Smart.Exp a
    -> Data.Array.Accelerate.Smart.Exp a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LS(LC(C(S))LLLLL)),1*U(A,1*U(A,1*C1(C1(U)),A,A,A,A,A))><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num a)
                   (eta :: Data.Array.Accelerate.Smart.Exp a)
                   (eta1 :: Data.Array.Accelerate.Smart.Exp a) ->
                 GHC.Num.-
                   @ (Data.Array.Accelerate.Smart.Exp a)
                   (GHC.Classes.$p2(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt a)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp a))
                      $d(%,%))
                   eta1
                   eta) -}
ed801b2cd8ba033e761a833fe006aa28
  toIndex ::
    Data.Array.Accelerate.Array.Sugar.Shape sh =>
    Data.Array.Accelerate.Smart.Exp sh
    -> Data.Array.Accelerate.Smart.Exp sh
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Int
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(U,U,U,U(U),U(U),U(U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U>,
     Unfolding: (\ @ sh
                   ($dShape :: Data.Array.Accelerate.Array.Sugar.Shape sh)
                   (eta :: Data.Array.Accelerate.Smart.Exp sh)
                   (eta1 :: Data.Array.Accelerate.Smart.Exp sh) ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh>_N <sh>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh>_N <sh>_N) of cobox2 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.$WToIndex
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ sh
                    $dShape
                    eta
                    eta1)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Int>_N) } } }) -}
020cd295334a08996953b6a9a2a87c51
  union ::
    Data.Array.Accelerate.Array.Sugar.Shape sh =>
    Data.Array.Accelerate.Smart.Exp sh
    -> Data.Array.Accelerate.Smart.Exp sh
    -> Data.Array.Accelerate.Smart.Exp sh
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(U,U,U,U(U),U(U),U(U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U>m21,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ sh
                   (w :: Data.Array.Accelerate.Array.Sugar.Shape sh)
                   (w1 :: Data.Array.Accelerate.Smart.Exp sh)
                   (w2 :: Data.Array.Accelerate.Smart.Exp sh) ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh w)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh w)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh>_N <sh>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh w)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh>_N <sh>_N) of cobox2 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.Union
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ sh
                    w
                    w1
                    w2)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <sh>_N) } } }) -}
b9ba98b289ec51513606020d2c670417
  unit ::
    Data.Array.Accelerate.Array.Sugar.Elt e =>
    Data.Array.Accelerate.Smart.Exp e
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Scalar e)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                (Data.Array.Accelerate.Smart.$WUnit
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp)
                  `cast`
                (forall (e :: <*>_N).
                 <Data.Array.Accelerate.Array.Sugar.Elt e>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp e>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Acc[0]) <Data.Array.Accelerate.Array.Sugar.Scalar
                                                                    e>_N) -}
120b3b3c1e446d77d464c1e1f38e3bf2
  use ::
    Data.Array.Accelerate.Array.Sugar.Arrays arrays =>
    arrays -> Data.Array.Accelerate.Smart.Acc arrays
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m8,
     Unfolding: InlineRule (0, True, True)
                (Data.Array.Accelerate.Smart.Use
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp)
                  `cast`
                (forall (arrays :: <*>_N).
                 <Data.Array.Accelerate.Array.Sugar.Arrays arrays>_R
                 ->_R <arrays>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Acc[0]) <arrays>_N) -}
73674a4115b985e1fe5c850a62a18ce3
  while ::
    Data.Array.Accelerate.Array.Sugar.Elt e =>
    (Data.Array.Accelerate.Smart.Exp e
     -> Data.Array.Accelerate.Smart.Exp GHC.Types.Bool)
    -> (Data.Array.Accelerate.Smart.Exp e
        -> Data.Array.Accelerate.Smart.Exp e)
    -> Data.Array.Accelerate.Smart.Exp e
    -> Data.Array.Accelerate.Smart.Exp e
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,U><L,U><L,U>m13,
     Unfolding: InlineRule (0, True, True)
                (Data.Array.Accelerate.Smart.While
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp)
                  `cast`
                (forall (e :: <*>_N).
                 <Data.Array.Accelerate.Array.Sugar.Elt e>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp e
                       -> Data.Array.Accelerate.Smart.Exp GHC.Types.Bool>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp e
                       -> Data.Array.Accelerate.Smart.Exp e>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp e>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <e>_N) -}
04cc0fb6c4b56c4fde6964b5a37155e2
  wrap ::
    Data.Array.Accelerate.Smart.Boundary
      (Data.Array.Accelerate.Array.Sugar.Array sh e)
  {- HasNoCafRefs,
     Unfolding: InlineRule (0, True, True)
                (\ @ sh @ e ->
                 Data.Array.Accelerate.Smart.Wrap
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ (Data.Array.Accelerate.Array.Sugar.Array sh e))
                  `cast`
                (forall (sh :: <GHC.Types.*>_N) (e :: <*>_N).
                 Sym (Data.Array.Accelerate.Smart.N:Boundary[0]) <Data.Array.Accelerate.Array.Sugar.Array
                                                                    sh e>_N) -}
1ef59c998b9a534365c2c579d67c9db2
  zipWith ::
    (Data.Array.Accelerate.Array.Sugar.Shape sh,
     Data.Array.Accelerate.Array.Sugar.Elt a,
     Data.Array.Accelerate.Array.Sugar.Elt b,
     Data.Array.Accelerate.Array.Sugar.Elt c) =>
    (Data.Array.Accelerate.Smart.Exp a
     -> Data.Array.Accelerate.Smart.Exp b
     -> Data.Array.Accelerate.Smart.Exp c)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array sh a)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array sh b)
    -> Data.Array.Accelerate.Smart.Acc
         (Data.Array.Accelerate.Array.Sugar.Array sh c)
  {- Arity: 7, HasNoCafRefs,
     Strictness: <S(LLLS(S)S(S)S(S)LLLLLLLLLLLLLLLL),U(U,U,U,U(U),U(U),U(U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U><L,U><L,U><L,U><L,U>,
     Unfolding: (\ @ sh
                   @ a
                   @ b
                   @ c
                   ($dShape :: Data.Array.Accelerate.Array.Sugar.Shape sh)
                   ($dElt :: Data.Array.Accelerate.Array.Sugar.Elt a)
                   ($dElt1 :: Data.Array.Accelerate.Array.Sugar.Elt b)
                   ($dElt2 :: Data.Array.Accelerate.Array.Sugar.Elt c)
                   (eta :: Data.Array.Accelerate.Smart.Exp a
                           -> Data.Array.Accelerate.Smart.Exp b
                           -> Data.Array.Accelerate.Smart.Exp c)
                   (eta1 :: Data.Array.Accelerate.Smart.Acc
                              (Data.Array.Accelerate.Array.Sugar.Array sh a))
                   (eta2 :: Data.Array.Accelerate.Smart.Acc
                              (Data.Array.Accelerate.Array.Sugar.Array sh b)) ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.SliceShape sh)
                        @ Data.Array.Accelerate.Array.Sugar.Z
                        (Data.Array.Accelerate.Array.Sugar.$p6Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.SliceShape
                                                sh>_N <Data.Array.Accelerate.Array.Sugar.Z>_N) of cobox0 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.CoSliceShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p5Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.CoSliceShape
                                                sh>_N <sh>_N) of cobox1 { DEFAULT ->
                 case GHC.Types.HEq_sc
                        @ GHC.Types.*
                        @ GHC.Types.*
                        @ (Data.Array.Accelerate.Array.Sugar.FullShape sh)
                        @ sh
                        (Data.Array.Accelerate.Array.Sugar.$p4Shape @ sh $dShape)
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <GHC.Types.*>_N <Data.Array.Accelerate.Array.Sugar.FullShape
                                                sh>_N <sh>_N) of cobox2 { DEFAULT ->
                 (Data.Array.Accelerate.Smart.$WZipWith
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ sh
                    @ a
                    @ b
                    @ c
                    $dShape
                    $dElt
                    $dElt1
                    $dElt2
                    eta
                    eta1
                    eta2)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Acc[0]) <Data.Array.Accelerate.Array.Sugar.Array
                                                                sh c>_N) } } }) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

