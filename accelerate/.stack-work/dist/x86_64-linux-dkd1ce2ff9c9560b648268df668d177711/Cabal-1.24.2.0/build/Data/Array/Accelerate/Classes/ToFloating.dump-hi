
==================== FINAL INTERFACE ====================
2017-08-29 05:27:47.171119 UTC

interface accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.ToFloating 8002
  interface hash: 3486bc53114bb99f41e19fa9368f6eff
  ABI hash: ed6aca53181b9d143484a8cea04ff101
  export-list hash: b3f7926ca27fa874d9e9951bca4e2004
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 9d293561143f2a548b906379335a7324
  sig of: Nothing
  used TH splices: True
  where
exports:
  Data.Array.Accelerate.Classes.ToFloating.ToFloating{Data.Array.Accelerate.Classes.ToFloating.toFloating}
module dependencies: Data.Array.Accelerate.AST
                     Data.Array.Accelerate.Array.Data
                     Data.Array.Accelerate.Array.Representation
                     Data.Array.Accelerate.Array.Sugar
                     Data.Array.Accelerate.Array.Unique
                     Data.Array.Accelerate.Classes.Floating
                     Data.Array.Accelerate.Classes.Fractional
                     Data.Array.Accelerate.Classes.Num Data.Array.Accelerate.Debug.Flags
                     Data.Array.Accelerate.Debug.Monitoring
                     Data.Array.Accelerate.Debug.Trace Data.Array.Accelerate.Error
                     Data.Array.Accelerate.Lifetime Data.Array.Accelerate.Product
                     Data.Array.Accelerate.Smart Data.Array.Accelerate.Type
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.1.0
                      base-orphans-0.6@base-orphans-0.6-AbJ3lKVXygDCG0eeQEv8Iu
                      binary-0.8.3.0@binary-0.8.3.0
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0
                      fclabels-2.0.3.2@fclabels-2.0.3.2-4EezQlp7n1w9uoh5Y3yxAt
                      ghc-boot-th-8.0.2@ghc-boot-th-8.0.2 ghc-prim-0.5.0.0
                      hashable-1.2.6.1@hashable-1.2.6.1-2ZLNuHq395GGIHwEHuqZol
                      integer-gmp-1.0.0.1 pretty-1.1.3.3@pretty-1.1.3.3
                      template-haskell-2.11.1.0
                      text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00
                      unique-0@unique-0-9CJQKYGbqiDaFUmoekKeA
orphans: accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.Floating
         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.Fractional
         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Classes.Num
         base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         base-orphans-0.6@base-orphans-0.6-AbJ3lKVXygDCG0eeQEv8Iu:Data.Orphans
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
         fclabels-2.0.3.2@fclabels-2.0.3.2-4EezQlp7n1w9uoh5Y3yxAt:Data.Label.Point
         hashable-1.2.6.1@hashable-1.2.6.1-2ZLNuHq395GGIHwEHuqZol:Data.Hashable.Generic
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Lazy
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Show
family instance modules: accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Array.Data
                         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Array.Representation
                         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Array.Sugar
                         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Product
                         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Smart
                         accelerate-1.0.0.0@accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw:Data.Array.Accelerate.Type
                         base-4.9.1.0:Control.Applicative base-4.9.1.0:Data.Complex
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Compose
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.Functor.Product base-4.9.1.0:Data.Functor.Sum
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         ghc-boot-th-8.0.2@ghc-boot-th-8.0.2:GHC.LanguageExtensions.Type
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.HughesPJ
                         template-haskell-2.11.1.0:Language.Haskell.TH.Syntax
                         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text
                         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Lazy
import  -/  Data.Array.Accelerate.Classes.Floating 78c7950257cd37d694096876cf1b7382
  exports: 691d74993cefe4e7a712f639003341ed
  Floating c6033b504a6fb428fc9d28610d2d2d7f
import  -/  Data.Array.Accelerate.Classes.Num 5830cb8ce2e6617e88ff07c7f188117f
  exports: 00b7c9e56019df3c44ef51ed8ebd4236
  Num 13b6af1dd60ee5505ca10fef83916e95
import  -/  Data.Array.Accelerate.Smart c6a471aeed497009ce791e94dc05d100
  exports: 1e3a20050ce25466608a82a26d24d5f0
  Exp dff601899922d9e86e5ab6941dfbac5f
  mkToFloating acba16c33823518243c248dcb4092fe3
import  -/  Data.Array.Accelerate.Type a1c7885f4a79193eaa1f192a9acbec78
  exports: 7aad7ca015788892b1349ebab929b71f
  FloatingType a8fbaf1931593cc4a29598dedb323812
  NumType 13909a3ca52b1a41105a7d98e1d63baf
import  -/  base-4.9.1.0:Control.Monad a6784c5dab0d75c63dabec5a37843f98
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.Traversable 556020d7cf3c4a34a774600512918a37
import  -/  base-4.9.1.0:Foreign.C.Types bf568ee9a3ec4aa42333a0da5f4345de
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Err 3bba35a16538d33d424682ce66876cdd
import  -/  base-4.9.1.0:GHC.Int e6f85fcab22769385fba2b5fce0acb40
import  -/  base-4.9.1.0:GHC.Word 2f8cb4e909eeef2f95e1563807dd9268
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  template-haskell-2.11.1.0:Language.Haskell.TH d856a1f9d606be57026da48a46c8b0a9
import  -/  template-haskell-2.11.1.0:Language.Haskell.TH.Lib 715cf040319ba19bc69da4853519bde7
import  -/  template-haskell-2.11.1.0:Language.Haskell.TH.Syntax f73a6f51a55e744c097972689232ddf4
addDependentFile "/home/pwoh/.stack/programs/x86_64-linux-dkd1ce2ff9c9560b648268df668d177711/ghc-8.0.2/lib/ghc-8.0.2/include/ghcversion.h"
addDependentFile ".stack-work/dist/x86_64-linux-dkd1ce2ff9c9560b648268df668d177711/Cabal-1.24.2.0/build/autogen/cabal_macros.h"
addDependentFile "/usr/include/stdc-predef.h"
b200a93b337871def55a951dd340358b
  $fToFloatingCDoubleCDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CDouble Foreign.C.Types.CDouble
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCDoubleCDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CDouble>_N <Foreign.C.Types.CDouble>_N)) -}
5a9dc8bc3fb348f6fc3340df660a434c
  $fToFloatingCDoubleCDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CDouble,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CDouble)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CDouble)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble) ->
                 let {
                   $dElt :: Data.Array.Accelerate.Array.Sugar.Elt
                              Foreign.C.Types.CDouble
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CDouble)
                       @ (GHC.Num.Num
                            (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble))
                       $d(%,%)
                 } in
                 (Data.Array.Accelerate.Smart.PrimApp
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ Foreign.C.Types.CDouble
                    @ Foreign.C.Types.CDouble
                    $dElt
                    $dElt
                    (Data.Array.Accelerate.AST.PrimToFloating
                       @ (Foreign.C.Types.CDouble -> Foreign.C.Types.CDouble)
                       @ Foreign.C.Types.CDouble
                       @ Foreign.C.Types.CDouble
                       @~ <Foreign.C.Types.CDouble -> Foreign.C.Types.CDouble>_N
                       Data.Array.Accelerate.Type.$fIsNumCDouble_$cnumType
                       Data.Array.Accelerate.Type.$fIsFloatingCDouble_$cfloatingType)
                    eta)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CDouble>_N)) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCDoubleCFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CDouble Foreign.C.Types.CFloat
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCDoubleCFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CDouble>_N <Foreign.C.Types.CFloat>_N)) -}
3fcd8a50224b316792f3bbb980d1b6cc
  $fToFloatingCDoubleCFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CDouble,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CDouble)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CFloat)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CFloat
                   @ Foreign.C.Types.CDouble
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CDouble)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CDouble -> Foreign.C.Types.CFloat)
                      @ Foreign.C.Types.CDouble
                      @ Foreign.C.Types.CFloat
                      @~ <Foreign.C.Types.CDouble -> Foreign.C.Types.CFloat>_N
                      Data.Array.Accelerate.Type.$fIsNumCDouble_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCFloat_$cfloatingType)
                   eta) -}
7c917285cb1f1cbc973a2d061d737e67
  $fToFloatingCDoubleCFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CDouble,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCDoubleCFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CDouble>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CFloat>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CFloat>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCDoubleDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CDouble GHC.Types.Double
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCDoubleDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CDouble>_N <GHC.Types.Double>_N)) -}
d946f78c9a6f022a2f2215ec339308f6
  $fToFloatingCDoubleDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CDouble,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CDouble)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Double)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Double
                   @ Foreign.C.Types.CDouble
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CDouble)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CDouble -> GHC.Types.Double)
                      @ Foreign.C.Types.CDouble
                      @ GHC.Types.Double
                      @~ <Foreign.C.Types.CDouble -> GHC.Types.Double>_N
                      Data.Array.Accelerate.Type.$fIsNumCDouble_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingDouble_$cfloatingType)
                   eta) -}
f713ff93869d1cd2a8902abf68576fc7
  $fToFloatingCDoubleDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CDouble,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCDoubleDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CDouble>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Double>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Double>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCDoubleFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CDouble GHC.Types.Float
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCDoubleFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CDouble>_N <GHC.Types.Float>_N)) -}
ac6f1416654cf607960fac2983d2ee87
  $fToFloatingCDoubleFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CDouble,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CDouble)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Float)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Float
                   @ Foreign.C.Types.CDouble
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CDouble)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CDouble -> GHC.Types.Float)
                      @ Foreign.C.Types.CDouble
                      @ GHC.Types.Float
                      @~ <Foreign.C.Types.CDouble -> GHC.Types.Float>_N
                      Data.Array.Accelerate.Type.$fIsNumCDouble_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingFloat_$cfloatingType)
                   eta) -}
05fde237c40cff6ceadab0f129f1c926
  $fToFloatingCDoubleFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CDouble,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCDoubleFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CDouble>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Float>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Float>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCFloatCDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CFloat Foreign.C.Types.CDouble
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCFloatCDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CFloat>_N <Foreign.C.Types.CDouble>_N)) -}
11a06274d384ef60a43705f3091f3866
  $fToFloatingCFloatCDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CFloat,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CFloat)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CDouble)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CDouble
                   @ Foreign.C.Types.CFloat
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CFloat)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CFloat -> Foreign.C.Types.CDouble)
                      @ Foreign.C.Types.CFloat
                      @ Foreign.C.Types.CDouble
                      @~ <Foreign.C.Types.CFloat -> Foreign.C.Types.CDouble>_N
                      Data.Array.Accelerate.Type.$fIsNumCFloat_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCDouble_$cfloatingType)
                   eta) -}
0b432b7554acafee9d97f1ac05b531e4
  $fToFloatingCFloatCDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CFloat,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCFloatCDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CFloat>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CDouble>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CDouble>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCFloatCFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CFloat Foreign.C.Types.CFloat
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCFloatCFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CFloat>_N <Foreign.C.Types.CFloat>_N)) -}
8f2b52851395f220c12b90b974edfd01
  $fToFloatingCFloatCFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CFloat,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CFloat)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CFloat)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat) ->
                 let {
                   $dElt :: Data.Array.Accelerate.Array.Sugar.Elt
                              Foreign.C.Types.CFloat
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CFloat)
                       @ (GHC.Num.Num
                            (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat))
                       $d(%,%)
                 } in
                 (Data.Array.Accelerate.Smart.PrimApp
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ Foreign.C.Types.CFloat
                    @ Foreign.C.Types.CFloat
                    $dElt
                    $dElt
                    (Data.Array.Accelerate.AST.PrimToFloating
                       @ (Foreign.C.Types.CFloat -> Foreign.C.Types.CFloat)
                       @ Foreign.C.Types.CFloat
                       @ Foreign.C.Types.CFloat
                       @~ <Foreign.C.Types.CFloat -> Foreign.C.Types.CFloat>_N
                       Data.Array.Accelerate.Type.$fIsNumCFloat_$cnumType
                       Data.Array.Accelerate.Type.$fIsFloatingCFloat_$cfloatingType)
                    eta)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CFloat>_N)) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCFloatDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CFloat GHC.Types.Double
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCFloatDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CFloat>_N <GHC.Types.Double>_N)) -}
5ca13eafa880702a73c096dacb349e4f
  $fToFloatingCFloatDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CFloat,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CFloat)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Double)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Double
                   @ Foreign.C.Types.CFloat
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CFloat)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CFloat -> GHC.Types.Double)
                      @ Foreign.C.Types.CFloat
                      @ GHC.Types.Double
                      @~ <Foreign.C.Types.CFloat -> GHC.Types.Double>_N
                      Data.Array.Accelerate.Type.$fIsNumCFloat_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingDouble_$cfloatingType)
                   eta) -}
9866aac3ec68a950377fb35bbda1156d
  $fToFloatingCFloatDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CFloat,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCFloatDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CFloat>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Double>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Double>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCFloatFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CFloat GHC.Types.Float
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCFloatFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CFloat>_N <GHC.Types.Float>_N)) -}
bb66232e0727fca753087b171b0288e0
  $fToFloatingCFloatFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CFloat,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CFloat)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Float)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Float
                   @ Foreign.C.Types.CFloat
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CFloat)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CFloat -> GHC.Types.Float)
                      @ Foreign.C.Types.CFloat
                      @ GHC.Types.Float
                      @~ <Foreign.C.Types.CFloat -> GHC.Types.Float>_N
                      Data.Array.Accelerate.Type.$fIsNumCFloat_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingFloat_$cfloatingType)
                   eta) -}
ace5a2808c5bb411d3ec702eb3f6ca64
  $fToFloatingCFloatFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CFloat,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCFloatFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CFloat>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Float>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Float>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCIntCDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CInt Foreign.C.Types.CDouble
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCIntCDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CInt>_N <Foreign.C.Types.CDouble>_N)) -}
6cc92cc26afbd3d7cc1679bde343a3ca
  $fToFloatingCIntCDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CInt,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CInt
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CInt)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CDouble)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CInt) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CDouble
                   @ Foreign.C.Types.CInt
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CInt)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CInt))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CInt -> Foreign.C.Types.CDouble)
                      @ Foreign.C.Types.CInt
                      @ Foreign.C.Types.CDouble
                      @~ <Foreign.C.Types.CInt -> Foreign.C.Types.CDouble>_N
                      Data.Array.Accelerate.Type.$fIsNumCInt_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCDouble_$cfloatingType)
                   eta) -}
5edc911f704c7e819058da8f88387de6
  $fToFloatingCIntCDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CInt,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CInt
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCIntCDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CInt>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CDouble>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CInt>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CDouble>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCIntCFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CInt Foreign.C.Types.CFloat
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCIntCFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CInt>_N <Foreign.C.Types.CFloat>_N)) -}
4479b8060299e158c661f21f2a2ecc1c
  $fToFloatingCIntCFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CInt,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CInt
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CInt)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CFloat)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CInt) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CFloat
                   @ Foreign.C.Types.CInt
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CInt)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CInt))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CInt -> Foreign.C.Types.CFloat)
                      @ Foreign.C.Types.CInt
                      @ Foreign.C.Types.CFloat
                      @~ <Foreign.C.Types.CInt -> Foreign.C.Types.CFloat>_N
                      Data.Array.Accelerate.Type.$fIsNumCInt_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCFloat_$cfloatingType)
                   eta) -}
5f965c2d59e7d1680eef65c38e842996
  $fToFloatingCIntCFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CInt,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CInt
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCIntCFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CInt>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CFloat>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CInt>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CFloat>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCIntDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CInt GHC.Types.Double
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCIntDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CInt>_N <GHC.Types.Double>_N)) -}
194bfa09f08c16763d7362fb34f0dd0c
  $fToFloatingCIntDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CInt,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CInt
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CInt)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Double)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CInt) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Double
                   @ Foreign.C.Types.CInt
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CInt)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CInt))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CInt -> GHC.Types.Double)
                      @ Foreign.C.Types.CInt
                      @ GHC.Types.Double
                      @~ <Foreign.C.Types.CInt -> GHC.Types.Double>_N
                      Data.Array.Accelerate.Type.$fIsNumCInt_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingDouble_$cfloatingType)
                   eta) -}
8bfb0eff51df9955e351009b481cead1
  $fToFloatingCIntDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CInt,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CInt
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCIntDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CInt>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Double>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CInt>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Double>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCIntFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CInt GHC.Types.Float
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCIntFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CInt>_N <GHC.Types.Float>_N)) -}
aa50d0726a7e8843f2017b0edb47a24e
  $fToFloatingCIntFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CInt,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CInt
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CInt)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Float)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CInt) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Float
                   @ Foreign.C.Types.CInt
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CInt)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CInt))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CInt -> GHC.Types.Float)
                      @ Foreign.C.Types.CInt
                      @ GHC.Types.Float
                      @~ <Foreign.C.Types.CInt -> GHC.Types.Float>_N
                      Data.Array.Accelerate.Type.$fIsNumCInt_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingFloat_$cfloatingType)
                   eta) -}
b0ec7959970a4cea024a325a68db2a55
  $fToFloatingCIntFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CInt,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CInt
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCIntFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CInt>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Float>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CInt>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Float>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCLLongCDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CLLong Foreign.C.Types.CDouble
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCLLongCDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CLLong>_N <Foreign.C.Types.CDouble>_N)) -}
5f0704b1efbfabad4d9f4a95195d2e7c
  $fToFloatingCLLongCDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CLLong,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLLong
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CLLong)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CDouble)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLLong) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CDouble
                   @ Foreign.C.Types.CLLong
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CLLong)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLLong))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CLLong -> Foreign.C.Types.CDouble)
                      @ Foreign.C.Types.CLLong
                      @ Foreign.C.Types.CDouble
                      @~ <Foreign.C.Types.CLLong -> Foreign.C.Types.CDouble>_N
                      Data.Array.Accelerate.Type.$fIsNumCLLong_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCDouble_$cfloatingType)
                   eta) -}
022742259966a76e12e5e154745003e2
  $fToFloatingCLLongCDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CLLong,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLLong
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCLLongCDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CLLong>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CDouble>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLLong>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CDouble>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCLLongCFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CLLong Foreign.C.Types.CFloat
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCLLongCFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CLLong>_N <Foreign.C.Types.CFloat>_N)) -}
83fc1ac2e8d699f0d0058e0cc56177cb
  $fToFloatingCLLongCFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CLLong,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLLong
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CLLong)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CFloat)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLLong) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CFloat
                   @ Foreign.C.Types.CLLong
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CLLong)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLLong))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CLLong -> Foreign.C.Types.CFloat)
                      @ Foreign.C.Types.CLLong
                      @ Foreign.C.Types.CFloat
                      @~ <Foreign.C.Types.CLLong -> Foreign.C.Types.CFloat>_N
                      Data.Array.Accelerate.Type.$fIsNumCLLong_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCFloat_$cfloatingType)
                   eta) -}
7c06953b70fb3359e5ccb178bebaca46
  $fToFloatingCLLongCFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CLLong,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLLong
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCLLongCFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CLLong>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CFloat>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLLong>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CFloat>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCLLongDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CLLong GHC.Types.Double
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCLLongDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CLLong>_N <GHC.Types.Double>_N)) -}
0b2002e4e1ab52f804b07d4cd8448947
  $fToFloatingCLLongDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CLLong,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLLong
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CLLong)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Double)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLLong) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Double
                   @ Foreign.C.Types.CLLong
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CLLong)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLLong))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CLLong -> GHC.Types.Double)
                      @ Foreign.C.Types.CLLong
                      @ GHC.Types.Double
                      @~ <Foreign.C.Types.CLLong -> GHC.Types.Double>_N
                      Data.Array.Accelerate.Type.$fIsNumCLLong_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingDouble_$cfloatingType)
                   eta) -}
1b11e5fd305bb0f21c6e3c6f56befd80
  $fToFloatingCLLongDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CLLong,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLLong
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCLLongDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CLLong>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Double>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLLong>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Double>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCLLongFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CLLong GHC.Types.Float
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCLLongFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CLLong>_N <GHC.Types.Float>_N)) -}
b66bd9f9ae6319646a33b78f15df3423
  $fToFloatingCLLongFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CLLong,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLLong
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CLLong)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Float)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLLong) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Float
                   @ Foreign.C.Types.CLLong
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CLLong)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLLong))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CLLong -> GHC.Types.Float)
                      @ Foreign.C.Types.CLLong
                      @ GHC.Types.Float
                      @~ <Foreign.C.Types.CLLong -> GHC.Types.Float>_N
                      Data.Array.Accelerate.Type.$fIsNumCLLong_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingFloat_$cfloatingType)
                   eta) -}
80af2bb863e4583086be73054974d09a
  $fToFloatingCLLongFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CLLong,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLLong
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCLLongFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CLLong>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Float>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLLong>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Float>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCLongCDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CLong Foreign.C.Types.CDouble
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCLongCDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CLong>_N <Foreign.C.Types.CDouble>_N)) -}
4210658b85553c6cab7b18e6aad3a24f
  $fToFloatingCLongCDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CLong,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLong
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CLong)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CDouble)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLong) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CDouble
                   @ Foreign.C.Types.CLong
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CLong)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLong))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CLong -> Foreign.C.Types.CDouble)
                      @ Foreign.C.Types.CLong
                      @ Foreign.C.Types.CDouble
                      @~ <Foreign.C.Types.CLong -> Foreign.C.Types.CDouble>_N
                      Data.Array.Accelerate.Type.$fIsNumCLong_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCDouble_$cfloatingType)
                   eta) -}
68aff32bdad129dab254c669a707ccc3
  $fToFloatingCLongCDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CLong,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLong
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCLongCDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CLong>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CDouble>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLong>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CDouble>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCLongCFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CLong Foreign.C.Types.CFloat
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCLongCFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CLong>_N <Foreign.C.Types.CFloat>_N)) -}
e2db1450b3a2c75040c207b76accfe85
  $fToFloatingCLongCFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CLong,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLong
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CLong)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CFloat)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLong) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CFloat
                   @ Foreign.C.Types.CLong
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CLong)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLong))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CLong -> Foreign.C.Types.CFloat)
                      @ Foreign.C.Types.CLong
                      @ Foreign.C.Types.CFloat
                      @~ <Foreign.C.Types.CLong -> Foreign.C.Types.CFloat>_N
                      Data.Array.Accelerate.Type.$fIsNumCLong_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCFloat_$cfloatingType)
                   eta) -}
1c09df712bb8174cbda7a9239d0bbae9
  $fToFloatingCLongCFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CLong,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLong
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCLongCFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CLong>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CFloat>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLong>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CFloat>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCLongDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CLong GHC.Types.Double
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCLongDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CLong>_N <GHC.Types.Double>_N)) -}
ec395534a7c6205c30a7126dca42a164
  $fToFloatingCLongDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CLong,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLong
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CLong)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Double)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLong) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Double
                   @ Foreign.C.Types.CLong
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CLong)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLong))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CLong -> GHC.Types.Double)
                      @ Foreign.C.Types.CLong
                      @ GHC.Types.Double
                      @~ <Foreign.C.Types.CLong -> GHC.Types.Double>_N
                      Data.Array.Accelerate.Type.$fIsNumCLong_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingDouble_$cfloatingType)
                   eta) -}
c8b1c6ba7b6f93585bf0bdf3e78106f7
  $fToFloatingCLongDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CLong,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLong
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCLongDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CLong>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Double>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLong>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Double>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCLongFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CLong GHC.Types.Float
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCLongFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CLong>_N <GHC.Types.Float>_N)) -}
ddf5b965197e42cda0929f8c91a07175
  $fToFloatingCLongFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CLong,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLong
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CLong)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Float)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLong) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Float
                   @ Foreign.C.Types.CLong
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CLong)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLong))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CLong -> GHC.Types.Float)
                      @ Foreign.C.Types.CLong
                      @ GHC.Types.Float
                      @~ <Foreign.C.Types.CLong -> GHC.Types.Float>_N
                      Data.Array.Accelerate.Type.$fIsNumCLong_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingFloat_$cfloatingType)
                   eta) -}
7a9df6b733014fba5114ae5836eaa223
  $fToFloatingCLongFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CLong,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLong
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCLongFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CLong>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Float>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CLong>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Float>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCShortCDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CShort Foreign.C.Types.CDouble
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCShortCDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CShort>_N <Foreign.C.Types.CDouble>_N)) -}
b0ceebd2d223828d9ca79a8fe05fde07
  $fToFloatingCShortCDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CShort,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CShort
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CShort)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CDouble)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CShort) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CDouble
                   @ Foreign.C.Types.CShort
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CShort)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CShort))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CShort -> Foreign.C.Types.CDouble)
                      @ Foreign.C.Types.CShort
                      @ Foreign.C.Types.CDouble
                      @~ <Foreign.C.Types.CShort -> Foreign.C.Types.CDouble>_N
                      Data.Array.Accelerate.Type.$fIsNumCShort_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCDouble_$cfloatingType)
                   eta) -}
2796dd7f68809f2999bfa3da8e2ef976
  $fToFloatingCShortCDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CShort,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CShort
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCShortCDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CShort>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CDouble>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CShort>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CDouble>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCShortCFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CShort Foreign.C.Types.CFloat
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCShortCFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CShort>_N <Foreign.C.Types.CFloat>_N)) -}
5663063e18ad1c8929054dc83207d630
  $fToFloatingCShortCFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CShort,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CShort
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CShort)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CFloat)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CShort) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CFloat
                   @ Foreign.C.Types.CShort
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CShort)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CShort))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CShort -> Foreign.C.Types.CFloat)
                      @ Foreign.C.Types.CShort
                      @ Foreign.C.Types.CFloat
                      @~ <Foreign.C.Types.CShort -> Foreign.C.Types.CFloat>_N
                      Data.Array.Accelerate.Type.$fIsNumCShort_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCFloat_$cfloatingType)
                   eta) -}
036c4ed2a1820636fd76cd36cbab6987
  $fToFloatingCShortCFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CShort,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CShort
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCShortCFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CShort>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CFloat>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CShort>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CFloat>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCShortDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CShort GHC.Types.Double
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCShortDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CShort>_N <GHC.Types.Double>_N)) -}
fb77084f40370ae05e5374f1487ec122
  $fToFloatingCShortDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CShort,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CShort
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CShort)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Double)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CShort) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Double
                   @ Foreign.C.Types.CShort
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CShort)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CShort))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CShort -> GHC.Types.Double)
                      @ Foreign.C.Types.CShort
                      @ GHC.Types.Double
                      @~ <Foreign.C.Types.CShort -> GHC.Types.Double>_N
                      Data.Array.Accelerate.Type.$fIsNumCShort_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingDouble_$cfloatingType)
                   eta) -}
41437bfb0c5d415e66fab2e7639b6eeb
  $fToFloatingCShortDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CShort,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CShort
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCShortDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CShort>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Double>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CShort>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Double>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCShortFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CShort GHC.Types.Float
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCShortFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CShort>_N <GHC.Types.Float>_N)) -}
1a7ea57334247b88cdd44d3a8f4c4444
  $fToFloatingCShortFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CShort,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CShort
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CShort)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Float)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CShort) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Float
                   @ Foreign.C.Types.CShort
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CShort)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CShort))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CShort -> GHC.Types.Float)
                      @ Foreign.C.Types.CShort
                      @ GHC.Types.Float
                      @~ <Foreign.C.Types.CShort -> GHC.Types.Float>_N
                      Data.Array.Accelerate.Type.$fIsNumCShort_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingFloat_$cfloatingType)
                   eta) -}
4ab422f73f6c4c48d18d82da873791c9
  $fToFloatingCShortFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CShort,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CShort
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCShortFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CShort>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Float>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CShort>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Float>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCUIntCDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CUInt Foreign.C.Types.CDouble
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCUIntCDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CUInt>_N <Foreign.C.Types.CDouble>_N)) -}
e106d420474a44bb72b92869ad16edb4
  $fToFloatingCUIntCDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CUInt,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUInt
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CUInt)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CDouble)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUInt) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CDouble
                   @ Foreign.C.Types.CUInt
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CUInt)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUInt))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CUInt -> Foreign.C.Types.CDouble)
                      @ Foreign.C.Types.CUInt
                      @ Foreign.C.Types.CDouble
                      @~ <Foreign.C.Types.CUInt -> Foreign.C.Types.CDouble>_N
                      Data.Array.Accelerate.Type.$fIsNumCUInt_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCDouble_$cfloatingType)
                   eta) -}
676eafba4492067493abfd81ede97d00
  $fToFloatingCUIntCDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CUInt,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUInt
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCUIntCDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CUInt>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CDouble>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUInt>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CDouble>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCUIntCFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CUInt Foreign.C.Types.CFloat
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCUIntCFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CUInt>_N <Foreign.C.Types.CFloat>_N)) -}
748d6d0b3a2ff1e60a7e9b983ce260a6
  $fToFloatingCUIntCFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CUInt,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUInt
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CUInt)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CFloat)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUInt) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CFloat
                   @ Foreign.C.Types.CUInt
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CUInt)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUInt))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CUInt -> Foreign.C.Types.CFloat)
                      @ Foreign.C.Types.CUInt
                      @ Foreign.C.Types.CFloat
                      @~ <Foreign.C.Types.CUInt -> Foreign.C.Types.CFloat>_N
                      Data.Array.Accelerate.Type.$fIsNumCUInt_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCFloat_$cfloatingType)
                   eta) -}
4b39d92c357687ea4ce991dff5cf8d58
  $fToFloatingCUIntCFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CUInt,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUInt
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCUIntCFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CUInt>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CFloat>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUInt>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CFloat>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCUIntDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CUInt GHC.Types.Double
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCUIntDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CUInt>_N <GHC.Types.Double>_N)) -}
25ae281221e1b3cdfa5f48575a03f42c
  $fToFloatingCUIntDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CUInt,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUInt
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CUInt)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Double)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUInt) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Double
                   @ Foreign.C.Types.CUInt
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CUInt)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUInt))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CUInt -> GHC.Types.Double)
                      @ Foreign.C.Types.CUInt
                      @ GHC.Types.Double
                      @~ <Foreign.C.Types.CUInt -> GHC.Types.Double>_N
                      Data.Array.Accelerate.Type.$fIsNumCUInt_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingDouble_$cfloatingType)
                   eta) -}
084720c14b83e0e88f9bb129ce6104d5
  $fToFloatingCUIntDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CUInt,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUInt
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCUIntDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CUInt>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Double>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUInt>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Double>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCUIntFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CUInt GHC.Types.Float
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCUIntFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CUInt>_N <GHC.Types.Float>_N)) -}
122c6e0976b2d8856e719b92401cb4fa
  $fToFloatingCUIntFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CUInt,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUInt
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CUInt)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Float)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUInt) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Float
                   @ Foreign.C.Types.CUInt
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CUInt)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUInt))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CUInt -> GHC.Types.Float)
                      @ Foreign.C.Types.CUInt
                      @ GHC.Types.Float
                      @~ <Foreign.C.Types.CUInt -> GHC.Types.Float>_N
                      Data.Array.Accelerate.Type.$fIsNumCUInt_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingFloat_$cfloatingType)
                   eta) -}
ad8012753d2e620181e222ee1b56fde6
  $fToFloatingCUIntFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CUInt,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUInt
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCUIntFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CUInt>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Float>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUInt>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Float>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCULLongCDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CULLong Foreign.C.Types.CDouble
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCULLongCDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CULLong>_N <Foreign.C.Types.CDouble>_N)) -}
2a79c4606b84c1d365a8fb7dbf962e95
  $fToFloatingCULLongCDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CULLong,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULLong
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CULLong)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CDouble)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULLong) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CDouble
                   @ Foreign.C.Types.CULLong
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CULLong)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULLong))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CULLong -> Foreign.C.Types.CDouble)
                      @ Foreign.C.Types.CULLong
                      @ Foreign.C.Types.CDouble
                      @~ <Foreign.C.Types.CULLong -> Foreign.C.Types.CDouble>_N
                      Data.Array.Accelerate.Type.$fIsNumCULLong_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCDouble_$cfloatingType)
                   eta) -}
8505f1f7ba3c62f632cbb4d2d8f6bca9
  $fToFloatingCULLongCDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CULLong,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULLong
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCULLongCDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CULLong>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CDouble>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULLong>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CDouble>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCULLongCFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CULLong Foreign.C.Types.CFloat
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCULLongCFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CULLong>_N <Foreign.C.Types.CFloat>_N)) -}
bbb36ee5950f23416efbafe1b6b22bf4
  $fToFloatingCULLongCFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CULLong,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULLong
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CULLong)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CFloat)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULLong) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CFloat
                   @ Foreign.C.Types.CULLong
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CULLong)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULLong))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CULLong -> Foreign.C.Types.CFloat)
                      @ Foreign.C.Types.CULLong
                      @ Foreign.C.Types.CFloat
                      @~ <Foreign.C.Types.CULLong -> Foreign.C.Types.CFloat>_N
                      Data.Array.Accelerate.Type.$fIsNumCULLong_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCFloat_$cfloatingType)
                   eta) -}
db4d2d1cda9308f2fa8807ee35c6e8a4
  $fToFloatingCULLongCFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CULLong,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULLong
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCULLongCFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CULLong>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CFloat>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULLong>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CFloat>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCULLongDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CULLong GHC.Types.Double
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCULLongDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CULLong>_N <GHC.Types.Double>_N)) -}
af6c8d97238ef6075a6803d5bb84268c
  $fToFloatingCULLongDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CULLong,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULLong
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CULLong)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Double)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULLong) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Double
                   @ Foreign.C.Types.CULLong
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CULLong)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULLong))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CULLong -> GHC.Types.Double)
                      @ Foreign.C.Types.CULLong
                      @ GHC.Types.Double
                      @~ <Foreign.C.Types.CULLong -> GHC.Types.Double>_N
                      Data.Array.Accelerate.Type.$fIsNumCULLong_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingDouble_$cfloatingType)
                   eta) -}
bbd5ca17d6a13d3d7d7dee990cd63ad6
  $fToFloatingCULLongDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CULLong,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULLong
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCULLongDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CULLong>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Double>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULLong>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Double>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCULLongFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CULLong GHC.Types.Float
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCULLongFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CULLong>_N <GHC.Types.Float>_N)) -}
bd6b13e826d3c94b304bb6da31fd79db
  $fToFloatingCULLongFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CULLong,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULLong
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CULLong)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Float)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULLong) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Float
                   @ Foreign.C.Types.CULLong
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CULLong)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULLong))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CULLong -> GHC.Types.Float)
                      @ Foreign.C.Types.CULLong
                      @ GHC.Types.Float
                      @~ <Foreign.C.Types.CULLong -> GHC.Types.Float>_N
                      Data.Array.Accelerate.Type.$fIsNumCULLong_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingFloat_$cfloatingType)
                   eta) -}
4fc0d332d760b5b7f8606973fd7d51a4
  $fToFloatingCULLongFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CULLong,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULLong
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCULLongFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CULLong>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Float>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULLong>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Float>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCULongCDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CULong Foreign.C.Types.CDouble
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCULongCDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CULong>_N <Foreign.C.Types.CDouble>_N)) -}
967aac03add73d22cd193a8d5d847291
  $fToFloatingCULongCDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CULong,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULong
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CULong)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CDouble)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULong) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CDouble
                   @ Foreign.C.Types.CULong
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CULong)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULong))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CULong -> Foreign.C.Types.CDouble)
                      @ Foreign.C.Types.CULong
                      @ Foreign.C.Types.CDouble
                      @~ <Foreign.C.Types.CULong -> Foreign.C.Types.CDouble>_N
                      Data.Array.Accelerate.Type.$fIsNumCULong_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCDouble_$cfloatingType)
                   eta) -}
4d39030895c245811a3e1f1e8dba0560
  $fToFloatingCULongCDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CULong,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULong
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCULongCDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CULong>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CDouble>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULong>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CDouble>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCULongCFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CULong Foreign.C.Types.CFloat
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCULongCFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CULong>_N <Foreign.C.Types.CFloat>_N)) -}
688ded0a43bfb41ddaca08160af3fae8
  $fToFloatingCULongCFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CULong,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULong
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CULong)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CFloat)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULong) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CFloat
                   @ Foreign.C.Types.CULong
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CULong)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULong))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CULong -> Foreign.C.Types.CFloat)
                      @ Foreign.C.Types.CULong
                      @ Foreign.C.Types.CFloat
                      @~ <Foreign.C.Types.CULong -> Foreign.C.Types.CFloat>_N
                      Data.Array.Accelerate.Type.$fIsNumCULong_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCFloat_$cfloatingType)
                   eta) -}
df9ee9a881b406d5ba8144e02f835684
  $fToFloatingCULongCFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CULong,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULong
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCULongCFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CULong>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CFloat>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULong>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CFloat>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCULongDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CULong GHC.Types.Double
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCULongDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CULong>_N <GHC.Types.Double>_N)) -}
c754a96ca33779a76283a7dbacebe136
  $fToFloatingCULongDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CULong,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULong
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CULong)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Double)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULong) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Double
                   @ Foreign.C.Types.CULong
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CULong)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULong))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CULong -> GHC.Types.Double)
                      @ Foreign.C.Types.CULong
                      @ GHC.Types.Double
                      @~ <Foreign.C.Types.CULong -> GHC.Types.Double>_N
                      Data.Array.Accelerate.Type.$fIsNumCULong_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingDouble_$cfloatingType)
                   eta) -}
2590a6b7003c06f972f1dc037e752421
  $fToFloatingCULongDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CULong,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULong
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCULongDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CULong>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Double>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULong>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Double>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCULongFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CULong GHC.Types.Float
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCULongFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CULong>_N <GHC.Types.Float>_N)) -}
47fadd7c9b7084145aafa8b617b706d2
  $fToFloatingCULongFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CULong,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULong
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CULong)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Float)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULong) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Float
                   @ Foreign.C.Types.CULong
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CULong)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULong))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CULong -> GHC.Types.Float)
                      @ Foreign.C.Types.CULong
                      @ GHC.Types.Float
                      @~ <Foreign.C.Types.CULong -> GHC.Types.Float>_N
                      Data.Array.Accelerate.Type.$fIsNumCULong_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingFloat_$cfloatingType)
                   eta) -}
71f06ed614134184883959caee945503
  $fToFloatingCULongFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CULong,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULong
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCULongFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CULong>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Float>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CULong>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Float>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCUShortCDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CUShort Foreign.C.Types.CDouble
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCUShortCDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CUShort>_N <Foreign.C.Types.CDouble>_N)) -}
478fa473d551af14eb0a9cddc85668ea
  $fToFloatingCUShortCDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CUShort,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUShort
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CUShort)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CDouble)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUShort) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CDouble
                   @ Foreign.C.Types.CUShort
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CUShort)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUShort))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CUShort -> Foreign.C.Types.CDouble)
                      @ Foreign.C.Types.CUShort
                      @ Foreign.C.Types.CDouble
                      @~ <Foreign.C.Types.CUShort -> Foreign.C.Types.CDouble>_N
                      Data.Array.Accelerate.Type.$fIsNumCUShort_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCDouble_$cfloatingType)
                   eta) -}
f1534d202c499ce74acce80c7a25fa4f
  $fToFloatingCUShortCDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CUShort,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUShort
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCUShortCDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CUShort>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CDouble>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUShort>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CDouble>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCUShortCFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CUShort Foreign.C.Types.CFloat
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCUShortCFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CUShort>_N <Foreign.C.Types.CFloat>_N)) -}
5fcad41715006145e18f72ee2806cb63
  $fToFloatingCUShortCFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CUShort,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUShort
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CUShort)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CFloat)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUShort) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CFloat
                   @ Foreign.C.Types.CUShort
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CUShort)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUShort))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CUShort -> Foreign.C.Types.CFloat)
                      @ Foreign.C.Types.CUShort
                      @ Foreign.C.Types.CFloat
                      @~ <Foreign.C.Types.CUShort -> Foreign.C.Types.CFloat>_N
                      Data.Array.Accelerate.Type.$fIsNumCUShort_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCFloat_$cfloatingType)
                   eta) -}
f36630aaa062e4ce06e388d065fe09c0
  $fToFloatingCUShortCFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CUShort,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUShort
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCUShortCFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CUShort>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CFloat>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUShort>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CFloat>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCUShortDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CUShort GHC.Types.Double
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCUShortDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CUShort>_N <GHC.Types.Double>_N)) -}
b7e8bba46aa1f16e4a9d1ccd8cacbf55
  $fToFloatingCUShortDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CUShort,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUShort
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CUShort)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Double)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUShort) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Double
                   @ Foreign.C.Types.CUShort
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CUShort)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUShort))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CUShort -> GHC.Types.Double)
                      @ Foreign.C.Types.CUShort
                      @ GHC.Types.Double
                      @~ <Foreign.C.Types.CUShort -> GHC.Types.Double>_N
                      Data.Array.Accelerate.Type.$fIsNumCUShort_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingDouble_$cfloatingType)
                   eta) -}
9da47f9b02af7c007863e57ebbcade3f
  $fToFloatingCUShortDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CUShort,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUShort
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCUShortDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CUShort>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Double>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUShort>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Double>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingCUShortFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      Foreign.C.Types.CUShort GHC.Types.Float
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCUShortFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <Foreign.C.Types.CUShort>_N <GHC.Types.Float>_N)) -}
f212263cb2f4c026e517c0ea76279638
  $fToFloatingCUShortFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CUShort,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUShort
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 Foreign.C.Types.CUShort)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Float)
                   (eta :: Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUShort) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Float
                   @ Foreign.C.Types.CUShort
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt Foreign.C.Types.CUShort)
                      @ (GHC.Num.Num
                           (Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUShort))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (Foreign.C.Types.CUShort -> GHC.Types.Float)
                      @ Foreign.C.Types.CUShort
                      @ GHC.Types.Float
                      @~ <Foreign.C.Types.CUShort -> GHC.Types.Float>_N
                      Data.Array.Accelerate.Type.$fIsNumCUShort_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingFloat_$cfloatingType)
                   eta) -}
be4416e439239cd941ed29c310a9f3ba
  $fToFloatingCUShortFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CUShort,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUShort
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCUShortFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num Foreign.C.Types.CUShort>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Float>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CUShort>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Float>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingDoubleCDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Types.Double Foreign.C.Types.CDouble
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingDoubleCDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Types.Double>_N <Foreign.C.Types.CDouble>_N)) -}
40542781f85c0aca5593593d3651596d
  $fToFloatingDoubleCDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Types.Double,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Double
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 GHC.Types.Double)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CDouble)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Types.Double) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CDouble
                   @ GHC.Types.Double
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Types.Double)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Types.Double))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Types.Double -> Foreign.C.Types.CDouble)
                      @ GHC.Types.Double
                      @ Foreign.C.Types.CDouble
                      @~ <GHC.Types.Double -> Foreign.C.Types.CDouble>_N
                      Data.Array.Accelerate.Type.$fIsNumDouble_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCDouble_$cfloatingType)
                   eta) -}
1cc9a658eb9cca906a49a741ddd8837e
  $fToFloatingDoubleCDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Types.Double,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Double
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingDoubleCDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Types.Double>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CDouble>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Types.Double>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CDouble>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingDoubleCFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Types.Double Foreign.C.Types.CFloat
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingDoubleCFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Types.Double>_N <Foreign.C.Types.CFloat>_N)) -}
2ff52014dc5d972d9ee5f8a93961e970
  $fToFloatingDoubleCFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Types.Double,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Double
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 GHC.Types.Double)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CFloat)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Types.Double) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CFloat
                   @ GHC.Types.Double
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Types.Double)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Types.Double))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Types.Double -> Foreign.C.Types.CFloat)
                      @ GHC.Types.Double
                      @ Foreign.C.Types.CFloat
                      @~ <GHC.Types.Double -> Foreign.C.Types.CFloat>_N
                      Data.Array.Accelerate.Type.$fIsNumDouble_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCFloat_$cfloatingType)
                   eta) -}
7eb2ba61096c15e9afe375363e790dfa
  $fToFloatingDoubleCFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Types.Double,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Double
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingDoubleCFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Types.Double>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CFloat>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Types.Double>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CFloat>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingDoubleDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Types.Double GHC.Types.Double
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingDoubleDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Types.Double>_N <GHC.Types.Double>_N)) -}
c25d1ab84abdac21a2723a596ff58399
  $fToFloatingDoubleDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Types.Double,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Double
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 GHC.Types.Double)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Double)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Types.Double) ->
                 let {
                   $dElt :: Data.Array.Accelerate.Array.Sugar.Elt GHC.Types.Double
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Types.Double)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Types.Double))
                       $d(%,%)
                 } in
                 (Data.Array.Accelerate.Smart.PrimApp
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ GHC.Types.Double
                    @ GHC.Types.Double
                    $dElt
                    $dElt
                    (Data.Array.Accelerate.AST.PrimToFloating
                       @ (GHC.Types.Double -> GHC.Types.Double)
                       @ GHC.Types.Double
                       @ GHC.Types.Double
                       @~ <GHC.Types.Double -> GHC.Types.Double>_N
                       Data.Array.Accelerate.Type.$fIsNumDouble_$cnumType
                       Data.Array.Accelerate.Type.$fIsFloatingDouble_$cfloatingType)
                    eta)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Double>_N)) -}
b200a93b337871def55a951dd340358b
  $fToFloatingDoubleFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Types.Double GHC.Types.Float
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingDoubleFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Types.Double>_N <GHC.Types.Float>_N)) -}
d7e3eb1b2c2ce13fb2e63d8e7c3cabff
  $fToFloatingDoubleFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Types.Double,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Double
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 GHC.Types.Double)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Float)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Types.Double) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Float
                   @ GHC.Types.Double
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Types.Double)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Types.Double))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Types.Double -> GHC.Types.Float)
                      @ GHC.Types.Double
                      @ GHC.Types.Float
                      @~ <GHC.Types.Double -> GHC.Types.Float>_N
                      Data.Array.Accelerate.Type.$fIsNumDouble_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingFloat_$cfloatingType)
                   eta) -}
133d340cc562909d48c4d258e675fe85
  $fToFloatingDoubleFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Types.Double,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Double
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingDoubleFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Types.Double>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Float>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Types.Double>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Float>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingFloatCDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Types.Float Foreign.C.Types.CDouble
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingFloatCDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Types.Float>_N <Foreign.C.Types.CDouble>_N)) -}
c80f870787da96127c5226285369776e
  $fToFloatingFloatCDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Types.Float,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Float
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 GHC.Types.Float)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CDouble)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Types.Float) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CDouble
                   @ GHC.Types.Float
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Types.Float)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Types.Float))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Types.Float -> Foreign.C.Types.CDouble)
                      @ GHC.Types.Float
                      @ Foreign.C.Types.CDouble
                      @~ <GHC.Types.Float -> Foreign.C.Types.CDouble>_N
                      Data.Array.Accelerate.Type.$fIsNumFloat_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCDouble_$cfloatingType)
                   eta) -}
fc05cc34cfa769ac8816ce40234ff95c
  $fToFloatingFloatCDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Types.Float,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Float
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingFloatCDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Types.Float>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CDouble>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Types.Float>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CDouble>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingFloatCFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Types.Float Foreign.C.Types.CFloat
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingFloatCFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Types.Float>_N <Foreign.C.Types.CFloat>_N)) -}
06ea309167374c67f7a95b065920985f
  $fToFloatingFloatCFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Types.Float,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Float
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 GHC.Types.Float)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CFloat)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Types.Float) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CFloat
                   @ GHC.Types.Float
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Types.Float)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Types.Float))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Types.Float -> Foreign.C.Types.CFloat)
                      @ GHC.Types.Float
                      @ Foreign.C.Types.CFloat
                      @~ <GHC.Types.Float -> Foreign.C.Types.CFloat>_N
                      Data.Array.Accelerate.Type.$fIsNumFloat_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCFloat_$cfloatingType)
                   eta) -}
15e864a44c00c60bc5406f93d156d13f
  $fToFloatingFloatCFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Types.Float,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Float
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingFloatCFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Types.Float>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CFloat>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Types.Float>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CFloat>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingFloatDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Types.Float GHC.Types.Double
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingFloatDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Types.Float>_N <GHC.Types.Double>_N)) -}
8bf68c93b6a36806efa1f59a9d02734c
  $fToFloatingFloatDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Types.Float,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Float
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 GHC.Types.Float)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Double)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Types.Float) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Double
                   @ GHC.Types.Float
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Types.Float)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Types.Float))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Types.Float -> GHC.Types.Double)
                      @ GHC.Types.Float
                      @ GHC.Types.Double
                      @~ <GHC.Types.Float -> GHC.Types.Double>_N
                      Data.Array.Accelerate.Type.$fIsNumFloat_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingDouble_$cfloatingType)
                   eta) -}
a9fef2a7ccbdb0f578742e9009210e42
  $fToFloatingFloatDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Types.Float,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Float
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingFloatDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Types.Float>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Double>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Types.Float>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Double>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingFloatFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Types.Float GHC.Types.Float
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingFloatFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Types.Float>_N <GHC.Types.Float>_N)) -}
91b82e5404f7c1934b906ff54defd9db
  $fToFloatingFloatFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Types.Float,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Float
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 GHC.Types.Float)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Float)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Types.Float) ->
                 let {
                   $dElt :: Data.Array.Accelerate.Array.Sugar.Elt GHC.Types.Float
                   = GHC.Classes.$p1(%,%)
                       @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Types.Float)
                       @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Types.Float))
                       $d(%,%)
                 } in
                 (Data.Array.Accelerate.Smart.PrimApp
                    @ Data.Array.Accelerate.Smart.Acc
                    @ Data.Array.Accelerate.Smart.Exp
                    @ GHC.Types.Float
                    @ GHC.Types.Float
                    $dElt
                    $dElt
                    (Data.Array.Accelerate.AST.PrimToFloating
                       @ (GHC.Types.Float -> GHC.Types.Float)
                       @ GHC.Types.Float
                       @ GHC.Types.Float
                       @~ <GHC.Types.Float -> GHC.Types.Float>_N
                       Data.Array.Accelerate.Type.$fIsNumFloat_$cnumType
                       Data.Array.Accelerate.Type.$fIsFloatingFloat_$cfloatingType)
                    eta)
                   `cast`
                 (Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Float>_N)) -}
b200a93b337871def55a951dd340358b
  $fToFloatingInt16CDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Int.Int16 Foreign.C.Types.CDouble
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt16CDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Int.Int16>_N <Foreign.C.Types.CDouble>_N)) -}
4326f4a48dbbc32b794b4ab33730e1f0
  $fToFloatingInt16CDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int16,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int16
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int16)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CDouble)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Int.Int16) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CDouble
                   @ GHC.Int.Int16
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Int.Int16)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Int.Int16))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Int.Int16 -> Foreign.C.Types.CDouble)
                      @ GHC.Int.Int16
                      @ Foreign.C.Types.CDouble
                      @~ <GHC.Int.Int16 -> Foreign.C.Types.CDouble>_N
                      Data.Array.Accelerate.Type.$fIsNumInt16_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCDouble_$cfloatingType)
                   eta) -}
189f2ac45658846281ffeacf5f9f6f2b
  $fToFloatingInt16CDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int16,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int16
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt16CDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int16>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CDouble>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Int.Int16>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CDouble>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingInt16CFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Int.Int16 Foreign.C.Types.CFloat
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt16CFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Int.Int16>_N <Foreign.C.Types.CFloat>_N)) -}
04e3e4127fc519e708c1d69634c77a94
  $fToFloatingInt16CFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int16,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int16
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int16)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CFloat)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Int.Int16) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CFloat
                   @ GHC.Int.Int16
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Int.Int16)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Int.Int16))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Int.Int16 -> Foreign.C.Types.CFloat)
                      @ GHC.Int.Int16
                      @ Foreign.C.Types.CFloat
                      @~ <GHC.Int.Int16 -> Foreign.C.Types.CFloat>_N
                      Data.Array.Accelerate.Type.$fIsNumInt16_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCFloat_$cfloatingType)
                   eta) -}
4dcb52ed246667030fc58d3469f4e09e
  $fToFloatingInt16CFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int16,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int16
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt16CFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int16>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CFloat>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Int.Int16>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CFloat>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingInt16Double ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Int.Int16 GHC.Types.Double
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt16Double_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Int.Int16>_N <GHC.Types.Double>_N)) -}
db85549e88ecffb0ed15e6dd39582db5
  $fToFloatingInt16Double1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int16,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int16
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int16)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Double)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Int.Int16) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Double
                   @ GHC.Int.Int16
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Int.Int16)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Int.Int16))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Int.Int16 -> GHC.Types.Double)
                      @ GHC.Int.Int16
                      @ GHC.Types.Double
                      @~ <GHC.Int.Int16 -> GHC.Types.Double>_N
                      Data.Array.Accelerate.Type.$fIsNumInt16_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingDouble_$cfloatingType)
                   eta) -}
ce748c2e180b5c5fc6dc67b6162c4fe2
  $fToFloatingInt16Double_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int16,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int16
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt16Double1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int16>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Double>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Int.Int16>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Double>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingInt16Float ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Int.Int16 GHC.Types.Float
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt16Float_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Int.Int16>_N <GHC.Types.Float>_N)) -}
f847c5565ed272f18a497ee525c9b6a9
  $fToFloatingInt16Float1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int16,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int16
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int16)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Float)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Int.Int16) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Float
                   @ GHC.Int.Int16
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Int.Int16)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Int.Int16))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Int.Int16 -> GHC.Types.Float)
                      @ GHC.Int.Int16
                      @ GHC.Types.Float
                      @~ <GHC.Int.Int16 -> GHC.Types.Float>_N
                      Data.Array.Accelerate.Type.$fIsNumInt16_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingFloat_$cfloatingType)
                   eta) -}
e1e0259bb1684573e796df9418d4db31
  $fToFloatingInt16Float_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int16,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int16
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt16Float1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int16>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Float>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Int.Int16>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Float>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingInt32CDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Int.Int32 Foreign.C.Types.CDouble
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt32CDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Int.Int32>_N <Foreign.C.Types.CDouble>_N)) -}
964846b25c2129bb244cc8e03e8a9de6
  $fToFloatingInt32CDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int32,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int32
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int32)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CDouble)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Int.Int32) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CDouble
                   @ GHC.Int.Int32
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Int.Int32)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Int.Int32))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Int.Int32 -> Foreign.C.Types.CDouble)
                      @ GHC.Int.Int32
                      @ Foreign.C.Types.CDouble
                      @~ <GHC.Int.Int32 -> Foreign.C.Types.CDouble>_N
                      Data.Array.Accelerate.Type.$fIsNumInt32_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCDouble_$cfloatingType)
                   eta) -}
e1c6a882895183e2f6bcb341005c9c25
  $fToFloatingInt32CDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int32,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int32
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt32CDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int32>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CDouble>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Int.Int32>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CDouble>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingInt32CFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Int.Int32 Foreign.C.Types.CFloat
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt32CFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Int.Int32>_N <Foreign.C.Types.CFloat>_N)) -}
59156a53327209aa94dda4d280a9bb8c
  $fToFloatingInt32CFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int32,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int32
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int32)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CFloat)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Int.Int32) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CFloat
                   @ GHC.Int.Int32
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Int.Int32)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Int.Int32))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Int.Int32 -> Foreign.C.Types.CFloat)
                      @ GHC.Int.Int32
                      @ Foreign.C.Types.CFloat
                      @~ <GHC.Int.Int32 -> Foreign.C.Types.CFloat>_N
                      Data.Array.Accelerate.Type.$fIsNumInt32_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCFloat_$cfloatingType)
                   eta) -}
69794c3fe0dff62b942d8084c4c02165
  $fToFloatingInt32CFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int32,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int32
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt32CFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int32>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CFloat>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Int.Int32>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CFloat>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingInt32Double ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Int.Int32 GHC.Types.Double
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt32Double_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Int.Int32>_N <GHC.Types.Double>_N)) -}
95adffa3c269e4826ba33e98f5cd137e
  $fToFloatingInt32Double1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int32,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int32
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int32)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Double)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Int.Int32) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Double
                   @ GHC.Int.Int32
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Int.Int32)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Int.Int32))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Int.Int32 -> GHC.Types.Double)
                      @ GHC.Int.Int32
                      @ GHC.Types.Double
                      @~ <GHC.Int.Int32 -> GHC.Types.Double>_N
                      Data.Array.Accelerate.Type.$fIsNumInt32_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingDouble_$cfloatingType)
                   eta) -}
65a9a8b48d98fa6cc58eef707246c01a
  $fToFloatingInt32Double_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int32,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int32
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt32Double1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int32>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Double>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Int.Int32>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Double>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingInt32Float ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Int.Int32 GHC.Types.Float
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt32Float_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Int.Int32>_N <GHC.Types.Float>_N)) -}
fd213bfe87cfacd17834bac14bda7990
  $fToFloatingInt32Float1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int32,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int32
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int32)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Float)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Int.Int32) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Float
                   @ GHC.Int.Int32
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Int.Int32)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Int.Int32))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Int.Int32 -> GHC.Types.Float)
                      @ GHC.Int.Int32
                      @ GHC.Types.Float
                      @~ <GHC.Int.Int32 -> GHC.Types.Float>_N
                      Data.Array.Accelerate.Type.$fIsNumInt32_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingFloat_$cfloatingType)
                   eta) -}
64f1a5430a2e16f115df5420e5ff7228
  $fToFloatingInt32Float_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int32,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int32
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt32Float1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int32>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Float>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Int.Int32>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Float>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingInt64CDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Int.Int64 Foreign.C.Types.CDouble
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt64CDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Int.Int64>_N <Foreign.C.Types.CDouble>_N)) -}
d5ab38b6a57e652d8aedb45377d204f6
  $fToFloatingInt64CDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int64,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int64
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int64)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CDouble)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Int.Int64) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CDouble
                   @ GHC.Int.Int64
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Int.Int64)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Int.Int64))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Int.Int64 -> Foreign.C.Types.CDouble)
                      @ GHC.Int.Int64
                      @ Foreign.C.Types.CDouble
                      @~ <GHC.Int.Int64 -> Foreign.C.Types.CDouble>_N
                      Data.Array.Accelerate.Type.$fIsNumInt64_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCDouble_$cfloatingType)
                   eta) -}
8c5a6ea87ec9e87742d612b3c9105c8e
  $fToFloatingInt64CDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int64,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int64
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt64CDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int64>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CDouble>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Int.Int64>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CDouble>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingInt64CFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Int.Int64 Foreign.C.Types.CFloat
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt64CFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Int.Int64>_N <Foreign.C.Types.CFloat>_N)) -}
ae6ecaf22ceab30d6b05b55fc2678b7c
  $fToFloatingInt64CFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int64,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int64
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int64)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CFloat)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Int.Int64) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CFloat
                   @ GHC.Int.Int64
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Int.Int64)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Int.Int64))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Int.Int64 -> Foreign.C.Types.CFloat)
                      @ GHC.Int.Int64
                      @ Foreign.C.Types.CFloat
                      @~ <GHC.Int.Int64 -> Foreign.C.Types.CFloat>_N
                      Data.Array.Accelerate.Type.$fIsNumInt64_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCFloat_$cfloatingType)
                   eta) -}
b7066cc4096406f0a61f4b72ac520e21
  $fToFloatingInt64CFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int64,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int64
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt64CFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int64>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CFloat>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Int.Int64>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CFloat>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingInt64Double ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Int.Int64 GHC.Types.Double
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt64Double_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Int.Int64>_N <GHC.Types.Double>_N)) -}
3193897d93a0a379afaf0dd7f4bcc7d3
  $fToFloatingInt64Double1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int64,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int64
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int64)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Double)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Int.Int64) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Double
                   @ GHC.Int.Int64
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Int.Int64)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Int.Int64))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Int.Int64 -> GHC.Types.Double)
                      @ GHC.Int.Int64
                      @ GHC.Types.Double
                      @~ <GHC.Int.Int64 -> GHC.Types.Double>_N
                      Data.Array.Accelerate.Type.$fIsNumInt64_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingDouble_$cfloatingType)
                   eta) -}
f2b1bd247c8758499a5c126e006477bc
  $fToFloatingInt64Double_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int64,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int64
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt64Double1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int64>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Double>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Int.Int64>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Double>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingInt64Float ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Int.Int64 GHC.Types.Float
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt64Float_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Int.Int64>_N <GHC.Types.Float>_N)) -}
dbee7d139309e1c99b87d95c00ef2957
  $fToFloatingInt64Float1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int64,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int64
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int64)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Float)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Int.Int64) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Float
                   @ GHC.Int.Int64
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Int.Int64)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Int.Int64))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Int.Int64 -> GHC.Types.Float)
                      @ GHC.Int.Int64
                      @ GHC.Types.Float
                      @~ <GHC.Int.Int64 -> GHC.Types.Float>_N
                      Data.Array.Accelerate.Type.$fIsNumInt64_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingFloat_$cfloatingType)
                   eta) -}
735384ede17d59c7dcc13a9df6e11e69
  $fToFloatingInt64Float_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int64,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int64
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt64Float1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int64>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Float>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Int.Int64>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Float>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingInt8CDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Int.Int8 Foreign.C.Types.CDouble
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt8CDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Int.Int8>_N <Foreign.C.Types.CDouble>_N)) -}
c026ccd138ab909355cf68f64d731e20
  $fToFloatingInt8CDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int8,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int8
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int8)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CDouble)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Int.Int8) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CDouble
                   @ GHC.Int.Int8
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Int.Int8)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Int.Int8))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Int.Int8 -> Foreign.C.Types.CDouble)
                      @ GHC.Int.Int8
                      @ Foreign.C.Types.CDouble
                      @~ <GHC.Int.Int8 -> Foreign.C.Types.CDouble>_N
                      Data.Array.Accelerate.Type.$fIsNumInt8_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCDouble_$cfloatingType)
                   eta) -}
e76df7a6db3c12fa99d05dd2fbb67a56
  $fToFloatingInt8CDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int8,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int8
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt8CDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int8>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CDouble>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Int.Int8>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CDouble>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingInt8CFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Int.Int8 Foreign.C.Types.CFloat
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt8CFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Int.Int8>_N <Foreign.C.Types.CFloat>_N)) -}
90fc3adc3601742725567ec4fc4648d4
  $fToFloatingInt8CFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int8,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int8
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int8)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CFloat)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Int.Int8) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CFloat
                   @ GHC.Int.Int8
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Int.Int8)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Int.Int8))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Int.Int8 -> Foreign.C.Types.CFloat)
                      @ GHC.Int.Int8
                      @ Foreign.C.Types.CFloat
                      @~ <GHC.Int.Int8 -> Foreign.C.Types.CFloat>_N
                      Data.Array.Accelerate.Type.$fIsNumInt8_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCFloat_$cfloatingType)
                   eta) -}
3d196846d6e4f4d76b46de5a96ae489d
  $fToFloatingInt8CFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int8,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int8
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt8CFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int8>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CFloat>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Int.Int8>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CFloat>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingInt8Double ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Int.Int8 GHC.Types.Double
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt8Double_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Int.Int8>_N <GHC.Types.Double>_N)) -}
dbd5e4e5d805546000eb4d082b3562f6
  $fToFloatingInt8Double1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int8,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int8
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int8)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Double)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Int.Int8) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Double
                   @ GHC.Int.Int8
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Int.Int8)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Int.Int8))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Int.Int8 -> GHC.Types.Double)
                      @ GHC.Int.Int8
                      @ GHC.Types.Double
                      @~ <GHC.Int.Int8 -> GHC.Types.Double>_N
                      Data.Array.Accelerate.Type.$fIsNumInt8_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingDouble_$cfloatingType)
                   eta) -}
1d090ba953eadf8e048008d4eb36e239
  $fToFloatingInt8Double_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int8,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int8
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt8Double1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int8>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Double>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Int.Int8>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Double>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingInt8Float ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Int.Int8 GHC.Types.Float
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt8Float_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Int.Int8>_N <GHC.Types.Float>_N)) -}
1af83dc56647390ce28096dd84cf2c8f
  $fToFloatingInt8Float1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int8,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int8
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int8)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Float)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Int.Int8) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Float
                   @ GHC.Int.Int8
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Int.Int8)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Int.Int8))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Int.Int8 -> GHC.Types.Float)
                      @ GHC.Int.Int8
                      @ GHC.Types.Float
                      @~ <GHC.Int.Int8 -> GHC.Types.Float>_N
                      Data.Array.Accelerate.Type.$fIsNumInt8_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingFloat_$cfloatingType)
                   eta) -}
b22292cad497ed445aa76384e6901714
  $fToFloatingInt8Float_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int8,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp GHC.Int.Int8
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt8Float1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Int.Int8>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Float>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Int.Int8>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Float>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingIntCDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Types.Int Foreign.C.Types.CDouble
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingIntCDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Types.Int>_N <Foreign.C.Types.CDouble>_N)) -}
a9ec18d14ba7951473d3492e04412743
  $fToFloatingIntCDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Types.Int,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Int
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num GHC.Types.Int)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CDouble)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Types.Int) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CDouble
                   @ GHC.Types.Int
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Types.Int)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Types.Int))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Types.Int -> Foreign.C.Types.CDouble)
                      @ GHC.Types.Int
                      @ Foreign.C.Types.CDouble
                      @~ <GHC.Types.Int -> Foreign.C.Types.CDouble>_N
                      Data.Array.Accelerate.Type.$fIsNumInt_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCDouble_$cfloatingType)
                   eta) -}
c4e7f5b883c29291c8aeb0613aa3965d
  $fToFloatingIntCDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Types.Int,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Int
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingIntCDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Types.Int>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CDouble>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Types.Int>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CDouble>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingIntCFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Types.Int Foreign.C.Types.CFloat
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingIntCFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Types.Int>_N <Foreign.C.Types.CFloat>_N)) -}
0de1a5abf06d2aee220737fe817d7f01
  $fToFloatingIntCFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Types.Int,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Int
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num GHC.Types.Int)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CFloat)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Types.Int) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CFloat
                   @ GHC.Types.Int
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Types.Int)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Types.Int))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Types.Int -> Foreign.C.Types.CFloat)
                      @ GHC.Types.Int
                      @ Foreign.C.Types.CFloat
                      @~ <GHC.Types.Int -> Foreign.C.Types.CFloat>_N
                      Data.Array.Accelerate.Type.$fIsNumInt_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCFloat_$cfloatingType)
                   eta) -}
4834fa46afe7d70854455fea85446d58
  $fToFloatingIntCFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Types.Int,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Int
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingIntCFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Types.Int>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CFloat>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Types.Int>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CFloat>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingIntDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Types.Int GHC.Types.Double
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingIntDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Types.Int>_N <GHC.Types.Double>_N)) -}
33e7c391eafb81997b2a1c2c171f21d2
  $fToFloatingIntDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Types.Int,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Int
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num GHC.Types.Int)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Double)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Types.Int) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Double
                   @ GHC.Types.Int
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Types.Int)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Types.Int))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Types.Int -> GHC.Types.Double)
                      @ GHC.Types.Int
                      @ GHC.Types.Double
                      @~ <GHC.Types.Int -> GHC.Types.Double>_N
                      Data.Array.Accelerate.Type.$fIsNumInt_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingDouble_$cfloatingType)
                   eta) -}
9e078fd97a56a70c86887d8cd8e324cc
  $fToFloatingIntDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Types.Int,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Int
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingIntDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Types.Int>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Double>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Types.Int>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Double>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingIntFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Types.Int GHC.Types.Float
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingIntFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Types.Int>_N <GHC.Types.Float>_N)) -}
ecb4a4946a35d9262e76946bb9abbc17
  $fToFloatingIntFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Types.Int,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Int
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num GHC.Types.Int)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Float)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Types.Int) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Float
                   @ GHC.Types.Int
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Types.Int)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Types.Int))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Types.Int -> GHC.Types.Float)
                      @ GHC.Types.Int
                      @ GHC.Types.Float
                      @~ <GHC.Types.Int -> GHC.Types.Float>_N
                      Data.Array.Accelerate.Type.$fIsNumInt_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingFloat_$cfloatingType)
                   eta) -}
520a662bc863a381fc9926b15bb72676
  $fToFloatingIntFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Types.Int,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Int
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingIntFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Types.Int>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Float>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Types.Int>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Float>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingWord16CDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Word.Word16 Foreign.C.Types.CDouble
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord16CDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Word.Word16>_N <Foreign.C.Types.CDouble>_N)) -}
563b09c394b0aa4a70be6d26ce0eb627
  $fToFloatingWord16CDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word16,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word16
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 GHC.Word.Word16)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CDouble)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Word.Word16) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CDouble
                   @ GHC.Word.Word16
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Word.Word16)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Word.Word16))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Word.Word16 -> Foreign.C.Types.CDouble)
                      @ GHC.Word.Word16
                      @ Foreign.C.Types.CDouble
                      @~ <GHC.Word.Word16 -> Foreign.C.Types.CDouble>_N
                      Data.Array.Accelerate.Type.$fIsNumWord16_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCDouble_$cfloatingType)
                   eta) -}
6412419f3d1589ac0b2031771931726f
  $fToFloatingWord16CDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word16,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word16
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord16CDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word16>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CDouble>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Word.Word16>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CDouble>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingWord16CFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Word.Word16 Foreign.C.Types.CFloat
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord16CFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Word.Word16>_N <Foreign.C.Types.CFloat>_N)) -}
5c80fc7743b2886a106b1b0c62668a46
  $fToFloatingWord16CFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word16,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word16
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 GHC.Word.Word16)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CFloat)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Word.Word16) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CFloat
                   @ GHC.Word.Word16
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Word.Word16)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Word.Word16))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Word.Word16 -> Foreign.C.Types.CFloat)
                      @ GHC.Word.Word16
                      @ Foreign.C.Types.CFloat
                      @~ <GHC.Word.Word16 -> Foreign.C.Types.CFloat>_N
                      Data.Array.Accelerate.Type.$fIsNumWord16_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCFloat_$cfloatingType)
                   eta) -}
985443891a7d87b9491e587260d14848
  $fToFloatingWord16CFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word16,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word16
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord16CFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word16>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CFloat>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Word.Word16>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CFloat>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingWord16Double ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Word.Word16 GHC.Types.Double
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord16Double_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Word.Word16>_N <GHC.Types.Double>_N)) -}
74e77e7cf33100be01322095114caa0d
  $fToFloatingWord16Double1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word16,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word16
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 GHC.Word.Word16)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Double)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Word.Word16) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Double
                   @ GHC.Word.Word16
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Word.Word16)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Word.Word16))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Word.Word16 -> GHC.Types.Double)
                      @ GHC.Word.Word16
                      @ GHC.Types.Double
                      @~ <GHC.Word.Word16 -> GHC.Types.Double>_N
                      Data.Array.Accelerate.Type.$fIsNumWord16_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingDouble_$cfloatingType)
                   eta) -}
b2e2e2e545bc31638ab452f80b50420f
  $fToFloatingWord16Double_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word16,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word16
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord16Double1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word16>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Double>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Word.Word16>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Double>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingWord16Float ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Word.Word16 GHC.Types.Float
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord16Float_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Word.Word16>_N <GHC.Types.Float>_N)) -}
b296d6fdb909133ef0e6a2ae6c999d5d
  $fToFloatingWord16Float1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word16,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word16
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 GHC.Word.Word16)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Float)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Word.Word16) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Float
                   @ GHC.Word.Word16
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Word.Word16)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Word.Word16))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Word.Word16 -> GHC.Types.Float)
                      @ GHC.Word.Word16
                      @ GHC.Types.Float
                      @~ <GHC.Word.Word16 -> GHC.Types.Float>_N
                      Data.Array.Accelerate.Type.$fIsNumWord16_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingFloat_$cfloatingType)
                   eta) -}
d0d61ca95b503191a21a5d9e05889445
  $fToFloatingWord16Float_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word16,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word16
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord16Float1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word16>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Float>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Word.Word16>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Float>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingWord32CDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Word.Word32 Foreign.C.Types.CDouble
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord32CDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Word.Word32>_N <Foreign.C.Types.CDouble>_N)) -}
adf110626ddf5072f81ba19cbc71b535
  $fToFloatingWord32CDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word32,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word32
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 GHC.Word.Word32)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CDouble)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Word.Word32) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CDouble
                   @ GHC.Word.Word32
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Word.Word32)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Word.Word32))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Word.Word32 -> Foreign.C.Types.CDouble)
                      @ GHC.Word.Word32
                      @ Foreign.C.Types.CDouble
                      @~ <GHC.Word.Word32 -> Foreign.C.Types.CDouble>_N
                      Data.Array.Accelerate.Type.$fIsNumWord32_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCDouble_$cfloatingType)
                   eta) -}
da587aaf6a09db1fa87dfff0ce67cf35
  $fToFloatingWord32CDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word32,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word32
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord32CDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word32>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CDouble>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Word.Word32>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CDouble>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingWord32CFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Word.Word32 Foreign.C.Types.CFloat
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord32CFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Word.Word32>_N <Foreign.C.Types.CFloat>_N)) -}
8295871e85dbb8b6070f8f50d2ab26c3
  $fToFloatingWord32CFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word32,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word32
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 GHC.Word.Word32)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CFloat)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Word.Word32) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CFloat
                   @ GHC.Word.Word32
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Word.Word32)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Word.Word32))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Word.Word32 -> Foreign.C.Types.CFloat)
                      @ GHC.Word.Word32
                      @ Foreign.C.Types.CFloat
                      @~ <GHC.Word.Word32 -> Foreign.C.Types.CFloat>_N
                      Data.Array.Accelerate.Type.$fIsNumWord32_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCFloat_$cfloatingType)
                   eta) -}
ade61831c68eff35ce12a6529ad7ea7d
  $fToFloatingWord32CFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word32,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word32
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord32CFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word32>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CFloat>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Word.Word32>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CFloat>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingWord32Double ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Word.Word32 GHC.Types.Double
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord32Double_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Word.Word32>_N <GHC.Types.Double>_N)) -}
6593b5cf91481a0cd06478bf1d2cafca
  $fToFloatingWord32Double1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word32,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word32
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 GHC.Word.Word32)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Double)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Word.Word32) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Double
                   @ GHC.Word.Word32
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Word.Word32)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Word.Word32))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Word.Word32 -> GHC.Types.Double)
                      @ GHC.Word.Word32
                      @ GHC.Types.Double
                      @~ <GHC.Word.Word32 -> GHC.Types.Double>_N
                      Data.Array.Accelerate.Type.$fIsNumWord32_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingDouble_$cfloatingType)
                   eta) -}
7329729fc371224530b3631180ce3866
  $fToFloatingWord32Double_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word32,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word32
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord32Double1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word32>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Double>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Word.Word32>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Double>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingWord32Float ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Word.Word32 GHC.Types.Float
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord32Float_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Word.Word32>_N <GHC.Types.Float>_N)) -}
0ae022d142b8d8d6b4e16996cc701f83
  $fToFloatingWord32Float1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word32,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word32
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 GHC.Word.Word32)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Float)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Word.Word32) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Float
                   @ GHC.Word.Word32
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Word.Word32)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Word.Word32))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Word.Word32 -> GHC.Types.Float)
                      @ GHC.Word.Word32
                      @ GHC.Types.Float
                      @~ <GHC.Word.Word32 -> GHC.Types.Float>_N
                      Data.Array.Accelerate.Type.$fIsNumWord32_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingFloat_$cfloatingType)
                   eta) -}
41c306024fd8103d22cdbe66ee4f45ae
  $fToFloatingWord32Float_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word32,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word32
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord32Float1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word32>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Float>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Word.Word32>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Float>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingWord64CDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Word.Word64 Foreign.C.Types.CDouble
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord64CDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Word.Word64>_N <Foreign.C.Types.CDouble>_N)) -}
f40b59b15881c1f77c5c76febe5b2546
  $fToFloatingWord64CDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word64,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word64
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 GHC.Word.Word64)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CDouble)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Word.Word64) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CDouble
                   @ GHC.Word.Word64
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Word.Word64)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Word.Word64))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Word.Word64 -> Foreign.C.Types.CDouble)
                      @ GHC.Word.Word64
                      @ Foreign.C.Types.CDouble
                      @~ <GHC.Word.Word64 -> Foreign.C.Types.CDouble>_N
                      Data.Array.Accelerate.Type.$fIsNumWord64_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCDouble_$cfloatingType)
                   eta) -}
a68adcef4a48c34839a7d455f449a766
  $fToFloatingWord64CDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word64,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word64
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord64CDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word64>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CDouble>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Word.Word64>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CDouble>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingWord64CFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Word.Word64 Foreign.C.Types.CFloat
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord64CFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Word.Word64>_N <Foreign.C.Types.CFloat>_N)) -}
39737c66ff78fe1720f6d2a3e3eb76cf
  $fToFloatingWord64CFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word64,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word64
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 GHC.Word.Word64)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CFloat)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Word.Word64) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CFloat
                   @ GHC.Word.Word64
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Word.Word64)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Word.Word64))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Word.Word64 -> Foreign.C.Types.CFloat)
                      @ GHC.Word.Word64
                      @ Foreign.C.Types.CFloat
                      @~ <GHC.Word.Word64 -> Foreign.C.Types.CFloat>_N
                      Data.Array.Accelerate.Type.$fIsNumWord64_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCFloat_$cfloatingType)
                   eta) -}
92cdad0ac79f5f08002538e2ac7896d3
  $fToFloatingWord64CFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word64,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word64
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord64CFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word64>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CFloat>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Word.Word64>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CFloat>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingWord64Double ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Word.Word64 GHC.Types.Double
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord64Double_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Word.Word64>_N <GHC.Types.Double>_N)) -}
c2460ca3a84d8d4a8ecefcc2e43afc59
  $fToFloatingWord64Double1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word64,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word64
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 GHC.Word.Word64)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Double)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Word.Word64) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Double
                   @ GHC.Word.Word64
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Word.Word64)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Word.Word64))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Word.Word64 -> GHC.Types.Double)
                      @ GHC.Word.Word64
                      @ GHC.Types.Double
                      @~ <GHC.Word.Word64 -> GHC.Types.Double>_N
                      Data.Array.Accelerate.Type.$fIsNumWord64_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingDouble_$cfloatingType)
                   eta) -}
1ad878f45cf1a907cf9def8be9be1480
  $fToFloatingWord64Double_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word64,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word64
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord64Double1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word64>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Double>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Word.Word64>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Double>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingWord64Float ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Word.Word64 GHC.Types.Float
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord64Float_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Word.Word64>_N <GHC.Types.Float>_N)) -}
7f8eac40ef567f802bd987088d9f1ab1
  $fToFloatingWord64Float1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word64,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word64
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 GHC.Word.Word64)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Float)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Word.Word64) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Float
                   @ GHC.Word.Word64
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Word.Word64)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Word.Word64))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Word.Word64 -> GHC.Types.Float)
                      @ GHC.Word.Word64
                      @ GHC.Types.Float
                      @~ <GHC.Word.Word64 -> GHC.Types.Float>_N
                      Data.Array.Accelerate.Type.$fIsNumWord64_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingFloat_$cfloatingType)
                   eta) -}
5fa9086adf82e1b60b3458cee5bd18a6
  $fToFloatingWord64Float_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word64,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word64
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord64Float1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word64>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Float>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Word.Word64>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Float>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingWord8CDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Word.Word8 Foreign.C.Types.CDouble
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord8CDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Word.Word8>_N <Foreign.C.Types.CDouble>_N)) -}
903a4d66134dd9ed47f9f90f6841cf58
  $fToFloatingWord8CDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word8,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word8
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 GHC.Word.Word8)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CDouble)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Word.Word8) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CDouble
                   @ GHC.Word.Word8
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Word.Word8)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Word.Word8))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Word.Word8 -> Foreign.C.Types.CDouble)
                      @ GHC.Word.Word8
                      @ Foreign.C.Types.CDouble
                      @~ <GHC.Word.Word8 -> Foreign.C.Types.CDouble>_N
                      Data.Array.Accelerate.Type.$fIsNumWord8_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCDouble_$cfloatingType)
                   eta) -}
22fd7a3d44dbc638a0c4fda97337f0ef
  $fToFloatingWord8CDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word8,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word8
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord8CDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word8>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CDouble>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Word.Word8>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CDouble>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingWord8CFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Word.Word8 Foreign.C.Types.CFloat
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord8CFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Word.Word8>_N <Foreign.C.Types.CFloat>_N)) -}
110fbbf2cdddd1b35c8cb4a3df094922
  $fToFloatingWord8CFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word8,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word8
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 GHC.Word.Word8)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CFloat)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Word.Word8) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CFloat
                   @ GHC.Word.Word8
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Word.Word8)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Word.Word8))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Word.Word8 -> Foreign.C.Types.CFloat)
                      @ GHC.Word.Word8
                      @ Foreign.C.Types.CFloat
                      @~ <GHC.Word.Word8 -> Foreign.C.Types.CFloat>_N
                      Data.Array.Accelerate.Type.$fIsNumWord8_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCFloat_$cfloatingType)
                   eta) -}
207a4eb2f73675766e5fb97c7b678076
  $fToFloatingWord8CFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word8,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word8
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord8CFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word8>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CFloat>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Word.Word8>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CFloat>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingWord8Double ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Word.Word8 GHC.Types.Double
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord8Double_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Word.Word8>_N <GHC.Types.Double>_N)) -}
9ad571f8316814ef9c7a21c9e97c13da
  $fToFloatingWord8Double1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word8,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word8
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 GHC.Word.Word8)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Double)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Word.Word8) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Double
                   @ GHC.Word.Word8
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Word.Word8)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Word.Word8))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Word.Word8 -> GHC.Types.Double)
                      @ GHC.Word.Word8
                      @ GHC.Types.Double
                      @~ <GHC.Word.Word8 -> GHC.Types.Double>_N
                      Data.Array.Accelerate.Type.$fIsNumWord8_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingDouble_$cfloatingType)
                   eta) -}
e558b343ca6d2cb36495a79d3f798736
  $fToFloatingWord8Double_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word8,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word8
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord8Double1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word8>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Double>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Word.Word8>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Double>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingWord8Float ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Word.Word8 GHC.Types.Float
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord8Float_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Word.Word8>_N <GHC.Types.Float>_N)) -}
b351914033fdf0cedae5c4f8638fa42f
  $fToFloatingWord8Float1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word8,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word8
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 GHC.Word.Word8)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Float)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Word.Word8) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Float
                   @ GHC.Word.Word8
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Word.Word8)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Word.Word8))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Word.Word8 -> GHC.Types.Float)
                      @ GHC.Word.Word8
                      @ GHC.Types.Float
                      @~ <GHC.Word.Word8 -> GHC.Types.Float>_N
                      Data.Array.Accelerate.Type.$fIsNumWord8_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingFloat_$cfloatingType)
                   eta) -}
f35a1b055b600487242c6347dce4fd12
  $fToFloatingWord8Float_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word8,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp GHC.Word.Word8
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord8Float1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Word.Word8>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Float>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Word.Word8>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Float>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingWordCDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Types.Word Foreign.C.Types.CDouble
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWordCDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Types.Word>_N <Foreign.C.Types.CDouble>_N)) -}
bed45e7f9b9dba1467928898f90f2366
  $fToFloatingWordCDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Types.Word,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Word
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 GHC.Types.Word)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CDouble)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Types.Word) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CDouble
                   @ GHC.Types.Word
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Types.Word)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Types.Word))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Types.Word -> Foreign.C.Types.CDouble)
                      @ GHC.Types.Word
                      @ Foreign.C.Types.CDouble
                      @~ <GHC.Types.Word -> Foreign.C.Types.CDouble>_N
                      Data.Array.Accelerate.Type.$fIsNumWord_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCDouble_$cfloatingType)
                   eta) -}
e8e7a8cd5162c4158d1c6379ffe3ae0b
  $fToFloatingWordCDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Types.Word,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CDouble) =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Word
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CDouble
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWordCDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Types.Word>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CDouble>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Types.Word>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CDouble>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingWordCFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Types.Word Foreign.C.Types.CFloat
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWordCFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Types.Word>_N <Foreign.C.Types.CFloat>_N)) -}
696b6f4146ecfaf16d68e7ca64f1fe86
  $fToFloatingWordCFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Types.Word,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Word
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 GHC.Types.Word)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  Foreign.C.Types.CFloat)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Types.Word) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ Foreign.C.Types.CFloat
                   @ GHC.Types.Word
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Types.Word)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Types.Word))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltCFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Types.Word -> Foreign.C.Types.CFloat)
                      @ GHC.Types.Word
                      @ Foreign.C.Types.CFloat
                      @~ <GHC.Types.Word -> Foreign.C.Types.CFloat>_N
                      Data.Array.Accelerate.Type.$fIsNumWord_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingCFloat_$cfloatingType)
                   eta) -}
607f45526b0651b37557e8db57aaea7f
  $fToFloatingWordCFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Types.Word,
     Data.Array.Accelerate.Classes.Floating.Floating
       Foreign.C.Types.CFloat) =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Word
    -> Data.Array.Accelerate.Smart.Exp Foreign.C.Types.CFloat
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWordCFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Types.Word>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         Foreign.C.Types.CFloat>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Types.Word>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <Foreign.C.Types.CFloat>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingWordDouble ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Types.Word GHC.Types.Double
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWordDouble_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Types.Word>_N <GHC.Types.Double>_N)) -}
cdcfa7de07fe378ea5692d48964543a8
  $fToFloatingWordDouble1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Types.Word,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Word
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 GHC.Types.Word)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Double)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Types.Word) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Double
                   @ GHC.Types.Word
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Types.Word)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Types.Word))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltDouble
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Types.Word -> GHC.Types.Double)
                      @ GHC.Types.Word
                      @ GHC.Types.Double
                      @~ <GHC.Types.Word -> GHC.Types.Double>_N
                      Data.Array.Accelerate.Type.$fIsNumWord_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingDouble_$cfloatingType)
                   eta) -}
ec8090bc72d3137fcb4959062f957ed3
  $fToFloatingWordDouble_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Types.Word,
     Data.Array.Accelerate.Classes.Floating.Floating
       GHC.Types.Double) =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Word
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Double
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWordDouble1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Types.Word>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Double>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Types.Word>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Double>_N) -}
b200a93b337871def55a951dd340358b
  $fToFloatingWordFloat ::
    Data.Array.Accelerate.Classes.ToFloating.ToFloating
      GHC.Types.Word GHC.Types.Float
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWordFloat_$ctoFloating
                  `cast`
                (Sym (Data.Array.Accelerate.Classes.ToFloating.N:ToFloating[0]
                          <GHC.Types.Word>_N <GHC.Types.Float>_N)) -}
f709050aa1a93d0b3830a78902936982
  $fToFloatingWordFloat1 ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Types.Word,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Word
    -> Data.Array.Accelerate.Smart.PreExp
         Data.Array.Accelerate.Smart.Acc
         Data.Array.Accelerate.Smart.Exp
         GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ ($d(%,%) :: Data.Array.Accelerate.Classes.Num.Num
                                 GHC.Types.Word)
                   ($d(%,%)1 :: Data.Array.Accelerate.Classes.Floating.Floating
                                  GHC.Types.Float)
                   (eta :: Data.Array.Accelerate.Smart.Exp GHC.Types.Word) ->
                 Data.Array.Accelerate.Smart.PrimApp
                   @ Data.Array.Accelerate.Smart.Acc
                   @ Data.Array.Accelerate.Smart.Exp
                   @ GHC.Types.Float
                   @ GHC.Types.Word
                   (GHC.Classes.$p1(%,%)
                      @ (Data.Array.Accelerate.Array.Sugar.Elt GHC.Types.Word)
                      @ (GHC.Num.Num (Data.Array.Accelerate.Smart.Exp GHC.Types.Word))
                      $d(%,%))
                   Data.Array.Accelerate.Array.Sugar.$fEltFloat
                   (Data.Array.Accelerate.AST.PrimToFloating
                      @ (GHC.Types.Word -> GHC.Types.Float)
                      @ GHC.Types.Word
                      @ GHC.Types.Float
                      @~ <GHC.Types.Word -> GHC.Types.Float>_N
                      Data.Array.Accelerate.Type.$fIsNumWord_$cnumType
                      Data.Array.Accelerate.Type.$fIsFloatingFloat_$cfloatingType)
                   eta) -}
c21b12cef2a46a77ea2f4b4dbefb3115
  $fToFloatingWordFloat_$ctoFloating ::
    (Data.Array.Accelerate.Classes.Num.Num GHC.Types.Word,
     Data.Array.Accelerate.Classes.Floating.Floating GHC.Types.Float) =>
    Data.Array.Accelerate.Smart.Exp GHC.Types.Word
    -> Data.Array.Accelerate.Smart.Exp GHC.Types.Float
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWordFloat1
                  `cast`
                (<Data.Array.Accelerate.Classes.Num.Num GHC.Types.Word>_R
                 ->_R <Data.Array.Accelerate.Classes.Floating.Floating
                         GHC.Types.Float>_R
                 ->_R <Data.Array.Accelerate.Smart.Exp GHC.Types.Word>_R
                 ->_R Sym (Data.Array.Accelerate.Smart.N:Exp[0]) <GHC.Types.Float>_N) -}
988a8cf525c7554e3073519f3164bb91
  $tc'C:ToFloating :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7864081538441327326##
                   3542469671843646377##
                   Data.Array.Accelerate.Classes.ToFloating.$trModule
                   Data.Array.Accelerate.Classes.ToFloating.$tc'C:ToFloating1) -}
e87387103495fecb453140c3b67da6ed
  $tc'C:ToFloating1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'C:ToFloating"#) -}
0807a0c601553c1c7f2c51fdd345259b
  $tcToFloating :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7488249584839884030##
                   12868735305919657485##
                   Data.Array.Accelerate.Classes.ToFloating.$trModule
                   Data.Array.Accelerate.Classes.ToFloating.$tcToFloating1) -}
200cd0c6edd963f9aad92010ef22903e
  $tcToFloating1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "ToFloating"#) -}
61070d052e4c6b28f3cb8cc0965673e0
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Data.Array.Accelerate.Classes.ToFloating.$trModule2
                   Data.Array.Accelerate.Classes.ToFloating.$trModule1) -}
a3c48c8cebb9b2f7549738384940fe54
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "Data.Array.Accelerate.Classes.ToFloating"#) -}
b195b140e8cfa13a94371dbea5437361
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "accelerate-1.0.0.0-5KTewgBt554ICR3vZPllxw"#) -}
b200a93b337871def55a951dd340358b
  class ToFloating a b where
    toFloating :: (Data.Array.Accelerate.Classes.Num.Num a,
                   Data.Array.Accelerate.Classes.Floating.Floating b) =>
                  Data.Array.Accelerate.Smart.Exp a
                  -> Data.Array.Accelerate.Smart.Exp b
    {-# MINIMAL toFloating #-}
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CDouble,
                                                              Foreign.C.Types.CDouble]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCDoubleCDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CDouble,
                                                              Foreign.C.Types.CFloat]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCDoubleCFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CDouble,
                                                              GHC.Types.Double]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCDoubleDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CDouble,
                                                              GHC.Types.Float]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCDoubleFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CFloat,
                                                              Foreign.C.Types.CDouble]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCFloatCDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CFloat,
                                                              Foreign.C.Types.CFloat]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCFloatCFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CFloat,
                                                              GHC.Types.Double]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCFloatDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CFloat,
                                                              GHC.Types.Float]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCFloatFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CInt,
                                                              Foreign.C.Types.CDouble]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCIntCDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CInt,
                                                              Foreign.C.Types.CFloat]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCIntCFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CInt,
                                                              GHC.Types.Double]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCIntDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CInt,
                                                              GHC.Types.Float]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCIntFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CLLong,
                                                              Foreign.C.Types.CDouble]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCLLongCDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CLLong,
                                                              Foreign.C.Types.CFloat]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCLLongCFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CLLong,
                                                              GHC.Types.Double]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCLLongDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CLLong,
                                                              GHC.Types.Float]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCLLongFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CLong,
                                                              Foreign.C.Types.CDouble]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCLongCDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CLong,
                                                              Foreign.C.Types.CFloat]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCLongCFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CLong,
                                                              GHC.Types.Double]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCLongDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CLong,
                                                              GHC.Types.Float]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCLongFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CShort,
                                                              Foreign.C.Types.CDouble]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCShortCDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CShort,
                                                              Foreign.C.Types.CFloat]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCShortCFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CShort,
                                                              GHC.Types.Double]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCShortDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CShort,
                                                              GHC.Types.Float]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCShortFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CUInt,
                                                              Foreign.C.Types.CDouble]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCUIntCDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CUInt,
                                                              Foreign.C.Types.CFloat]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCUIntCFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CUInt,
                                                              GHC.Types.Double]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCUIntDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CUInt,
                                                              GHC.Types.Float]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCUIntFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CULLong,
                                                              Foreign.C.Types.CDouble]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCULLongCDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CULLong,
                                                              Foreign.C.Types.CFloat]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCULLongCFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CULLong,
                                                              GHC.Types.Double]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCULLongDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CULLong,
                                                              GHC.Types.Float]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCULLongFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CULong,
                                                              Foreign.C.Types.CDouble]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCULongCDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CULong,
                                                              Foreign.C.Types.CFloat]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCULongCFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CULong,
                                                              GHC.Types.Double]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCULongDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CULong,
                                                              GHC.Types.Float]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCULongFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CUShort,
                                                              Foreign.C.Types.CDouble]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCUShortCDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CUShort,
                                                              Foreign.C.Types.CFloat]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCUShortCFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CUShort,
                                                              GHC.Types.Double]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCUShortDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [Foreign.C.Types.CUShort,
                                                              GHC.Types.Float]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingCUShortFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Types.Double,
                                                              Foreign.C.Types.CDouble]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingDoubleCDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Types.Double,
                                                              Foreign.C.Types.CFloat]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingDoubleCFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Types.Double,
                                                              GHC.Types.Double]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingDoubleDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Types.Double,
                                                              GHC.Types.Float]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingDoubleFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Types.Float,
                                                              Foreign.C.Types.CDouble]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingFloatCDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Types.Float,
                                                              Foreign.C.Types.CFloat]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingFloatCFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Types.Float,
                                                              GHC.Types.Double]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingFloatDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Types.Float,
                                                              GHC.Types.Float]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingFloatFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Int.Int16,
                                                              Foreign.C.Types.CDouble]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt16CDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Int.Int16,
                                                              Foreign.C.Types.CFloat]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt16CFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Int.Int16,
                                                              GHC.Types.Double]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt16Double
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Int.Int16,
                                                              GHC.Types.Float]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt16Float
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Int.Int32,
                                                              Foreign.C.Types.CDouble]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt32CDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Int.Int32,
                                                              Foreign.C.Types.CFloat]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt32CFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Int.Int32,
                                                              GHC.Types.Double]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt32Double
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Int.Int32,
                                                              GHC.Types.Float]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt32Float
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Int.Int64,
                                                              Foreign.C.Types.CDouble]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt64CDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Int.Int64,
                                                              Foreign.C.Types.CFloat]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt64CFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Int.Int64,
                                                              GHC.Types.Double]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt64Double
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Int.Int64,
                                                              GHC.Types.Float]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt64Float
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Int.Int8,
                                                              Foreign.C.Types.CDouble]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt8CDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Int.Int8,
                                                              Foreign.C.Types.CFloat]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt8CFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Int.Int8,
                                                              GHC.Types.Double]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt8Double
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Int.Int8,
                                                              GHC.Types.Float]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingInt8Float
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Types.Int,
                                                              Foreign.C.Types.CDouble]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingIntCDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Types.Int,
                                                              Foreign.C.Types.CFloat]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingIntCFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Types.Int,
                                                              GHC.Types.Double]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingIntDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Types.Int,
                                                              GHC.Types.Float]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingIntFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Word.Word16,
                                                              Foreign.C.Types.CDouble]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord16CDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Word.Word16,
                                                              Foreign.C.Types.CFloat]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord16CFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Word.Word16,
                                                              GHC.Types.Double]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord16Double
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Word.Word16,
                                                              GHC.Types.Float]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord16Float
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Word.Word32,
                                                              Foreign.C.Types.CDouble]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord32CDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Word.Word32,
                                                              Foreign.C.Types.CFloat]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord32CFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Word.Word32,
                                                              GHC.Types.Double]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord32Double
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Word.Word32,
                                                              GHC.Types.Float]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord32Float
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Word.Word64,
                                                              Foreign.C.Types.CDouble]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord64CDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Word.Word64,
                                                              Foreign.C.Types.CFloat]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord64CFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Word.Word64,
                                                              GHC.Types.Double]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord64Double
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Word.Word64,
                                                              GHC.Types.Float]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord64Float
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Word.Word8,
                                                              Foreign.C.Types.CDouble]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord8CDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Word.Word8,
                                                              Foreign.C.Types.CFloat]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord8CFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Word.Word8,
                                                              GHC.Types.Double]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord8Double
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Word.Word8,
                                                              GHC.Types.Float]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWord8Float
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Types.Word,
                                                              Foreign.C.Types.CDouble]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWordCDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Types.Word,
                                                              Foreign.C.Types.CFloat]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWordCFloat
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Types.Word,
                                                              GHC.Types.Double]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWordDouble
instance Data.Array.Accelerate.Classes.ToFloating.ToFloating [GHC.Types.Word,
                                                              GHC.Types.Float]
  = Data.Array.Accelerate.Classes.ToFloating.$fToFloatingWordFloat
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

